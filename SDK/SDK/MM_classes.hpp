#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MM

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "MM_structs.hpp"


namespace SDK
{

// Class MM.FilmstormFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFilmstormFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CreatePlayerInputDirection(struct FInputPlayerDirectionData* OutConstructTargetDirection, const struct FTransform& DesiredTransform, const struct FTransform& RootWorldTransform, const float TargetDirectionInputStrength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FilmstormFunctionLibrary">();
	}
	static class UFilmstormFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFilmstormFunctionLibrary>();
	}
};
//static_assert(alignof(UFilmstormFunctionLibrary) == 0x000008, "Wrong alignment on UFilmstormFunctionLibrary");
//static_assert(sizeof(UFilmstormFunctionLibrary) == 0x000028, "Wrong size on UFilmstormFunctionLibrary");

// Class MM.MotionMatchingHelpers
// 0x0000 (0x0028 - 0x0028)
class UMotionMatchingHelpers final : public UObject
{
public:
	static void BlendKeyPoses(const struct FMotionMatchData& PoseA, const struct FMotionMatchData& PoseB, const float Alpha, struct FMotionMatchData* OutBlendedKeyPose);
	static float CompareJointDatas(const TArray<struct FSkeletonStructure>& JointData_A, const TArray<struct FSkeletonStructure>& JointData_B);
	static float CompareTrajectories(const struct FInputPlayerDirectionData& InputDirectionData_A, const struct FInputPlayerDirectionData& InputDirectionData_B);
	static void CreateInputDirection(struct FInputPlayerDirectionData* OutConstructTargetDirection, const struct FTransform& DesiredTransform, const struct FTransform& RootWorldTransform, const float TargetDirectionInputStrength);
	static void ExtractAnimInputDirection(struct FInputPlayerDirectionData* DeliveredVelocityViaAnimBonesLocalVelocityData, const class UAnimSequence* InSequence, const float ClockInGame);
	static void ExtractAnimSmoothedRotation(struct FQuat* DeliveredRotation, const class UAnimSequence* InSequence, const float ClockInGame);
	static void ExtractLMAnimInputDirection(struct FInputPlayerDirectionData* DeliveredVelocityViaAnimBonesLocalVelocityData, const class UAnimSequence* InSequence, const float ClockInGame);
	static void GetAnimBoneLocalTransform(const class UAnimSequence* InSequence, const float ReferenceClock, const int32 CurrentSkeletonPartInReference, const TMap<int32, int32>& SkelIdx2TrackIdx, struct FTransform* CalculatedTransformMM);
	static void GetAnimBoneLocalVel(const class UAnimSequence* InSequence, const float ReferenceClock, const int32 CurrentSkeletonPartInReference, const TMap<int32, int32>& SkelIdx2TrackIdx, struct FVector* DeliveredVelocityViaAnimBonesLocalVel);
	static void GetAnimBoneWorldTransform(const class UAnimSequence* InSequence, const float ReferenceClock, const int32 CurrentSkeletonPartInReference, const TMap<int32, int32>& SkelIdx2TrackIdx, struct FTransform* CalculatedTransformMM);
	static void GetAnimJointData(const class UAnimSequence* InSequence, const float ReferenceClock, const class FName BoneName, struct FSkeletonStructure* DeliveredAnimationReferencesForSkelRef, float InDeltaTime);
	static void GetAnimVelocityReferenceClock(const class UAnimSequence* InSequence, const float ReferenceClock, struct FVector* DeliveredVelocityViaAnimBonesLocalVelocity);
	static void GetDataFromAnimation(const class UAnimSequence* InSequence, const float ReferenceClock, const TArray<class FName>& SkeletonRuntimeName, struct FInputPlayerDirectionData* OutPresentInputDirection, struct FInputPlayerDirectionData* OutFutureInputDirection, TArray<struct FSkeletonStructure>* DeliveredAnimationReferencesForSkelRef);
	static void GetKeyPoseDataFromAnim(const class UAnimSequence* InSequence, const float ReferenceClock, const TArray<class FName>& ToBeRefAgainst, struct FMotionMatchData* CalculatedMMData);
	static struct FTransform GetLastInputDirectionTransform(const struct FInputPlayerDirectionData& InputDirection);
	static void GetLMAnimVelocityReferenceClock(const class UAnimSequence* InSequence, const float ReferenceClock, struct FVector* DeliveredVelocityViaAnimBonesLocalVelocity);
	static class FString GetMMAnimDataRecordFilePath();
	static bool MakeInputDirectionData(struct FInputPlayerDirectionData* OutInputDirection, const TArray<struct FTransform>& VectorsWeHaveLeftBehind, const TArray<struct FVector>& CheckTheseAgainstVWHLB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionMatchingHelpers">();
	}
	static class UMotionMatchingHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionMatchingHelpers>();
	}
};
//static_assert(alignof(UMotionMatchingHelpers) == 0x000008, "Wrong alignment on UMotionMatchingHelpers");
//static_assert(sizeof(UMotionMatchingHelpers) == 0x000028, "Wrong size on UMotionMatchingHelpers");

// Class MM.AnimationAnalyzer
// 0x00D0 (0x00F8 - 0x0028)
class UAnimationAnalyzer : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              SelectedSkeleton;                                  // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KDTreeNodeRootIndex;                               // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseLMAnim;                                        // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastMatchedAnimIndex;                              // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControllerInputReactionSpeed;                      // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControllerRotateReactionSpeed;                     // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMMKDTreeNode>                  MMKDTree;                                          // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMotionMatchingMath>            AnimationReferences;                               // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReferencedJoints;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, float>                            JointWeights;                                      // 0x0080(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AnimationsInMemory;                                // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMotionMatchingAnimSeqdata>     AnimationSeqSoftDatas;                             // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUsingAssetSoftRef;                                // 0x00F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnalyzerAnimationReferences(const int32 CurrentReferenceAnimation);
	bool AnimationCalculationsAccepted(const int32 Ref);
	bool AnimationContextIsValid(const int32 CurrentAnimationRef);
	bool AnimationReferenceIsValid(const int32 CurrentAnimationRef);
	bool CheckIsFirstLoadRequireDesireAsset(const int32 Ref);
	void CleanAllAnimationReferences();
	void CleanAnimationReferences(const int32 CurrentReferenceAnimation);
	void ClearAllAnimSeqForCalculatingInEditor();
	void ConstructAllAnimationReferences();
	void ConstructAnimationReferences(const int32 FromSourceAnimation);
	void ConstructSerializedFeatures();
	int32 CountAnimationReferences();
	class UAnimSequence* FindAnimationFromSequence(const int32 CurrentAnimationRef);
	class UAnimSequence* FindAnimationsAtDesiredReferences(const int32 Ref);
	int32 FindUserSelectedBones();
	class FName FindUsersSkeletonBoneNames(int32 ReferencedBone);
	void GatherSkeletonInfo(class USkeleton* UserSkeleton, const TArray<class FName>& SelectedJoints, const TArray<float>& BoneWeights);
	class USkeleton* GetAnimationAnalyzerSkeleton();
	int32 GetAnimationCount();
	class FText GetAnimationShowNameInEditor(const int32 Ref);
	struct FSoftObjectPath GetSoftPathByIndex(const int32 Ref);
	bool HasSequence(const class FName SequenceName);
	void InitAnimMathDataBySerializedFeatures();
	bool IsAnimationExtracted(const class FName AnimationRef, const float WorldTime);
	bool IsAnimMathDataValid();
	bool IsUseLMAnim();
	void LoadAllAnimSeqFromSoftRefForCalculatingInEditor();
	int32 MatchAnimationByKDTree(const float VelocityStrength, const struct FInputPlayerDirectionData& InputDirection, const TArray<struct FSkeletonStructure>& MotionJointData, const struct FVector& PresentVel, float* MinSquareDis);
	void MMAnimationSeqUsingNotify_Inner(const int32 Ref, class AActor* Owner);
	void NewAnimationReference(const TArray<class UAnimSequence*>& ProvidedAnimationsByUser);
	void OnAnimationAssetLoadStatChange(const int32 Ref, EAnimSeqAssetLoadStatType Stat, class UAnimSequence* Anim);
	void RemoveAnimationReference(const int32 CurrentAnimationRef);
	int32 RequireAnimationsLoadAtDesiredReferences(const int32 Ref, bool bLoadAll, class UObject* AnimInst);
	void SetUseLMAnim(bool bUse);
	int32 StructureForAnimationCalculations(const float ControllerInputReactionSpeedCustom, const float ControllerRotateReactionSpeedCustom, const float VelocityStrength, const float AnimationMatchPower, const struct FInputPlayerDirectionData& InputDirection, const TArray<struct FSkeletonStructure>& AllAnimationReferences, const struct FVector& PresentVel, const float BlendTime, float* CalculatedResult, struct FMotionMatchingCostData* AnimCostData);
	bool TryInitFromAA(const class UAnimationAnalyzer* OrgAA);

	const struct FMotionMatchingMath GetSequenceTimeOfAnimations(const int32 CurrentAnimationKeyframe) const;
	bool IsBoneSelected(const class FName& BoneName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationAnalyzer">();
	}
	static class UAnimationAnalyzer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationAnalyzer>();
	}
};
//static_assert(alignof(UAnimationAnalyzer) == 0x000008, "Wrong alignment on UAnimationAnalyzer");
//static_assert(sizeof(UAnimationAnalyzer) == 0x0000F8, "Wrong size on UAnimationAnalyzer");
//static_assert(offsetof(UAnimationAnalyzer, SelectedSkeleton) == 0x000030, "Member 'UAnimationAnalyzer::SelectedSkeleton' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, KDTreeNodeRootIndex) == 0x000038, "Member 'UAnimationAnalyzer::KDTreeNodeRootIndex' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, bUseLMAnim) == 0x00003C, "Member 'UAnimationAnalyzer::bUseLMAnim' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, LastMatchedAnimIndex) == 0x000040, "Member 'UAnimationAnalyzer::LastMatchedAnimIndex' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, ControllerInputReactionSpeed) == 0x000044, "Member 'UAnimationAnalyzer::ControllerInputReactionSpeed' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, ControllerRotateReactionSpeed) == 0x000048, "Member 'UAnimationAnalyzer::ControllerRotateReactionSpeed' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, MMKDTree) == 0x000050, "Member 'UAnimationAnalyzer::MMKDTree' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, AnimationReferences) == 0x000060, "Member 'UAnimationAnalyzer::AnimationReferences' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, ReferencedJoints) == 0x000070, "Member 'UAnimationAnalyzer::ReferencedJoints' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, JointWeights) == 0x000080, "Member 'UAnimationAnalyzer::JointWeights' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, AnimationsInMemory) == 0x0000D0, "Member 'UAnimationAnalyzer::AnimationsInMemory' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, AnimationSeqSoftDatas) == 0x0000E0, "Member 'UAnimationAnalyzer::AnimationSeqSoftDatas' has a wrong offset!");
//static_assert(offsetof(UAnimationAnalyzer, bUsingAssetSoftRef) == 0x0000F0, "Member 'UAnimationAnalyzer::bUsingAssetSoftRef' has a wrong offset!");

}

