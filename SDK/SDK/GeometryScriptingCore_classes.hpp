#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GeometryScriptingCore

#include "Basic.hpp"

#include "GeometryScriptingCore_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class GeometryScriptingCore.GeometryScriptLibrary_CollisionFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_CollisionFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void ResetDynamicMeshCollision(class UDynamicMeshComponent* Component, bool bEmitTransaction, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetDynamicMeshCollisionFromMesh(class UDynamicMesh* FromDynamicMesh, class UDynamicMeshComponent* ToDynamicMeshComponent, const struct FGeometryScriptCollisionFromMeshOptions& Options, class UGeometryScriptDebug* Debug);
	static void SetStaticMeshCollisionFromComponent(class UStaticMesh* StaticMeshAsset, class UPrimitiveComponent* SourceComponent, const struct FGeometryScriptSetSimpleCollisionOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetStaticMeshCollisionFromMesh(class UDynamicMesh* FromDynamicMesh, class UStaticMesh* ToStaticMeshAsset, const struct FGeometryScriptCollisionFromMeshOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_CollisionFunctions">();
	}
	static class UGeometryScriptLibrary_CollisionFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_CollisionFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_CollisionFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_CollisionFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_CollisionFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_CollisionFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_ContainmentFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_ContainmentFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ComputeMeshConvexHull(class UDynamicMesh* TargetMesh, class UDynamicMesh*& CopyToMesh, class UDynamicMesh** CopyToMeshOut, const struct FGeometryScriptConvexHullOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputeMeshSweptHull(class UDynamicMesh* TargetMesh, class UDynamicMesh*& CopyToMesh, class UDynamicMesh** CopyToMeshOut, const struct FTransform& ProjectionFrame, const struct FGeometryScriptSweptHullOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_ContainmentFunctions">();
	}
	static class UGeometryScriptLibrary_ContainmentFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_ContainmentFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_ContainmentFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_ContainmentFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_ContainmentFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_ContainmentFunctions");

// Class GeometryScriptingCore.GeometryScriptDebug
// 0x0010 (0x0038 - 0x0028)
class UGeometryScriptDebug final : public UObject
{
public:
	TArray<struct FGeometryScriptDebugMessage>    Messages;                                          // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptDebug">();
	}
	static class UGeometryScriptDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptDebug>();
	}
};
//static_assert(alignof(UGeometryScriptDebug) == 0x000008, "Wrong alignment on UGeometryScriptDebug");
//static_assert(sizeof(UGeometryScriptDebug) == 0x000038, "Wrong size on UGeometryScriptDebug");
//static_assert(offsetof(UGeometryScriptDebug, Messages) == 0x000028, "Member 'UGeometryScriptDebug::Messages' has a wrong offset!");

// Class GeometryScriptingCore.GeometryScriptLibrary_ListUtilityFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_ListUtilityFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertArrayToColorList(const TArray<struct FLinearColor>& ColorArray, struct FGeometryScriptColorList* ColorList);
	static void ConvertArrayToIndexList(const TArray<int32>& IndexArray, struct FGeometryScriptIndexList* IndexList, EGeometryScriptIndexType IndexType);
	static void ConvertArrayToTriangleList(const TArray<struct FIntVector>& TriangleArray, struct FGeometryScriptTriangleList* TriangleList);
	static void ConvertArrayToUVList(const TArray<struct FVector2D>& UVArray, struct FGeometryScriptUVList* UVList);
	static void ConvertArrayToVectorList(const TArray<struct FVector>& VectorArray, struct FGeometryScriptVectorList* VectorList);
	static void ConvertColorListToArray(const struct FGeometryScriptColorList& ColorList, TArray<struct FLinearColor>* ColorArray);
	static void ConvertIndexListToArray(const struct FGeometryScriptIndexList& IndexList, TArray<int32>* IndexArray);
	static void ConvertTriangleListToArray(const struct FGeometryScriptTriangleList& TriangleList, TArray<struct FIntVector>* TriangleArray);
	static void ConvertUVListToArray(const struct FGeometryScriptUVList& UVList, TArray<struct FVector2D>* UVArray);
	static void ConvertVectorListToArray(const struct FGeometryScriptVectorList& VectorList, TArray<struct FVector>* VectorArray);
	static struct FLinearColor GetColorListItem(const struct FGeometryScriptColorList& ColorList, int32 Index_0, bool* bIsValidIndex);
	static int32 GetColorListLastIndex(const struct FGeometryScriptColorList& ColorList);
	static int32 GetColorListLength(const struct FGeometryScriptColorList& ColorList);
	static int32 GetIndexListItem(const struct FGeometryScriptIndexList& IndexList, int32 Index_0, bool* bIsValidIndex);
	static int32 GetIndexListLastIndex(const struct FGeometryScriptIndexList& IndexList);
	static int32 GetIndexListLength(const struct FGeometryScriptIndexList& IndexList);
	static struct FIntVector GetTriangleListItem(const struct FGeometryScriptTriangleList& TriangleList, int32 Triangle, bool* bIsValidTriangle);
	static int32 GetTriangleListLastTriangle(const struct FGeometryScriptTriangleList& TriangleList);
	static int32 GetTriangleListLength(const struct FGeometryScriptTriangleList& TriangleList);
	static struct FVector2D GetUVListItem(const struct FGeometryScriptUVList& UVList, int32 Index_0, bool* bIsValidIndex);
	static int32 GetUVListLastIndex(const struct FGeometryScriptUVList& UVList);
	static int32 GetUVListLength(const struct FGeometryScriptUVList& UVList);
	static struct FVector GetVectorListItem(const struct FGeometryScriptVectorList& VectorList, int32 Index_0, bool* bIsValidIndex);
	static int32 GetVectorListLastIndex(const struct FGeometryScriptVectorList& VectorList);
	static int32 GetVectorListLength(const struct FGeometryScriptVectorList& VectorList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_ListUtilityFunctions">();
	}
	static class UGeometryScriptLibrary_ListUtilityFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_ListUtilityFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_ListUtilityFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_ListUtilityFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_ListUtilityFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_ListUtilityFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_StaticMeshFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_StaticMeshFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* CopyMeshFromStaticMesh(class UStaticMesh* FromStaticMeshAsset, class UDynamicMesh* ToDynamicMesh, const struct FGeometryScriptCopyMeshFromAssetOptions& AssetOptions, const struct FGeometryScriptMeshReadLOD& RequestedLOD, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyMeshToStaticMesh(class UDynamicMesh* FromDynamicMesh, class UStaticMesh* ToStaticMeshAsset, const struct FGeometryScriptCopyMeshToAssetOptions& Options, const struct FGeometryScriptMeshWriteLOD& TargetLod, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static void GetSectionMaterialListFromStaticMesh(class UStaticMesh* FromStaticMeshAsset, const struct FGeometryScriptMeshReadLOD& RequestedLOD, TArray<class UMaterialInterface*>* MaterialList, TArray<int32>* MaterialIndex, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_StaticMeshFunctions">();
	}
	static class UGeometryScriptLibrary_StaticMeshFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_StaticMeshFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_StaticMeshFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_StaticMeshFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_StaticMeshFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_StaticMeshFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshBasicEditFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshBasicEditFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* AddTrianglesToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptTriangleList& NewTrianglesList, struct FGeometryScriptIndexList* NewIndicesList, int32 NewTriangleGroupID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AddTriangleToMesh(class UDynamicMesh* TargetMesh, const struct FIntVector& NewTriangle, int32* NewTriangleIndex, int32 NewTriangleGroupID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AddVertexToMesh(class UDynamicMesh* TargetMesh, const struct FVector& NewPosition, int32* NewVertexIndex, bool bDeferChangeNotifications);
	static class UDynamicMesh* AddVerticesToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptVectorList& NewPositionsList, struct FGeometryScriptIndexList* NewIndicesList, bool bDeferChangeNotifications);
	static class UDynamicMesh* AppendBuffersToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptSimpleMeshBuffers& Buffers, struct FGeometryScriptIndexList* NewTriangleIndicesList, int32 MaterialID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendMesh(class UDynamicMesh* TargetMesh, class UDynamicMesh* AppendMesh_0, const struct FTransform& AppendTransform, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendMeshRepeated(class UDynamicMesh* TargetMesh, class UDynamicMesh* AppendMesh, const struct FTransform& AppendTransform, int32 RepeatCount, bool bApplyTransformToFirstInstance, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* DeleteTriangleFromMesh(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bWasTriangleDeleted, bool bDeferChangeNotifications);
	static class UDynamicMesh* DeleteTrianglesFromMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptIndexList& TriangleList, int32* NumDeleted, bool bDeferChangeNotifications);
	static class UDynamicMesh* DeleteVertexFromMesh(class UDynamicMesh* TargetMesh, int32 VertexID, bool* bWasVertexDeleted, bool bDeferChangeNotifications);
	static class UDynamicMesh* DeleteVerticesFromMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptIndexList& VertexList, int32* NumDeleted, bool bDeferChangeNotifications);
	static class UDynamicMesh* DiscardMeshAttributes(class UDynamicMesh* TargetMesh, bool bDeferChangeNotifications);
	static class UDynamicMesh* SetVertexPosition(class UDynamicMesh* TargetMesh, int32 VertexID, const struct FVector& NewPosition, bool* bIsValidVertex, bool bDeferChangeNotifications);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshBasicEditFunctions">();
	}
	static class UGeometryScriptLibrary_MeshBasicEditFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshBasicEditFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshBasicEditFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshBasicEditFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshBasicEditFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshBasicEditFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshBooleanFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshBooleanFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyMeshBoolean(class UDynamicMesh* TargetMesh, const struct FTransform& TargetTransform, class UDynamicMesh* ToolMesh, const struct FTransform& ToolTransform, EGeometryScriptBooleanOperation Operation, const struct FGeometryScriptMeshBooleanOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshMirror(class UDynamicMesh* TargetMesh, const struct FTransform& MirrorFrame, const struct FGeometryScriptMeshMirrorOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshPlaneCut(class UDynamicMesh* TargetMesh, const struct FTransform& CutFrame, const struct FGeometryScriptMeshPlaneCutOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshPlaneSlice(class UDynamicMesh* TargetMesh, const struct FTransform& CutFrame, const struct FGeometryScriptMeshPlaneSliceOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshSelfUnion(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelfUnionOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshBooleanFunctions">();
	}
	static class UGeometryScriptLibrary_MeshBooleanFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshBooleanFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshBooleanFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshBooleanFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshBooleanFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshBooleanFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshComparisonFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshComparisonFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* IsIntersectingMesh(class UDynamicMesh* TargetMesh, const struct FTransform& TargetTransform, class UDynamicMesh* OtherMesh, const struct FTransform& OtherTransform, bool* bIsIntersecting, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* IsSameMeshAs(class UDynamicMesh* TargetMesh, class UDynamicMesh* OtherMesh, const struct FGeometryScriptIsSameMeshOptions& Options, bool* bIsSameMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* MeasureDistancesBetweenMeshes(class UDynamicMesh* TargetMesh, class UDynamicMesh* OtherMesh, const struct FGeometryScriptMeasureMeshDistanceOptions& Options, double* MaxDistance, double* MinDistance, double* AverageDistance, double* RootMeanSqrDeviation, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshComparisonFunctions">();
	}
	static class UGeometryScriptLibrary_MeshComparisonFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshComparisonFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshComparisonFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshComparisonFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshComparisonFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshComparisonFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshDecompositionFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshDecompositionFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* CopyMeshToMesh(class UDynamicMesh* CopyFromMesh, class UDynamicMesh*& CopyToMesh, class UDynamicMesh** CopyToMeshOut, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetSubMeshFromMesh(class UDynamicMesh* TargetMesh, class UDynamicMesh*& StoreToSubmesh, const struct FGeometryScriptIndexList& TriangleList, class UDynamicMesh** StoreToSubmeshOut, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SplitMeshByComponents(class UDynamicMesh* TargetMesh, TArray<class UDynamicMesh*>* ComponentMeshes, class UDynamicMeshPool* MeshPool, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SplitMeshByMaterialIDs(class UDynamicMesh* TargetMesh, TArray<class UDynamicMesh*>* ComponentMeshes, TArray<int32>* ComponentMaterialIDs, class UDynamicMeshPool* MeshPool, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SplitMeshByPolygroups(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, TArray<class UDynamicMesh*>* ComponentMeshes, TArray<int32>* ComponentPolygroups, class UDynamicMeshPool* MeshPool, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshDecompositionFunctions">();
	}
	static class UGeometryScriptLibrary_MeshDecompositionFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshDecompositionFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshDecompositionFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshDecompositionFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshDecompositionFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshDecompositionFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshDeformFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshDeformFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyBendWarpToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptBendWarpOptions& Options, const struct FTransform& BendOrientation, float BendAngle, float BendExtent, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyDisplaceFromTextureMap(class UDynamicMesh* TargetMesh, class UTexture2D* Texture, const struct FGeometryScriptDisplaceFromTextureOptions& Options, int32 UVLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyFlareWarpToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptFlareWarpOptions& Options, const struct FTransform& FlareOrientation, float FlarePercentX, float FlarePercentY, float FlareExtent, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyIterativeSmoothingToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptIterativeMeshSmoothingOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMathWarpToMesh(class UDynamicMesh* TargetMesh, const struct FTransform& WarpOrientation, EGeometryScriptMathWarpType WarpType, const struct FGeometryScriptMathWarpOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyPerlinNoiseToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPerlinNoiseOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyTwistWarpToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptTwistWarpOptions& Options, const struct FTransform& TwistOrientation, float TwistAngle, float TwistExtent, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshDeformFunctions">();
	}
	static class UGeometryScriptLibrary_MeshDeformFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshDeformFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshDeformFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshDeformFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshDeformFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshDeformFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshMaterialFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshMaterialFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ClearMaterialIDs(class UDynamicMesh* TargetMesh, int32 ClearValue, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CompactMaterialIDs(class UDynamicMesh* TargetMesh, const TArray<class UMaterialInterface*>& SourceMaterialList, TArray<class UMaterialInterface*>* CompactedMaterialList, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* DeleteTrianglesByMaterialID(class UDynamicMesh* TargetMesh, int32 MaterialID, int32* NumDeleted, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* EnableMaterialIDs(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetAllTriangleMaterialIDs(class UDynamicMesh* TargetMesh, struct FGeometryScriptIndexList* MaterialIDList, bool* bHasMaterialIDs);
	static int32 GetMaxMaterialID(class UDynamicMesh* TargetMesh, bool* bHasMaterialIDs);
	static int32 GetTriangleMaterialID(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bIsValidTriangle);
	static class UDynamicMesh* RemapMaterialIDs(class UDynamicMesh* TargetMesh, int32 FromMaterialID, int32 ToMaterialID, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetAllTriangleMaterialIDs(class UDynamicMesh* TargetMesh, struct FGeometryScriptIndexList* TriangleMaterialIDList, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetPolygroupMaterialID(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 PolygroupID, int32 MaterialID, bool* bIsValidPolygroupID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetTriangleMaterialID(class UDynamicMesh* TargetMesh, int32 TriangleID, int32 MaterialID, bool* bIsValidTriangle, bool bDeferChangeNotifications);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshMaterialFunctions">();
	}
	static class UGeometryScriptLibrary_MeshMaterialFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshMaterialFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshMaterialFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshMaterialFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshMaterialFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshMaterialFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshModelingFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshModelingFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyMeshExtrude(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshExtrudeOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshOffset(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshOffsetOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshPolygroupBevel(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshBevelOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshShell(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshOffsetOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshModelingFunctions">();
	}
	static class UGeometryScriptLibrary_MeshModelingFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshModelingFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshModelingFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshModelingFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshModelingFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshModelingFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshNormalsFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshNormalsFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* AutoRepairNormals(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputeSplitNormals(class UDynamicMesh* TargetMesh, const struct FGeometryScriptSplitNormalsOptions& SplitOptions, const struct FGeometryScriptCalculateNormalsOptions& CalculateOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputeTangents(class UDynamicMesh* TargetMesh, const struct FGeometryScriptTangentsOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* FlipNormals(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RecomputeNormals(class UDynamicMesh* TargetMesh, const struct FGeometryScriptCalculateNormalsOptions& CalculateOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshTriangleNormals(class UDynamicMesh* TargetMesh, int32 TriangleID, const struct FGeometryScriptTriangle& Normals, bool* bIsValidTriangle, bool bDeferChangeNotifications);
	static class UDynamicMesh* SetPerFaceNormals(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetPerVertexNormals(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshNormalsFunctions">();
	}
	static class UGeometryScriptLibrary_MeshNormalsFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshNormalsFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshNormalsFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshNormalsFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshNormalsFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshNormalsFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshPolygroupFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshPolygroupFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ClearPolygroups(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 ClearValue, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputePolygroupsFromAngleThreshold(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, float CreaseAngle, int32 MinGroupSize, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ConvertComponentsToPolygroups(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ConvertUVIslandsToPolygroups(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 UVLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyPolygroupsLayer(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& FromGroupLayer, const struct FGeometryScriptGroupLayer& ToGroupLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* DeleteTrianglesInPolygroup(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 PolygroupID, int32* NumDeleted, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* EnablePolygroups(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetAllTrianglePolygroupIDs(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, struct FGeometryScriptIndexList& PolygroupIDsOut);
	static class UDynamicMesh* GetPolygroupIDsInMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, struct FGeometryScriptIndexList& PolygroupIDsOut);
	static int32 GetTrianglePolygroupID(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 TriangleID, bool* bIsValidTriangle);
	static class UDynamicMesh* GetTrianglesInPolygroup(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 PolygroupID, struct FGeometryScriptIndexList& TriangleIDsOut);
	static class UDynamicMesh* SetNumExtendedPolygroupLayers(class UDynamicMesh* TargetMesh, int32 NumLayers, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshPolygroupFunctions">();
	}
	static class UGeometryScriptLibrary_MeshPolygroupFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshPolygroupFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshPolygroupFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshPolygroupFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshPolygroupFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshPolygroupFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshPrimitiveFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshPrimitiveFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* AppendBox(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, float DimensionZ, int32 StepsX, int32 StepsY, int32 StepsZ, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendCapsule(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, float LineLength, int32 HemisphereSteps, int32 CircleSteps, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendCone(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float BaseRadius, float TopRadius, float Height, int32 RadialSteps, int32 HeightSteps, bool bCapped, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendCurvedStairs(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float StepWidth, float StepHeight, float InnerRadius, float CurveAngle, int32 NumSteps, bool bFloating, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendCylinder(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, float Height, int32 RadialSteps, int32 HeightSteps, bool bCapped, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendDisc(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, int32 AngleSteps, int32 SpokeSteps, float StartAngle, float EndAngle, float HoleRadius, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendLinearStairs(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float StepWidth, float StepHeight, float StepDepth, int32 NumSteps, bool bFloating, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRectangle_Compatibility_5_0(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, int32 StepsWidth, int32 StepsHeight, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRectangleXY(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, int32 StepsWidth, int32 StepsHeight, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRevolvePath(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PathVertices, const struct FGeometryScriptRevolveOptions& RevolveOptions, int32 Steps, bool bCapped, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRevolvePolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, const struct FGeometryScriptRevolveOptions& RevolveOptions, float Radius, int32 Steps, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRoundRectangle_Compatibility_5_0(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, float CornerRadius, int32 StepsWidth, int32 StepsHeight, int32 StepsRound, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRoundRectangleXY(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, float CornerRadius, int32 StepsWidth, int32 StepsHeight, int32 StepsRound, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSimpleExtrudePolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, float Height, int32 HeightSteps, bool bCapped, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSimpleSweptPolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, const TArray<struct FVector>& SweepPath, bool bLoop, bool bCapped, float StartScale, float EndScale, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSphereBox(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, int32 StepsX, int32 StepsY, int32 StepsZ, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSphereLatLong(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, int32 StepsPhi, int32 StepsTheta, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSpiralRevolvePolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, const struct FGeometryScriptRevolveOptions& RevolveOptions, float Radius, int32 Steps, float RisePerRevolution, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendTorus(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const struct FGeometryScriptRevolveOptions& RevolveOptions, float MajorRadius, float MinorRadius, int32 MajorSteps, int32 MinorSteps, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendTriangulatedPolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, bool bAllowSelfIntersections, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshPrimitiveFunctions">();
	}
	static class UGeometryScriptLibrary_MeshPrimitiveFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshPrimitiveFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshPrimitiveFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshPrimitiveFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshPrimitiveFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshPrimitiveFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshQueryFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshQueryFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* GetAllTriangleIDs(class UDynamicMesh* TargetMesh, struct FGeometryScriptIndexList* TriangleIDList, bool* bHasTriangleIDGaps);
	static class UDynamicMesh* GetAllTriangleIndices(class UDynamicMesh* TargetMesh, struct FGeometryScriptTriangleList* TriangleList, bool bSkipGaps, bool* bHasTriangleIDGaps);
	static class UDynamicMesh* GetAllVertexIDs(class UDynamicMesh* TargetMesh, struct FGeometryScriptIndexList* VertexIDList, bool* bHasVertexIDGaps);
	static class UDynamicMesh* GetAllVertexPositions(class UDynamicMesh* TargetMesh, struct FGeometryScriptVectorList* PositionList, bool bSkipGaps, bool* bHasVertexIDGaps);
	static bool GetHasMaterialIDs(class UDynamicMesh* TargetMesh);
	static bool GetHasPolygroups(class UDynamicMesh* TargetMesh);
	static bool GetHasTriangleIDGaps(class UDynamicMesh* TargetMesh);
	static bool GetHasVertexIDGaps(class UDynamicMesh* TargetMesh);
	static bool GetIsClosedMesh(class UDynamicMesh* TargetMesh);
	static bool GetIsDenseMesh(class UDynamicMesh* TargetMesh);
	static struct FBox GetMeshBoundingBox(class UDynamicMesh* TargetMesh);
	static bool GetMeshHasAttributeSet(class UDynamicMesh* TargetMesh);
	static void GetMeshVolumeArea(class UDynamicMesh* TargetMesh, float* SurfaceArea, float* Volume);
	static int32 GetNumConnectedComponents(class UDynamicMesh* TargetMesh);
	static int32 GetNumExtendedPolygroupLayers(class UDynamicMesh* TargetMesh);
	static int32 GetNumOpenBorderEdges(class UDynamicMesh* TargetMesh);
	static int32 GetNumOpenBorderLoops(class UDynamicMesh* TargetMesh, bool* bAmbiguousTopologyFound);
	static int32 GetNumTriangleIDs(class UDynamicMesh* TargetMesh);
	static int32 GetNumUVSets(class UDynamicMesh* TargetMesh);
	static int32 GetNumVertexIDs(class UDynamicMesh* TargetMesh);
	static struct FVector GetTriangleFaceNormal(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bIsValidTriangle);
	static struct FIntVector GetTriangleIndices(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bIsValidTriangle);
	static void GetTrianglePositions(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bIsValidTriangle, struct FVector* Vertex1, struct FVector* Vertex2, struct FVector* Vertex3);
	static void GetTriangleUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 TriangleID, struct FVector2D* UV1, struct FVector2D* UV2, struct FVector2D* UV3, bool* bHaveValidUVs);
	static struct FBox2D GetUVSetBoundingBox(class UDynamicMesh* TargetMesh, int32 UvSetIndex, bool* bIsValidUVSet, bool* bUVSetIsEmpty);
	static int32 GetVertexCount(class UDynamicMesh* TargetMesh);
	static struct FVector GetVertexPosition(class UDynamicMesh* TargetMesh, int32 VertexID, bool* bIsValidVertex);
	static bool IsValidTriangleID(class UDynamicMesh* TargetMesh, int32 TriangleID);
	static bool IsValidVertexID(class UDynamicMesh* TargetMesh, int32 VertexID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshQueryFunctions">();
	}
	static class UGeometryScriptLibrary_MeshQueryFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshQueryFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshQueryFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshQueryFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshQueryFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshQueryFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshRepairFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshRepairFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* CompactMesh(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* FillAllMeshHoles(class UDynamicMesh* TargetMesh, const struct FGeometryScriptFillHolesOptions& FillOptions, int32* NumFilledHoles, int32* NumFailedHoleFills, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RemoveHiddenTriangles(class UDynamicMesh* TargetMesh, const struct FGeometryScriptRemoveHiddenTrianglesOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RemoveSmallComponents(class UDynamicMesh* TargetMesh, const struct FGeometryScriptRemoveSmallComponentOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* WeldMeshEdges(class UDynamicMesh* TargetMesh, const struct FGeometryScriptWeldEdgesOptions& WeldOptions, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshRepairFunctions">();
	}
	static class UGeometryScriptLibrary_MeshRepairFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshRepairFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshRepairFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshRepairFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshRepairFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshRepairFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshSimplifyFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshSimplifyFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplySimplifyToPlanar(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPlanarSimplifyOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplySimplifyToPolygroupTopology(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPolygroupSimplifyOptions& Options, const struct FGeometryScriptGroupLayer& GroupLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplySimplifyToTolerance(class UDynamicMesh* TargetMesh, float Tolerance, const struct FGeometryScriptSimplifyMeshOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplySimplifyToTriangleCount(class UDynamicMesh* TargetMesh, int32 TriangleCount, const struct FGeometryScriptSimplifyMeshOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplySimplifyToVertexCount(class UDynamicMesh* TargetMesh, int32 Vertexcount, const struct FGeometryScriptSimplifyMeshOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshSimplifyFunctions">();
	}
	static class UGeometryScriptLibrary_MeshSimplifyFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshSimplifyFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshSimplifyFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshSimplifyFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshSimplifyFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshSimplifyFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshSpatial
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshSpatial final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* BuildBVHForMesh(class UDynamicMesh* TargetMesh, struct FGeometryScriptDynamicMeshBVH* OutputBVH, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* FindNearestPointOnMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDynamicMeshBVH& QueryBVH, const struct FVector& QueryPoint, const struct FGeometryScriptSpatialQueryOptions& Options, struct FGeometryScriptTrianglePoint* NearestResult, EGeometryScriptSearchOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* FindNearestRayIntersectionWithMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDynamicMeshBVH& QueryBVH, const struct FVector& RayOrigin, const struct FVector& RayDirection, const struct FGeometryScriptSpatialQueryOptions& Options, struct FGeometryScriptRayHitResult* HitResult, EGeometryScriptSearchOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* IsBVHValidForMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDynamicMeshBVH& TestBVH, bool* bIsValid, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* IsPointInsideMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDynamicMeshBVH& QueryBVH, const struct FVector& QueryPoint, const struct FGeometryScriptSpatialQueryOptions& Options, bool* bIsInside, EGeometryScriptContainmentOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RebuildBVHForMesh(class UDynamicMesh* TargetMesh, struct FGeometryScriptDynamicMeshBVH& UpdateBVH, bool bOnlyIfInvalid, class UGeometryScriptDebug* Debug);
	static void ResetBVH(struct FGeometryScriptDynamicMeshBVH& ResetBVH_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshSpatial">();
	}
	static class UGeometryScriptLibrary_MeshSpatial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshSpatial>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshSpatial) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshSpatial");
//static_assert(sizeof(UGeometryScriptLibrary_MeshSpatial) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshSpatial");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshSubdivideFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshSubdivideFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyPNTessellation(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPNTessellateOptions& Options, int32 TessellationLevel, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyRecursivePNTessellation(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPNTessellateOptions& Options, int32 NumIterations, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyUniformTessellation(class UDynamicMesh* TargetMesh, int32 TessellationLevel, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshSubdivideFunctions">();
	}
	static class UGeometryScriptLibrary_MeshSubdivideFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshSubdivideFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshSubdivideFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshSubdivideFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshSubdivideFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshSubdivideFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshTransformFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshTransformFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ScaleMesh(class UDynamicMesh* TargetMesh, const struct FVector& Scale, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* TransformMesh(class UDynamicMesh* TargetMesh, const struct FTransform& Transform, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* TranslateMesh(class UDynamicMesh* TargetMesh, const struct FVector& Translation, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshTransformFunctions">();
	}
	static class UGeometryScriptLibrary_MeshTransformFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshTransformFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshTransformFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshTransformFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshTransformFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshTransformFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshUVFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshUVFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* AutoGeneratePatchBuilderMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FGeometryScriptPatchBuilderOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AutoGenerateXAtlasMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FGeometryScriptXAtlasOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyUVSet(class UDynamicMesh* TargetMesh, int32 FromUVSet, int32 ToUVSet, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RecomputeMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FGeometryScriptRecomputeUVsOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RepackMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FGeometryScriptRepackUVsOptions& RepackOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RotateMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, float RotationAngle, const struct FVector2D& RotationOrigin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ScaleMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FVector2D& Scale, const struct FVector2D& ScaleOrigin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshTriangleUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 TriangleID, const struct FGeometryScriptUVTriangle& UVs, bool* bIsValidTriangle, bool bDeferChangeNotifications);
	static class UDynamicMesh* SetMeshUVsFromBoxProjection(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FTransform& BoxTransform, int32 MinIslandTriCount, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshUVsFromCylinderProjection(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FTransform& CylinderTransform, float SplitAngle, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshUVsFromPlanarProjection(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FTransform& PlaneTransform, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetNumUVSets(class UDynamicMesh* TargetMesh, int32 NumUVSets, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* TranslateMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FVector2D& Translation, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshUVFunctions">();
	}
	static class UGeometryScriptLibrary_MeshUVFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshUVFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshUVFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshUVFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshUVFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshUVFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshVertexColorFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshVertexColorFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* SetMeshConstantVertexColor(class UDynamicMesh* TargetMesh, const struct FLinearColor& Color, const struct FGeometryScriptColorFlags& Flags_0, bool bClearExisting, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshPerVertexColors(class UDynamicMesh* TargetMesh, const struct FGeometryScriptColorList& VertexColorList, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshVertexColorFunctions">();
	}
	static class UGeometryScriptLibrary_MeshVertexColorFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshVertexColorFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshVertexColorFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshVertexColorFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshVertexColorFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshVertexColorFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshVoxelFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshVoxelFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyMeshMorphology(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMorphologyOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshSolidify(class UDynamicMesh* TargetMesh, const struct FGeometryScriptSolidifyOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshVoxelFunctions">();
	}
	static class UGeometryScriptLibrary_MeshVoxelFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshVoxelFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_MeshVoxelFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshVoxelFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_MeshVoxelFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshVoxelFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_SceneUtilityFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_SceneUtilityFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* CopyMeshFromComponent(class USceneComponent* Component, class UDynamicMesh* ToDynamicMesh, const struct FGeometryScriptCopyMeshFromComponentOptions& Options, bool bTransformToWorld, struct FTransform* LocalToWorld, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMeshPool* CreateDynamicMeshPool();
	static void SetComponentMaterialList(class UPrimitiveComponent* Component, const TArray<class UMaterialInterface*>& MaterialList, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_SceneUtilityFunctions">();
	}
	static class UGeometryScriptLibrary_SceneUtilityFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_SceneUtilityFunctions>();
	}
};
//static_assert(alignof(UGeometryScriptLibrary_SceneUtilityFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_SceneUtilityFunctions");
//static_assert(sizeof(UGeometryScriptLibrary_SceneUtilityFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_SceneUtilityFunctions");

}

