#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MM

#include "Basic.hpp"

#include "MM_classes.hpp"
#include "MM_parameters.hpp"


namespace SDK
{

// Function MM.FilmstormFunctionLibrary.CreatePlayerInputDirection
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FInputPlayerDirectionData        OutConstructTargetDirection                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTransform                       DesiredTransform                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       RootWorldTransform                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   TargetDirectionInputStrength                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFilmstormFunctionLibrary::CreatePlayerInputDirection(struct FInputPlayerDirectionData* OutConstructTargetDirection, const struct FTransform& DesiredTransform, const struct FTransform& RootWorldTransform, const float TargetDirectionInputStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FilmstormFunctionLibrary", "CreatePlayerInputDirection");

	Params::FilmstormFunctionLibrary_CreatePlayerInputDirection Parms{};

	Parms.DesiredTransform = std::move(DesiredTransform);
	Parms.RootWorldTransform = std::move(RootWorldTransform);
	Parms.TargetDirectionInputStrength = TargetDirectionInputStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConstructTargetDirection != nullptr)
		*OutConstructTargetDirection = std::move(Parms.OutConstructTargetDirection);
}


// Function MM.MotionMatchingHelpers.BlendKeyPoses
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMotionMatchData                 PoseA                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMotionMatchData                 PoseB                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMotionMatchData                 OutBlendedKeyPose                                      (Parm, OutParm, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::BlendKeyPoses(const struct FMotionMatchData& PoseA, const struct FMotionMatchData& PoseB, const float Alpha, struct FMotionMatchData* OutBlendedKeyPose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "BlendKeyPoses");

	Params::MotionMatchingHelpers_BlendKeyPoses Parms{};

	Parms.PoseA = std::move(PoseA);
	Parms.PoseB = std::move(PoseB);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBlendedKeyPose != nullptr)
		*OutBlendedKeyPose = std::move(Parms.OutBlendedKeyPose);
}


// Function MM.MotionMatchingHelpers.CompareJointDatas
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSkeletonStructure>       JointData_A                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FSkeletonStructure>       JointData_B                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMotionMatchingHelpers::CompareJointDatas(const TArray<struct FSkeletonStructure>& JointData_A, const TArray<struct FSkeletonStructure>& JointData_B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "CompareJointDatas");

	Params::MotionMatchingHelpers_CompareJointDatas Parms{};

	Parms.JointData_A = std::move(JointData_A);
	Parms.JointData_B = std::move(JointData_B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.MotionMatchingHelpers.CompareTrajectories
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputPlayerDirectionData        InputDirectionData_A                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FInputPlayerDirectionData        InputDirectionData_B                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMotionMatchingHelpers::CompareTrajectories(const struct FInputPlayerDirectionData& InputDirectionData_A, const struct FInputPlayerDirectionData& InputDirectionData_B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "CompareTrajectories");

	Params::MotionMatchingHelpers_CompareTrajectories Parms{};

	Parms.InputDirectionData_A = std::move(InputDirectionData_A);
	Parms.InputDirectionData_B = std::move(InputDirectionData_B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.MotionMatchingHelpers.CreateInputDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FInputPlayerDirectionData        OutConstructTargetDirection                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTransform                       DesiredTransform                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       RootWorldTransform                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   TargetDirectionInputStrength                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::CreateInputDirection(struct FInputPlayerDirectionData* OutConstructTargetDirection, const struct FTransform& DesiredTransform, const struct FTransform& RootWorldTransform, const float TargetDirectionInputStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "CreateInputDirection");

	Params::MotionMatchingHelpers_CreateInputDirection Parms{};

	Parms.DesiredTransform = std::move(DesiredTransform);
	Parms.RootWorldTransform = std::move(RootWorldTransform);
	Parms.TargetDirectionInputStrength = TargetDirectionInputStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConstructTargetDirection != nullptr)
		*OutConstructTargetDirection = std::move(Parms.OutConstructTargetDirection);
}


// Function MM.MotionMatchingHelpers.ExtractAnimInputDirection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputPlayerDirectionData        DeliveredVelocityViaAnimBonesLocalVelocityData         (Parm, OutParm, NativeAccessSpecifierPublic)
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClockInGame                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::ExtractAnimInputDirection(struct FInputPlayerDirectionData* DeliveredVelocityViaAnimBonesLocalVelocityData, const class UAnimSequence* InSequence, const float ClockInGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "ExtractAnimInputDirection");

	Params::MotionMatchingHelpers_ExtractAnimInputDirection Parms{};

	Parms.InSequence = InSequence;
	Parms.ClockInGame = ClockInGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DeliveredVelocityViaAnimBonesLocalVelocityData != nullptr)
		*DeliveredVelocityViaAnimBonesLocalVelocityData = std::move(Parms.DeliveredVelocityViaAnimBonesLocalVelocityData);
}


// Function MM.MotionMatchingHelpers.ExtractAnimSmoothedRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            DeliveredRotation                                      (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClockInGame                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::ExtractAnimSmoothedRotation(struct FQuat* DeliveredRotation, const class UAnimSequence* InSequence, const float ClockInGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "ExtractAnimSmoothedRotation");

	Params::MotionMatchingHelpers_ExtractAnimSmoothedRotation Parms{};

	Parms.InSequence = InSequence;
	Parms.ClockInGame = ClockInGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DeliveredRotation != nullptr)
		*DeliveredRotation = std::move(Parms.DeliveredRotation);
}


// Function MM.MotionMatchingHelpers.ExtractLMAnimInputDirection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputPlayerDirectionData        DeliveredVelocityViaAnimBonesLocalVelocityData         (Parm, OutParm, NativeAccessSpecifierPublic)
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClockInGame                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::ExtractLMAnimInputDirection(struct FInputPlayerDirectionData* DeliveredVelocityViaAnimBonesLocalVelocityData, const class UAnimSequence* InSequence, const float ClockInGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "ExtractLMAnimInputDirection");

	Params::MotionMatchingHelpers_ExtractLMAnimInputDirection Parms{};

	Parms.InSequence = InSequence;
	Parms.ClockInGame = ClockInGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DeliveredVelocityViaAnimBonesLocalVelocityData != nullptr)
		*DeliveredVelocityViaAnimBonesLocalVelocityData = std::move(Parms.DeliveredVelocityViaAnimBonesLocalVelocityData);
}


// Function MM.MotionMatchingHelpers.GetAnimBoneLocalTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReferenceClock                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentSkeletonPartInReference                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<int32, int32>                      SkelIdx2TrackIdx                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform                       CalculatedTransformMM                                  (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::GetAnimBoneLocalTransform(const class UAnimSequence* InSequence, const float ReferenceClock, const int32 CurrentSkeletonPartInReference, const TMap<int32, int32>& SkelIdx2TrackIdx, struct FTransform* CalculatedTransformMM)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetAnimBoneLocalTransform");

	Params::MotionMatchingHelpers_GetAnimBoneLocalTransform Parms{};

	Parms.InSequence = InSequence;
	Parms.ReferenceClock = ReferenceClock;
	Parms.CurrentSkeletonPartInReference = CurrentSkeletonPartInReference;
	Parms.SkelIdx2TrackIdx = std::move(SkelIdx2TrackIdx);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CalculatedTransformMM != nullptr)
		*CalculatedTransformMM = std::move(Parms.CalculatedTransformMM);
}


// Function MM.MotionMatchingHelpers.GetAnimBoneLocalVel
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReferenceClock                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentSkeletonPartInReference                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<int32, int32>                      SkelIdx2TrackIdx                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          DeliveredVelocityViaAnimBonesLocalVel                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::GetAnimBoneLocalVel(const class UAnimSequence* InSequence, const float ReferenceClock, const int32 CurrentSkeletonPartInReference, const TMap<int32, int32>& SkelIdx2TrackIdx, struct FVector* DeliveredVelocityViaAnimBonesLocalVel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetAnimBoneLocalVel");

	Params::MotionMatchingHelpers_GetAnimBoneLocalVel Parms{};

	Parms.InSequence = InSequence;
	Parms.ReferenceClock = ReferenceClock;
	Parms.CurrentSkeletonPartInReference = CurrentSkeletonPartInReference;
	Parms.SkelIdx2TrackIdx = std::move(SkelIdx2TrackIdx);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DeliveredVelocityViaAnimBonesLocalVel != nullptr)
		*DeliveredVelocityViaAnimBonesLocalVel = std::move(Parms.DeliveredVelocityViaAnimBonesLocalVel);
}


// Function MM.MotionMatchingHelpers.GetAnimBoneWorldTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReferenceClock                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentSkeletonPartInReference                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<int32, int32>                      SkelIdx2TrackIdx                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform                       CalculatedTransformMM                                  (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::GetAnimBoneWorldTransform(const class UAnimSequence* InSequence, const float ReferenceClock, const int32 CurrentSkeletonPartInReference, const TMap<int32, int32>& SkelIdx2TrackIdx, struct FTransform* CalculatedTransformMM)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetAnimBoneWorldTransform");

	Params::MotionMatchingHelpers_GetAnimBoneWorldTransform Parms{};

	Parms.InSequence = InSequence;
	Parms.ReferenceClock = ReferenceClock;
	Parms.CurrentSkeletonPartInReference = CurrentSkeletonPartInReference;
	Parms.SkelIdx2TrackIdx = std::move(SkelIdx2TrackIdx);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CalculatedTransformMM != nullptr)
		*CalculatedTransformMM = std::move(Parms.CalculatedTransformMM);
}


// Function MM.MotionMatchingHelpers.GetAnimJointData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReferenceClock                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkeletonStructure               DeliveredAnimationReferencesForSkelRef                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::GetAnimJointData(const class UAnimSequence* InSequence, const float ReferenceClock, const class FName BoneName, struct FSkeletonStructure* DeliveredAnimationReferencesForSkelRef, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetAnimJointData");

	Params::MotionMatchingHelpers_GetAnimJointData Parms{};

	Parms.InSequence = InSequence;
	Parms.ReferenceClock = ReferenceClock;
	Parms.BoneName = BoneName;
	Parms.InDeltaTime = InDeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DeliveredAnimationReferencesForSkelRef != nullptr)
		*DeliveredAnimationReferencesForSkelRef = std::move(Parms.DeliveredAnimationReferencesForSkelRef);
}


// Function MM.MotionMatchingHelpers.GetAnimVelocityReferenceClock
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReferenceClock                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DeliveredVelocityViaAnimBonesLocalVelocity             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::GetAnimVelocityReferenceClock(const class UAnimSequence* InSequence, const float ReferenceClock, struct FVector* DeliveredVelocityViaAnimBonesLocalVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetAnimVelocityReferenceClock");

	Params::MotionMatchingHelpers_GetAnimVelocityReferenceClock Parms{};

	Parms.InSequence = InSequence;
	Parms.ReferenceClock = ReferenceClock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DeliveredVelocityViaAnimBonesLocalVelocity != nullptr)
		*DeliveredVelocityViaAnimBonesLocalVelocity = std::move(Parms.DeliveredVelocityViaAnimBonesLocalVelocity);
}


// Function MM.MotionMatchingHelpers.GetDataFromAnimation
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReferenceClock                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     SkeletonRuntimeName                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FInputPlayerDirectionData        OutPresentInputDirection                               (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FInputPlayerDirectionData        OutFutureInputDirection                                (Parm, OutParm, NativeAccessSpecifierPublic)
// TArray<struct FSkeletonStructure>       DeliveredAnimationReferencesForSkelRef                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::GetDataFromAnimation(const class UAnimSequence* InSequence, const float ReferenceClock, const TArray<class FName>& SkeletonRuntimeName, struct FInputPlayerDirectionData* OutPresentInputDirection, struct FInputPlayerDirectionData* OutFutureInputDirection, TArray<struct FSkeletonStructure>* DeliveredAnimationReferencesForSkelRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetDataFromAnimation");

	Params::MotionMatchingHelpers_GetDataFromAnimation Parms{};

	Parms.InSequence = InSequence;
	Parms.ReferenceClock = ReferenceClock;
	Parms.SkeletonRuntimeName = std::move(SkeletonRuntimeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPresentInputDirection != nullptr)
		*OutPresentInputDirection = std::move(Parms.OutPresentInputDirection);

	if (OutFutureInputDirection != nullptr)
		*OutFutureInputDirection = std::move(Parms.OutFutureInputDirection);

	if (DeliveredAnimationReferencesForSkelRef != nullptr)
		*DeliveredAnimationReferencesForSkelRef = std::move(Parms.DeliveredAnimationReferencesForSkelRef);
}


// Function MM.MotionMatchingHelpers.GetKeyPoseDataFromAnim
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReferenceClock                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ToBeRefAgainst                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMotionMatchData                 CalculatedMMData                                       (Parm, OutParm, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::GetKeyPoseDataFromAnim(const class UAnimSequence* InSequence, const float ReferenceClock, const TArray<class FName>& ToBeRefAgainst, struct FMotionMatchData* CalculatedMMData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetKeyPoseDataFromAnim");

	Params::MotionMatchingHelpers_GetKeyPoseDataFromAnim Parms{};

	Parms.InSequence = InSequence;
	Parms.ReferenceClock = ReferenceClock;
	Parms.ToBeRefAgainst = std::move(ToBeRefAgainst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CalculatedMMData != nullptr)
		*CalculatedMMData = std::move(Parms.CalculatedMMData);
}


// Function MM.MotionMatchingHelpers.GetLastInputDirectionTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputPlayerDirectionData        InputDirection                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UMotionMatchingHelpers::GetLastInputDirectionTransform(const struct FInputPlayerDirectionData& InputDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetLastInputDirectionTransform");

	Params::MotionMatchingHelpers_GetLastInputDirectionTransform Parms{};

	Parms.InputDirection = std::move(InputDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.MotionMatchingHelpers.GetLMAnimVelocityReferenceClock
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InSequence                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReferenceClock                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DeliveredVelocityViaAnimBonesLocalVelocity             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingHelpers::GetLMAnimVelocityReferenceClock(const class UAnimSequence* InSequence, const float ReferenceClock, struct FVector* DeliveredVelocityViaAnimBonesLocalVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetLMAnimVelocityReferenceClock");

	Params::MotionMatchingHelpers_GetLMAnimVelocityReferenceClock Parms{};

	Parms.InSequence = InSequence;
	Parms.ReferenceClock = ReferenceClock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DeliveredVelocityViaAnimBonesLocalVelocity != nullptr)
		*DeliveredVelocityViaAnimBonesLocalVelocity = std::move(Parms.DeliveredVelocityViaAnimBonesLocalVelocity);
}


// Function MM.MotionMatchingHelpers.GetMMAnimDataRecordFilePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMotionMatchingHelpers::GetMMAnimDataRecordFilePath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "GetMMAnimDataRecordFilePath");

	Params::MotionMatchingHelpers_GetMMAnimDataRecordFilePath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.MotionMatchingHelpers.MakeInputDirectionData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputPlayerDirectionData        OutInputDirection                                      (Parm, OutParm, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               VectorsWeHaveLeftBehind                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  CheckTheseAgainstVWHLB                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionMatchingHelpers::MakeInputDirectionData(struct FInputPlayerDirectionData* OutInputDirection, const TArray<struct FTransform>& VectorsWeHaveLeftBehind, const TArray<struct FVector>& CheckTheseAgainstVWHLB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingHelpers", "MakeInputDirectionData");

	Params::MotionMatchingHelpers_MakeInputDirectionData Parms{};

	Parms.VectorsWeHaveLeftBehind = std::move(VectorsWeHaveLeftBehind);
	Parms.CheckTheseAgainstVWHLB = std::move(CheckTheseAgainstVWHLB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInputDirection != nullptr)
		*OutInputDirection = std::move(Parms.OutInputDirection);

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.AnalyzerAnimationReferences
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CurrentReferenceAnimation                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationAnalyzer::AnalyzerAnimationReferences(const int32 CurrentReferenceAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "AnalyzerAnimationReferences");

	Params::AnimationAnalyzer_AnalyzerAnimationReferences Parms{};

	Parms.CurrentReferenceAnimation = CurrentReferenceAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.AnimationCalculationsAccepted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Ref                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::AnimationCalculationsAccepted(const int32 Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "AnimationCalculationsAccepted");

	Params::AnimationAnalyzer_AnimationCalculationsAccepted Parms{};

	Parms.Ref = Ref;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.AnimationContextIsValid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CurrentAnimationRef                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::AnimationContextIsValid(const int32 CurrentAnimationRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "AnimationContextIsValid");

	Params::AnimationAnalyzer_AnimationContextIsValid Parms{};

	Parms.CurrentAnimationRef = CurrentAnimationRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.AnimationReferenceIsValid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CurrentAnimationRef                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::AnimationReferenceIsValid(const int32 CurrentAnimationRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "AnimationReferenceIsValid");

	Params::AnimationAnalyzer_AnimationReferenceIsValid Parms{};

	Parms.CurrentAnimationRef = CurrentAnimationRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.CheckIsFirstLoadRequireDesireAsset
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Ref                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::CheckIsFirstLoadRequireDesireAsset(const int32 Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "CheckIsFirstLoadRequireDesireAsset");

	Params::AnimationAnalyzer_CheckIsFirstLoadRequireDesireAsset Parms{};

	Parms.Ref = Ref;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.CleanAllAnimationReferences
// (Final, Native, Public, BlueprintCallable)

void UAnimationAnalyzer::CleanAllAnimationReferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "CleanAllAnimationReferences");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.CleanAnimationReferences
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CurrentReferenceAnimation                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationAnalyzer::CleanAnimationReferences(const int32 CurrentReferenceAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "CleanAnimationReferences");

	Params::AnimationAnalyzer_CleanAnimationReferences Parms{};

	Parms.CurrentReferenceAnimation = CurrentReferenceAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.ClearAllAnimSeqForCalculatingInEditor
// (Final, Native, Public, BlueprintCallable)

void UAnimationAnalyzer::ClearAllAnimSeqForCalculatingInEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "ClearAllAnimSeqForCalculatingInEditor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.ConstructAllAnimationReferences
// (Final, Native, Public, BlueprintCallable)

void UAnimationAnalyzer::ConstructAllAnimationReferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "ConstructAllAnimationReferences");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.ConstructAnimationReferences
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FromSourceAnimation                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationAnalyzer::ConstructAnimationReferences(const int32 FromSourceAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "ConstructAnimationReferences");

	Params::AnimationAnalyzer_ConstructAnimationReferences Parms{};

	Parms.FromSourceAnimation = FromSourceAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.ConstructSerializedFeatures
// (Final, Native, Private, BlueprintCallable)

void UAnimationAnalyzer::ConstructSerializedFeatures()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "ConstructSerializedFeatures");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.CountAnimationReferences
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationAnalyzer::CountAnimationReferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "CountAnimationReferences");

	Params::AnimationAnalyzer_CountAnimationReferences Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.FindAnimationFromSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CurrentAnimationRef                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* UAnimationAnalyzer::FindAnimationFromSequence(const int32 CurrentAnimationRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "FindAnimationFromSequence");

	Params::AnimationAnalyzer_FindAnimationFromSequence Parms{};

	Parms.CurrentAnimationRef = CurrentAnimationRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.FindAnimationsAtDesiredReferences
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Ref                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* UAnimationAnalyzer::FindAnimationsAtDesiredReferences(const int32 Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "FindAnimationsAtDesiredReferences");

	Params::AnimationAnalyzer_FindAnimationsAtDesiredReferences Parms{};

	Parms.Ref = Ref;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.FindUserSelectedBones
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationAnalyzer::FindUserSelectedBones()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "FindUserSelectedBones");

	Params::AnimationAnalyzer_FindUserSelectedBones Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.FindUsersSkeletonBoneNames
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReferencedBone                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAnimationAnalyzer::FindUsersSkeletonBoneNames(int32 ReferencedBone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "FindUsersSkeletonBoneNames");

	Params::AnimationAnalyzer_FindUsersSkeletonBoneNames Parms{};

	Parms.ReferencedBone = ReferencedBone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.GatherSkeletonInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeleton*                        UserSkeleton                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     SelectedJoints                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           BoneWeights                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAnimationAnalyzer::GatherSkeletonInfo(class USkeleton* UserSkeleton, const TArray<class FName>& SelectedJoints, const TArray<float>& BoneWeights)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "GatherSkeletonInfo");

	Params::AnimationAnalyzer_GatherSkeletonInfo Parms{};

	Parms.UserSkeleton = UserSkeleton;
	Parms.SelectedJoints = std::move(SelectedJoints);
	Parms.BoneWeights = std::move(BoneWeights);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.GetAnimationAnalyzerSkeleton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeleton*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeleton* UAnimationAnalyzer::GetAnimationAnalyzerSkeleton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "GetAnimationAnalyzerSkeleton");

	Params::AnimationAnalyzer_GetAnimationAnalyzerSkeleton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.GetAnimationCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationAnalyzer::GetAnimationCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "GetAnimationCount");

	Params::AnimationAnalyzer_GetAnimationCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.GetAnimationShowNameInEditor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Ref                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAnimationAnalyzer::GetAnimationShowNameInEditor(const int32 Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "GetAnimationShowNameInEditor");

	Params::AnimationAnalyzer_GetAnimationShowNameInEditor Parms{};

	Parms.Ref = Ref;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.GetSoftPathByIndex
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Ref                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UAnimationAnalyzer::GetSoftPathByIndex(const int32 Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "GetSoftPathByIndex");

	Params::AnimationAnalyzer_GetSoftPathByIndex Parms{};

	Parms.Ref = Ref;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.HasSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SequenceName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::HasSequence(const class FName SequenceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "HasSequence");

	Params::AnimationAnalyzer_HasSequence Parms{};

	Parms.SequenceName = SequenceName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.InitAnimMathDataBySerializedFeatures
// (Final, Native, Public, BlueprintCallable)

void UAnimationAnalyzer::InitAnimMathDataBySerializedFeatures()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "InitAnimMathDataBySerializedFeatures");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.IsAnimationExtracted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AnimationRef                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WorldTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::IsAnimationExtracted(const class FName AnimationRef, const float WorldTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "IsAnimationExtracted");

	Params::AnimationAnalyzer_IsAnimationExtracted Parms{};

	Parms.AnimationRef = AnimationRef;
	Parms.WorldTime = WorldTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.IsAnimMathDataValid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::IsAnimMathDataValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "IsAnimMathDataValid");

	Params::AnimationAnalyzer_IsAnimMathDataValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.IsUseLMAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::IsUseLMAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "IsUseLMAnim");

	Params::AnimationAnalyzer_IsUseLMAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.LoadAllAnimSeqFromSoftRefForCalculatingInEditor
// (Final, Native, Public, BlueprintCallable)

void UAnimationAnalyzer::LoadAllAnimSeqFromSoftRefForCalculatingInEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "LoadAllAnimSeqFromSoftRefForCalculatingInEditor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.MatchAnimationByKDTree
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   VelocityStrength                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputPlayerDirectionData        InputDirection                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FSkeletonStructure>       MotionJointData                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          PresentVel                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSquareDis                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationAnalyzer::MatchAnimationByKDTree(const float VelocityStrength, const struct FInputPlayerDirectionData& InputDirection, const TArray<struct FSkeletonStructure>& MotionJointData, const struct FVector& PresentVel, float* MinSquareDis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "MatchAnimationByKDTree");

	Params::AnimationAnalyzer_MatchAnimationByKDTree Parms{};

	Parms.VelocityStrength = VelocityStrength;
	Parms.InputDirection = std::move(InputDirection);
	Parms.MotionJointData = std::move(MotionJointData);
	Parms.PresentVel = std::move(PresentVel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MinSquareDis != nullptr)
		*MinSquareDis = Parms.MinSquareDis;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.MMAnimationSeqUsingNotify_Inner
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Ref                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationAnalyzer::MMAnimationSeqUsingNotify_Inner(const int32 Ref, class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "MMAnimationSeqUsingNotify_Inner");

	Params::AnimationAnalyzer_MMAnimationSeqUsingNotify_Inner Parms{};

	Parms.Ref = Ref;
	Parms.Owner = Owner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MM.AnimationAnalyzer.NewAnimationReference
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UAnimSequence*>            ProvidedAnimationsByUser                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAnimationAnalyzer::NewAnimationReference(const TArray<class UAnimSequence*>& ProvidedAnimationsByUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "NewAnimationReference");

	Params::AnimationAnalyzer_NewAnimationReference Parms{};

	Parms.ProvidedAnimationsByUser = std::move(ProvidedAnimationsByUser);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.OnAnimationAssetLoadStatChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Ref                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimSeqAssetLoadStatType               Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    Anim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationAnalyzer::OnAnimationAssetLoadStatChange(const int32 Ref, EAnimSeqAssetLoadStatType Stat, class UAnimSequence* Anim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "OnAnimationAssetLoadStatChange");

	Params::AnimationAnalyzer_OnAnimationAssetLoadStatChange Parms{};

	Parms.Ref = Ref;
	Parms.Stat = Stat;
	Parms.Anim = Anim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.RemoveAnimationReference
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CurrentAnimationRef                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationAnalyzer::RemoveAnimationReference(const int32 CurrentAnimationRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "RemoveAnimationReference");

	Params::AnimationAnalyzer_RemoveAnimationReference Parms{};

	Parms.CurrentAnimationRef = CurrentAnimationRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.RequireAnimationsLoadAtDesiredReferences
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Ref                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoadAll                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationAnalyzer::RequireAnimationsLoadAtDesiredReferences(const int32 Ref, bool bLoadAll, class UObject* AnimInst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "RequireAnimationsLoadAtDesiredReferences");

	Params::AnimationAnalyzer_RequireAnimationsLoadAtDesiredReferences Parms{};

	Parms.Ref = Ref;
	Parms.bLoadAll = bLoadAll;
	Parms.AnimInst = AnimInst;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.SetUseLMAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationAnalyzer::SetUseLMAnim(bool bUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "SetUseLMAnim");

	Params::AnimationAnalyzer_SetUseLMAnim Parms{};

	Parms.bUse = bUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MM.AnimationAnalyzer.StructureForAnimationCalculations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   ControllerInputReactionSpeedCustom                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ControllerRotateReactionSpeedCustom                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VelocityStrength                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimationMatchPower                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputPlayerDirectionData        InputDirection                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FSkeletonStructure>       AllAnimationReferences                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          PresentVel                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CalculatedResult                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMotionMatchingCostData          AnimCostData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationAnalyzer::StructureForAnimationCalculations(const float ControllerInputReactionSpeedCustom, const float ControllerRotateReactionSpeedCustom, const float VelocityStrength, const float AnimationMatchPower, const struct FInputPlayerDirectionData& InputDirection, const TArray<struct FSkeletonStructure>& AllAnimationReferences, const struct FVector& PresentVel, const float BlendTime, float* CalculatedResult, struct FMotionMatchingCostData* AnimCostData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "StructureForAnimationCalculations");

	Params::AnimationAnalyzer_StructureForAnimationCalculations Parms{};

	Parms.ControllerInputReactionSpeedCustom = ControllerInputReactionSpeedCustom;
	Parms.ControllerRotateReactionSpeedCustom = ControllerRotateReactionSpeedCustom;
	Parms.VelocityStrength = VelocityStrength;
	Parms.AnimationMatchPower = AnimationMatchPower;
	Parms.InputDirection = std::move(InputDirection);
	Parms.AllAnimationReferences = std::move(AllAnimationReferences);
	Parms.PresentVel = std::move(PresentVel);
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CalculatedResult != nullptr)
		*CalculatedResult = Parms.CalculatedResult;

	if (AnimCostData != nullptr)
		*AnimCostData = std::move(Parms.AnimCostData);

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.TryInitFromAA
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimationAnalyzer*               OrgAA                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::TryInitFromAA(const class UAnimationAnalyzer* OrgAA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "TryInitFromAA");

	Params::AnimationAnalyzer_TryInitFromAA Parms{};

	Parms.OrgAA = OrgAA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.GetSequenceTimeOfAnimations
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CurrentAnimationKeyframe                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMotionMatchingMath        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMotionMatchingMath UAnimationAnalyzer::GetSequenceTimeOfAnimations(const int32 CurrentAnimationKeyframe) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "GetSequenceTimeOfAnimations");

	Params::AnimationAnalyzer_GetSequenceTimeOfAnimations Parms{};

	Parms.CurrentAnimationKeyframe = CurrentAnimationKeyframe;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MM.AnimationAnalyzer.IsBoneSelected
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAnalyzer::IsBoneSelected(const class FName& BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationAnalyzer", "IsBoneSelected");

	Params::AnimationAnalyzer_IsBoneSelected Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

