#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UnrealExtent

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_classes.hpp"
#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"
#include "UnrealExtent_structs.hpp"
#include "MovieSceneTracks_classes.hpp"
#include "Water_classes.hpp"
#include "Niagara_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "Slate_structs.hpp"
#include "PCG_classes.hpp"


namespace SDK
{

// Class UnrealExtent.GSE_RenderUtilFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_RenderUtilFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static float GetSceneViewPreExposure(class AActor* WorldContext);
	static void MarkRenderStateDirty(class UActorComponent* ActorComponent);
	static void OverrideSystemUserVariableSKMFilteredBones(class UNiagaraComponent* NiagaraSystem, const class FString& OverrideName, const TArray<class FName>& OverrideFilteredBones);
	static void OverrideSystemUserVariableSKMFilteredSockets(class UNiagaraComponent* NiagaraSystem, const class FString& OverrideName, const TArray<class FName>& OverrideFilteredSockets);
	static void PlayCameraShake(class UClass* CameraShakeCls, class APlayerCameraManager* Camera);
	static void SetRenderCustomDepth(class AActor* AA, bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_RenderUtilFuncLib">();
	}
	static class UGSE_RenderUtilFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_RenderUtilFuncLib>();
	}
};
//static_assert(alignof(UGSE_RenderUtilFuncLib) == 0x000008, "Wrong alignment on UGSE_RenderUtilFuncLib");
//static_assert(sizeof(UGSE_RenderUtilFuncLib) == 0x000028, "Wrong size on UGSE_RenderUtilFuncLib");

// Class UnrealExtent.LandscapeHeightModifierVolume
// 0x0080 (0x0330 - 0x02B0)
class ALandscapeHeightModifierVolume final : public AVolume
{
public:
	class AGenerateLandscapeVolume*               GenerateVolume;                                    // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALandscape*                             LandscapeActor;                                    // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x70];                                     // 0x02C0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeHeightModifierVolume">();
	}
	static class ALandscapeHeightModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandscapeHeightModifierVolume>();
	}
};
//static_assert(alignof(ALandscapeHeightModifierVolume) == 0x000008, "Wrong alignment on ALandscapeHeightModifierVolume");
//static_assert(sizeof(ALandscapeHeightModifierVolume) == 0x000330, "Wrong size on ALandscapeHeightModifierVolume");
//static_assert(offsetof(ALandscapeHeightModifierVolume, GenerateVolume) == 0x0002B0, "Member 'ALandscapeHeightModifierVolume::GenerateVolume' has a wrong offset!");
//static_assert(offsetof(ALandscapeHeightModifierVolume, LandscapeActor) == 0x0002B8, "Member 'ALandscapeHeightModifierVolume::LandscapeActor' has a wrong offset!");

// Class UnrealExtent.AudioVisualizeBox
// 0x00A8 (0x0340 - 0x0298)
class UAudioVisualizeBox final : public UUserWidget
{
public:
	class UImage*                                 LayoutWidget;                                      // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FreqNum;                                           // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoudnessNum;                                       // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FreqSpecInfoArray;                                 // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      LoudnessInfoArray;                                 // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FreqThickness;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FreqColor;                                         // 0x02CC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreqHeightFinalScale;                              // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreqHeightScale;                                   // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreqPaintPower;                                    // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoudnessThickness;                                 // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LoudnessColor;                                     // 0x02EC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LoudnessHeightRange;                               // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoudnessRandomScaleFactor;                         // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OffsetInWidget;                                    // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PaintFreq;                                         // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PaintLoudness;                                     // 0x0329(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A[0x2];                                      // 0x032A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreqDisturbInterval;                               // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PausePainting();
	void ResetVisualizing();
	void SetAudioInfo(const struct FVector2D& InLoudness, const TArray<float>& InConstantInfo);
	void SetFreqInfo(const TArray<float>& InConstantInfo);
	void SetFreqNum(const int32 InFreqNum);
	void SetLoudnessInfo(const struct FVector2D& InLoudness);
	void StartPainting();
	void StopPainting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioVisualizeBox">();
	}
	static class UAudioVisualizeBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioVisualizeBox>();
	}
};
//static_assert(alignof(UAudioVisualizeBox) == 0x000008, "Wrong alignment on UAudioVisualizeBox");
//static_assert(sizeof(UAudioVisualizeBox) == 0x000340, "Wrong size on UAudioVisualizeBox");
//static_assert(offsetof(UAudioVisualizeBox, LayoutWidget) == 0x000298, "Member 'UAudioVisualizeBox::LayoutWidget' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, FreqNum) == 0x0002A0, "Member 'UAudioVisualizeBox::FreqNum' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, LoudnessNum) == 0x0002A4, "Member 'UAudioVisualizeBox::LoudnessNum' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, FreqSpecInfoArray) == 0x0002A8, "Member 'UAudioVisualizeBox::FreqSpecInfoArray' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, LoudnessInfoArray) == 0x0002B8, "Member 'UAudioVisualizeBox::LoudnessInfoArray' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, FreqThickness) == 0x0002C8, "Member 'UAudioVisualizeBox::FreqThickness' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, FreqColor) == 0x0002CC, "Member 'UAudioVisualizeBox::FreqColor' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, FreqHeightFinalScale) == 0x0002DC, "Member 'UAudioVisualizeBox::FreqHeightFinalScale' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, FreqHeightScale) == 0x0002E0, "Member 'UAudioVisualizeBox::FreqHeightScale' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, FreqPaintPower) == 0x0002E4, "Member 'UAudioVisualizeBox::FreqPaintPower' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, LoudnessThickness) == 0x0002E8, "Member 'UAudioVisualizeBox::LoudnessThickness' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, LoudnessColor) == 0x0002EC, "Member 'UAudioVisualizeBox::LoudnessColor' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, LoudnessHeightRange) == 0x000300, "Member 'UAudioVisualizeBox::LoudnessHeightRange' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, LoudnessRandomScaleFactor) == 0x000310, "Member 'UAudioVisualizeBox::LoudnessRandomScaleFactor' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, OffsetInWidget) == 0x000318, "Member 'UAudioVisualizeBox::OffsetInWidget' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, PaintFreq) == 0x000328, "Member 'UAudioVisualizeBox::PaintFreq' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, PaintLoudness) == 0x000329, "Member 'UAudioVisualizeBox::PaintLoudness' has a wrong offset!");
//static_assert(offsetof(UAudioVisualizeBox, FreqDisturbInterval) == 0x00032C, "Member 'UAudioVisualizeBox::FreqDisturbInterval' has a wrong offset!");

// Class UnrealExtent.GSCrowdFollowingComponent
// 0x0000 (0x0318 - 0x0318)
class UGSCrowdFollowingComponent : public UCrowdFollowingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCrowdFollowingComponent">();
	}
	static class UGSCrowdFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCrowdFollowingComponent>();
	}
};
//static_assert(alignof(UGSCrowdFollowingComponent) == 0x000008, "Wrong alignment on UGSCrowdFollowingComponent");
//static_assert(sizeof(UGSCrowdFollowingComponent) == 0x000318, "Wrong size on UGSCrowdFollowingComponent");

// Class UnrealExtent.AlphaScanButton
// 0x0010 (0x05E0 - 0x05D0)
class UAlphaScanButton final : public UButton
{
public:
	class UTexture2D*                             AdvancedHitTexture;                                // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdvancedHitAlpha;                                  // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0xC];                                      // 0x05D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAdvancedHitAlpha(int32 InAlpha);
	void SetAdvancedHitTexture(class UTexture2D* InTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlphaScanButton">();
	}
	static class UAlphaScanButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlphaScanButton>();
	}
};
//static_assert(alignof(UAlphaScanButton) == 0x000010, "Wrong alignment on UAlphaScanButton");
//static_assert(sizeof(UAlphaScanButton) == 0x0005E0, "Wrong size on UAlphaScanButton");
//static_assert(offsetof(UAlphaScanButton, AdvancedHitTexture) == 0x0005C8, "Member 'UAlphaScanButton::AdvancedHitTexture' has a wrong offset!");
//static_assert(offsetof(UAlphaScanButton, AdvancedHitAlpha) == 0x0005D0, "Member 'UAlphaScanButton::AdvancedHitAlpha' has a wrong offset!");

// Class UnrealExtent.ExedreWidgetRenderTarget
// 0x00F8 (0x0390 - 0x0298)
class UExedreWidgetRenderTarget final : public UUserWidget
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     RenderingMaterial;                                 // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            ImageBrush;                                        // 0x02B0(0x00D0)(NativeAccessSpecifierPrivate)
	class UTexture2D*                             DefaultTexture;                                    // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExedreWidgetRenderTarget">();
	}
	static class UExedreWidgetRenderTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExedreWidgetRenderTarget>();
	}
};
//static_assert(alignof(UExedreWidgetRenderTarget) == 0x000010, "Wrong alignment on UExedreWidgetRenderTarget");
//static_assert(sizeof(UExedreWidgetRenderTarget) == 0x000390, "Wrong size on UExedreWidgetRenderTarget");
//static_assert(offsetof(UExedreWidgetRenderTarget, RenderingMaterial) == 0x0002A8, "Member 'UExedreWidgetRenderTarget::RenderingMaterial' has a wrong offset!");
//static_assert(offsetof(UExedreWidgetRenderTarget, ImageBrush) == 0x0002B0, "Member 'UExedreWidgetRenderTarget::ImageBrush' has a wrong offset!");
//static_assert(offsetof(UExedreWidgetRenderTarget, DefaultTexture) == 0x000380, "Member 'UExedreWidgetRenderTarget::DefaultTexture' has a wrong offset!");

// Class UnrealExtent.AudioVisualizeUtil
// 0x0030 (0x02A8 - 0x0278)
class AAudioVisualizeUtil final : public AActor
{
public:
	class UAudioComponent*                        Audio;                                             // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoudnessNRT*                           LoudnessAnalyzer;                                  // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConstantQNRT*                          ConstantAnalyzer;                                  // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAudioPlaybackPercentCallback(const class USoundWave* SoundWave, const float Percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioVisualizeUtil">();
	}
	static class AAudioVisualizeUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAudioVisualizeUtil>();
	}
};
//static_assert(alignof(AAudioVisualizeUtil) == 0x000008, "Wrong alignment on AAudioVisualizeUtil");
//static_assert(sizeof(AAudioVisualizeUtil) == 0x0002A8, "Wrong size on AAudioVisualizeUtil");
//static_assert(offsetof(AAudioVisualizeUtil, Audio) == 0x000278, "Member 'AAudioVisualizeUtil::Audio' has a wrong offset!");
//static_assert(offsetof(AAudioVisualizeUtil, LoudnessAnalyzer) == 0x000280, "Member 'AAudioVisualizeUtil::LoudnessAnalyzer' has a wrong offset!");
//static_assert(offsetof(AAudioVisualizeUtil, ConstantAnalyzer) == 0x000288, "Member 'AAudioVisualizeUtil::ConstantAnalyzer' has a wrong offset!");

// Class UnrealExtent.GSE_GridlyFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_GridlyFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FString> GetSupportCultures();
	static void RequestPage(class UObject* Obj);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_GridlyFuncLib">();
	}
	static class UGSE_GridlyFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_GridlyFuncLib>();
	}
};
//static_assert(alignof(UGSE_GridlyFuncLib) == 0x000008, "Wrong alignment on UGSE_GridlyFuncLib");
//static_assert(sizeof(UGSE_GridlyFuncLib) == 0x000028, "Wrong size on UGSE_GridlyFuncLib");

// Class UnrealExtent.SFadeObjectsComponent
// 0x00C8 (0x0178 - 0x00B0)
class USFadeObjectsComponent final : public UActorComponent
{
public:
	TArray<struct FFadeObjStruct>                 FadeObjects;                                       // 0x00B0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle_ObjectComputeTimer;                    // 0x00C0(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle_AddObjectsTimer;                       // 0x00C8(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentFade;                                       // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FadeNowID;                                         // 0x00D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPrimitiveComponent*>            FadeObjectsTemp;                                   // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UPrimitiveComponent*>            FadeObjectsHit;                                    // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterial*                              FadeMaterial;                                      // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnable;                                           // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddObjectInterval;                                 // 0x0104(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CalcFadeInterval;                                  // 0x0108(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WorkDistance;                                      // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NearCameraRadius;                                  // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 PlayerClass;                                       // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<ECollisionChannel>                     ObjectTypes;                                       // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	ECollisionChannel                             ChannelType;                                       // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsIgnore;                                      // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         FadeRate;                                          // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CapsuleHalfHeight;                                 // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CapsuleRadius;                                     // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         CharacterArray;                                    // 0x0158(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         NearObjectFade;                                    // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FarObjectFade;                                     // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ImmediatelyFade;                                   // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SFadeObjectsComponent">();
	}
	static class USFadeObjectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USFadeObjectsComponent>();
	}
};
//static_assert(alignof(USFadeObjectsComponent) == 0x000008, "Wrong alignment on USFadeObjectsComponent");
//static_assert(sizeof(USFadeObjectsComponent) == 0x000178, "Wrong size on USFadeObjectsComponent");
//static_assert(offsetof(USFadeObjectsComponent, FadeObjects) == 0x0000B0, "Member 'USFadeObjectsComponent::FadeObjects' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, TimerHandle_ObjectComputeTimer) == 0x0000C0, "Member 'USFadeObjectsComponent::TimerHandle_ObjectComputeTimer' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, TimerHandle_AddObjectsTimer) == 0x0000C8, "Member 'USFadeObjectsComponent::TimerHandle_AddObjectsTimer' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, CurrentFade) == 0x0000D0, "Member 'USFadeObjectsComponent::CurrentFade' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, FadeNowID) == 0x0000D4, "Member 'USFadeObjectsComponent::FadeNowID' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, FadeObjectsTemp) == 0x0000D8, "Member 'USFadeObjectsComponent::FadeObjectsTemp' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, FadeObjectsHit) == 0x0000E8, "Member 'USFadeObjectsComponent::FadeObjectsHit' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, FadeMaterial) == 0x0000F8, "Member 'USFadeObjectsComponent::FadeMaterial' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, bEnable) == 0x000100, "Member 'USFadeObjectsComponent::bEnable' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, AddObjectInterval) == 0x000104, "Member 'USFadeObjectsComponent::AddObjectInterval' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, CalcFadeInterval) == 0x000108, "Member 'USFadeObjectsComponent::CalcFadeInterval' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, WorkDistance) == 0x00010C, "Member 'USFadeObjectsComponent::WorkDistance' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, NearCameraRadius) == 0x000110, "Member 'USFadeObjectsComponent::NearCameraRadius' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, PlayerClass) == 0x000118, "Member 'USFadeObjectsComponent::PlayerClass' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, ObjectTypes) == 0x000120, "Member 'USFadeObjectsComponent::ObjectTypes' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, ChannelType) == 0x000130, "Member 'USFadeObjectsComponent::ChannelType' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, ActorsIgnore) == 0x000138, "Member 'USFadeObjectsComponent::ActorsIgnore' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, FadeRate) == 0x000148, "Member 'USFadeObjectsComponent::FadeRate' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, CapsuleHalfHeight) == 0x00014C, "Member 'USFadeObjectsComponent::CapsuleHalfHeight' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, CapsuleRadius) == 0x000150, "Member 'USFadeObjectsComponent::CapsuleRadius' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, CharacterArray) == 0x000158, "Member 'USFadeObjectsComponent::CharacterArray' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, NearObjectFade) == 0x000168, "Member 'USFadeObjectsComponent::NearObjectFade' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, FarObjectFade) == 0x00016C, "Member 'USFadeObjectsComponent::FarObjectFade' has a wrong offset!");
//static_assert(offsetof(USFadeObjectsComponent, ImmediatelyFade) == 0x000170, "Member 'USFadeObjectsComponent::ImmediatelyFade' has a wrong offset!");

// Class UnrealExtent.AutoMovementPattern
// 0x00C8 (0x00F8 - 0x0030)
class UAutoMovementPattern final : public UPrimaryDataAsset
{
public:
	float                                         TickInterval;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAutoMovementViewingPattern            ViewingPattern;                                    // 0x0038(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAutoMovementHeatmapConfig             HeatmapConfig;                                     // 0x0090(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoMovementPattern">();
	}
	static class UAutoMovementPattern* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoMovementPattern>();
	}
};
//static_assert(alignof(UAutoMovementPattern) == 0x000008, "Wrong alignment on UAutoMovementPattern");
//static_assert(sizeof(UAutoMovementPattern) == 0x0000F8, "Wrong size on UAutoMovementPattern");
//static_assert(offsetof(UAutoMovementPattern, TickInterval) == 0x000030, "Member 'UAutoMovementPattern::TickInterval' has a wrong offset!");
//static_assert(offsetof(UAutoMovementPattern, ViewingPattern) == 0x000038, "Member 'UAutoMovementPattern::ViewingPattern' has a wrong offset!");
//static_assert(offsetof(UAutoMovementPattern, HeatmapConfig) == 0x000090, "Member 'UAutoMovementPattern::HeatmapConfig' has a wrong offset!");

// Class UnrealExtent.BGUMovieSceneComponentMaterialTrack
// 0x0010 (0x00B0 - 0x00A0)
class UBGUMovieSceneComponentMaterialTrack final : public UMovieSceneMaterialTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaterialIndex;                                     // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUMovieSceneComponentMaterialTrack">();
	}
	static class UBGUMovieSceneComponentMaterialTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUMovieSceneComponentMaterialTrack>();
	}
};
//static_assert(alignof(UBGUMovieSceneComponentMaterialTrack) == 0x000008, "Wrong alignment on UBGUMovieSceneComponentMaterialTrack");
//static_assert(sizeof(UBGUMovieSceneComponentMaterialTrack) == 0x0000B0, "Wrong size on UBGUMovieSceneComponentMaterialTrack");
//static_assert(offsetof(UBGUMovieSceneComponentMaterialTrack, MaterialIndex) == 0x0000A8, "Member 'UBGUMovieSceneComponentMaterialTrack::MaterialIndex' has a wrong offset!");

// Class UnrealExtent.AutoMovementMonitor
// 0x00A8 (0x0320 - 0x0278)
class AAutoMovementMonitor : public AActor
{
public:
	class UAutoMovementPattern*                   AutoMovePattern;                                   // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReportFilePath;                                    // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PathPoints;                                        // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        CachedPathPoints;                                  // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          bLogProcessingState;                               // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReadyToProcess;                                 // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPitchingPositively;                               // 0x02B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3[0x1];                                      // 0x02B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetPositionIndex;                               // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetYawIndex;                                    // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetPitchIndex;                                  // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPosition;                                    // 0x02C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x02D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ViewingPhaseIndex;                                 // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AutoMoveStartTimeSinceAppStarted;                  // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPointEndTimestamp;                             // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x14];                                     // 0x030C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureViewingInfo();
	void CheckHitRotation(const struct FRotator& InRotator);
	void CreatePointInstances(const TArray<struct FVector>& InPoints);
	void DrawStatOnHeatmap(const class FString& InStatName, const int32 InTileCount);
	void EnableAutoMovement();
	void ExitAppOnAutoMoveFinished();
	class FString GetPointExecutionDurationInfo(int64 InStartTimestamp);
	struct FRotator GetRotationIncrement(const struct FVector& InRotatorMask, const struct FAutoMovementViewingPattern& ViewingPattern);
	void IncreaseViewingRotation(ERotateType RotateType, bool bProxyCall);
	void LoadPathPoints();
	void PauseAutoMovement();
	void PostAutoMovement();
	void PreAutoMovement();
	void ProcessAutoMovement(const struct FVector& InLocation, const struct FRotator& InRotator);
	void RegisterAutoMovementConsoleCommands();
	void ResetAutoMovement();
	void ResetPitchRotation();
	void ResetTransportAttemptedCount();
	void ResetYawRotation();
	void ResumeAutoMovement();
	void SetSparseVersionEnabled(bool bEnabled);
	void StopAutoMovement();
	void SwitchRotateDirection();
	void SwitchToVirtualPawn(class UClass* VirtualPlayerBaseClass, const struct FVector& SpawningOffset);
	void TransportViewingPosition(const struct FVector& InLocation, const struct FRotator& InRotator, bool bProxyCall);

	bool CheckAutoMovementCompleted() const;
	bool CheckHitLocation(const struct FVector& InLocation) const;
	bool HasCompletedPitchingObservation() const;
	bool HasCompletedYawingObservation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoMovementMonitor">();
	}
	static class AAutoMovementMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAutoMovementMonitor>();
	}
};
//static_assert(alignof(AAutoMovementMonitor) == 0x000008, "Wrong alignment on AAutoMovementMonitor");
//static_assert(sizeof(AAutoMovementMonitor) == 0x000320, "Wrong size on AAutoMovementMonitor");
//static_assert(offsetof(AAutoMovementMonitor, AutoMovePattern) == 0x000278, "Member 'AAutoMovementMonitor::AutoMovePattern' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, ReportFilePath) == 0x000280, "Member 'AAutoMovementMonitor::ReportFilePath' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, PathPoints) == 0x000290, "Member 'AAutoMovementMonitor::PathPoints' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, CachedPathPoints) == 0x0002A0, "Member 'AAutoMovementMonitor::CachedPathPoints' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, bLogProcessingState) == 0x0002B0, "Member 'AAutoMovementMonitor::bLogProcessingState' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, bIsReadyToProcess) == 0x0002B1, "Member 'AAutoMovementMonitor::bIsReadyToProcess' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, bPitchingPositively) == 0x0002B2, "Member 'AAutoMovementMonitor::bPitchingPositively' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, TargetPositionIndex) == 0x0002B4, "Member 'AAutoMovementMonitor::TargetPositionIndex' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, TargetYawIndex) == 0x0002B8, "Member 'AAutoMovementMonitor::TargetYawIndex' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, TargetPitchIndex) == 0x0002BC, "Member 'AAutoMovementMonitor::TargetPitchIndex' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, TargetPosition) == 0x0002C0, "Member 'AAutoMovementMonitor::TargetPosition' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, TargetRotation) == 0x0002D8, "Member 'AAutoMovementMonitor::TargetRotation' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, ViewingPhaseIndex) == 0x0002F0, "Member 'AAutoMovementMonitor::ViewingPhaseIndex' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, AutoMoveStartTimeSinceAppStarted) == 0x0002F8, "Member 'AAutoMovementMonitor::AutoMoveStartTimeSinceAppStarted' has a wrong offset!");
//static_assert(offsetof(AAutoMovementMonitor, LastPointEndTimestamp) == 0x000308, "Member 'AAutoMovementMonitor::LastPointEndTimestamp' has a wrong offset!");

// Class UnrealExtent.AutoMovementUtil
// 0x0000 (0x0028 - 0x0028)
class UAutoMovementUtil final : public UBlueprintFunctionLibrary
{
public:
	static void AppendGeneralStatisticsToCapturedReport(const class FString& InFilename, int32 MetricsNum, int32 PointNum);
	static void AppendHeaderToCapturedReport(const TArray<class FString>& CapturedInfoNameList, const class FString& InFilename);
	static void AppendOfflinePathPoints(const TArray<struct FVector>& InPoints, const class FString& InFilePathUnderProjFolder);
	static bool ExportCapturedInfoBatch(const int32 BatchSize, const int32 TotalPointNum, const TArray<struct FGSPathPointStatInfo>& InPathPointStatsInfo, const class FString& InFilename, bool bLastBatch, bool bOutputHeader);
	static void ExportStatsCapturedReport(const TArray<struct FGSPathPointStatInfo>& InPathPointStatsInfo, const class FString& InFilename, bool bAppend, bool bOutputHeader);
	static class FString ExtractDateTimeInfo(const class FString& InString);
	static class FString FormatTimeAuto(const double InDuration, const int32 NumDigits);
	static class FString FormatTimeSeconds(const float InDuration);
	static struct FDateTime FromTimestamp(int64 Time);
	static TMap<class FString, float> GetCurPointProcessedMetricsMap(const struct FCapturedInfoArrayPerPoint& InCapturedInfoPerPoint);
	static int64 GetNowTimestamp();
	static TArray<struct FVector> GetOfflinePathPoints(const class FString& InFilePathUnderProjDir, bool bUseSparsePoints);
	static class FString GetVfxAutoPlayerRootFolderPath();
	static struct FCapturedInfoArrayPerPoint InsertIntoCapturedInfoArrayPerPoint(const TArray<struct FGSCapturedStatResult>& RawCapturedData, const struct FCapturedInfoArrayPerPoint& CapturedInfoArrayPerPoint);
	static bool LoadStatsCapturerReport(const class FString& InFileNameUnderProjFolder, TArray<struct FGSPathPointStatInfo>* AllPathPointStatInfo, int32 PointNum);
	static bool MergeMipReportsWithFileNameKeyword(const class FString& InDirectoryUnderProjDir, const class FString& InFileNameKeyword, const class FString& OutputMergedFileName);
	static bool MergeMultiTextureMipReports(const TArray<class FString>& InReportFilePaths, const class FString& OutputMergedFileName);
	static void SaveOfflinePathPoints(const TArray<struct FVector>& InPoints, const class FString& InFilePathUnderProjFolder);
	static void SetVfxAutoPlayerRootFolderPath(const class FString& InRootFolderPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoMovementUtil">();
	}
	static class UAutoMovementUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoMovementUtil>();
	}
};
//static_assert(alignof(UAutoMovementUtil) == 0x000008, "Wrong alignment on UAutoMovementUtil");
//static_assert(sizeof(UAutoMovementUtil) == 0x000028, "Wrong size on UAutoMovementUtil");

// Class UnrealExtent.GSE_SequenceMasterCppBase
// 0x0000 (0x0278 - 0x0278)
class AGSE_SequenceMasterCppBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SequenceMasterCppBase">();
	}
	static class AGSE_SequenceMasterCppBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSE_SequenceMasterCppBase>();
	}
};
//static_assert(alignof(AGSE_SequenceMasterCppBase) == 0x000008, "Wrong alignment on AGSE_SequenceMasterCppBase");
//static_assert(sizeof(AGSE_SequenceMasterCppBase) == 0x000278, "Wrong size on AGSE_SequenceMasterCppBase");

// Class UnrealExtent.AutoMoveTaskAssembler
// 0x0028 (0x0348 - 0x0320)
class AAutoMoveTaskAssembler final : public AAutoMovementMonitor
{
public:
	TArray<class AAutoMovementMonitor*>           Tasks;                                             // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         TaskID;                                            // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PointsTaskIdList;                                  // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	void IncreaseSubTaskViewingRotation(ERotateType InRotateType);
	void InitAutoMoveAssembler();
	void TransportSubTaskViewingPosition(const struct FVector& InLocation, const struct FRotator& InRotator);
	void UpdateProcessingState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoMoveTaskAssembler">();
	}
	static class AAutoMoveTaskAssembler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAutoMoveTaskAssembler>();
	}
};
//static_assert(alignof(AAutoMoveTaskAssembler) == 0x000008, "Wrong alignment on AAutoMoveTaskAssembler");
//static_assert(sizeof(AAutoMoveTaskAssembler) == 0x000348, "Wrong size on AAutoMoveTaskAssembler");
//static_assert(offsetof(AAutoMoveTaskAssembler, Tasks) == 0x000320, "Member 'AAutoMoveTaskAssembler::Tasks' has a wrong offset!");
//static_assert(offsetof(AAutoMoveTaskAssembler, TaskID) == 0x000330, "Member 'AAutoMoveTaskAssembler::TaskID' has a wrong offset!");
//static_assert(offsetof(AAutoMoveTaskAssembler, PointsTaskIdList) == 0x000338, "Member 'AAutoMoveTaskAssembler::PointsTaskIdList' has a wrong offset!");

// Class UnrealExtent.GSE_NetFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_NetFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void GetAllActiveConnectionInfo(class UObject* WorldContext, TArray<struct FGSConnectionInfo>* ConnectionInfos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_NetFuncLib">();
	}
	static class UGSE_NetFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_NetFuncLib>();
	}
};
//static_assert(alignof(UGSE_NetFuncLib) == 0x000008, "Wrong alignment on UGSE_NetFuncLib");
//static_assert(sizeof(UGSE_NetFuncLib) == 0x000028, "Wrong size on UGSE_NetFuncLib");

// Class UnrealExtent.TilingImage
// 0x0020 (0x02B0 - 0x0290)
class UTilingImage final : public UImage
{
public:
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TilingImage">();
	}
	static class UTilingImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTilingImage>();
	}
};
//static_assert(alignof(UTilingImage) == 0x000010, "Wrong alignment on UTilingImage");
//static_assert(sizeof(UTilingImage) == 0x0002B0, "Wrong size on UTilingImage");

// Class UnrealExtent.AutoOnlineSubsystemTest
// 0x0000 (0x0028 - 0x0028)
class UAutoOnlineSubsystemTest final : public UObject
{
public:
	static void TestGSSdkAuthToken();
	static void TestLogin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoOnlineSubsystemTest">();
	}
	static class UAutoOnlineSubsystemTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoOnlineSubsystemTest>();
	}
};
//static_assert(alignof(UAutoOnlineSubsystemTest) == 0x000008, "Wrong alignment on UAutoOnlineSubsystemTest");
//static_assert(sizeof(UAutoOnlineSubsystemTest) == 0x000028, "Wrong size on UAutoOnlineSubsystemTest");

// Class UnrealExtent.AssetDataArray
// 0x0018 (0x0040 - 0x0028)
class UAssetDataArray final : public UObject
{
public:
	TArray<struct FAssetData>                     AssetDataArr;                                      // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ActiveIdx;                                         // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetAssetDataCount();
	void SetActiveIdx(int32 Idx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetDataArray">();
	}
	static class UAssetDataArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetDataArray>();
	}
};
//static_assert(alignof(UAssetDataArray) == 0x000008, "Wrong alignment on UAssetDataArray");
//static_assert(sizeof(UAssetDataArray) == 0x000040, "Wrong size on UAssetDataArray");
//static_assert(offsetof(UAssetDataArray, AssetDataArr) == 0x000028, "Member 'UAssetDataArray::AssetDataArr' has a wrong offset!");
//static_assert(offsetof(UAssetDataArray, ActiveIdx) == 0x000038, "Member 'UAssetDataArray::ActiveIdx' has a wrong offset!");

// Class UnrealExtent.BattleCloud
// 0x0008 (0x0280 - 0x0278)
class ABattleCloud final : public AActor
{
public:
	bool                                          EnableSim;                                         // 0x0278(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MipmapDistanceScale;                               // 0x027C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCloud">();
	}
	static class ABattleCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleCloud>();
	}
};
//static_assert(alignof(ABattleCloud) == 0x000008, "Wrong alignment on ABattleCloud");
//static_assert(sizeof(ABattleCloud) == 0x000280, "Wrong size on ABattleCloud");
//static_assert(offsetof(ABattleCloud, EnableSim) == 0x000278, "Member 'ABattleCloud::EnableSim' has a wrong offset!");
//static_assert(offsetof(ABattleCloud, MipmapDistanceScale) == 0x00027C, "Member 'ABattleCloud::MipmapDistanceScale' has a wrong offset!");

// Class UnrealExtent.GSE_GameIntentFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_GameIntentFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool GetCachedActivityIntentReceivedParam(struct FCachedActivityIntentReceivedParamCS* OutParamCS);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_GameIntentFuncLib">();
	}
	static class UGSE_GameIntentFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_GameIntentFuncLib>();
	}
};
//static_assert(alignof(UGSE_GameIntentFuncLib) == 0x000008, "Wrong alignment on UGSE_GameIntentFuncLib");
//static_assert(sizeof(UGSE_GameIntentFuncLib) == 0x000028, "Wrong size on UGSE_GameIntentFuncLib");

// Class UnrealExtent.GSRTAvatarConfigPreset
// 0x00F0 (0x0120 - 0x0030)
class UGSRTAvatarConfigPreset final : public UPrimaryDataAsset
{
public:
	class FString                                 HeroActorBPPath;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             HeroTransform;                                     // 0x0040(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             RTCamTransform;                                    // 0x00A0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RTCamFOV;                                          // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRTAvatarRectLightConfig>       LightConfigs;                                      // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSRTAvatarConfigPreset">();
	}
	static class UGSRTAvatarConfigPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSRTAvatarConfigPreset>();
	}
};
//static_assert(alignof(UGSRTAvatarConfigPreset) == 0x000010, "Wrong alignment on UGSRTAvatarConfigPreset");
//static_assert(sizeof(UGSRTAvatarConfigPreset) == 0x000120, "Wrong size on UGSRTAvatarConfigPreset");
//static_assert(offsetof(UGSRTAvatarConfigPreset, HeroActorBPPath) == 0x000030, "Member 'UGSRTAvatarConfigPreset::HeroActorBPPath' has a wrong offset!");
//static_assert(offsetof(UGSRTAvatarConfigPreset, HeroTransform) == 0x000040, "Member 'UGSRTAvatarConfigPreset::HeroTransform' has a wrong offset!");
//static_assert(offsetof(UGSRTAvatarConfigPreset, RTCamTransform) == 0x0000A0, "Member 'UGSRTAvatarConfigPreset::RTCamTransform' has a wrong offset!");
//static_assert(offsetof(UGSRTAvatarConfigPreset, RTCamFOV) == 0x000100, "Member 'UGSRTAvatarConfigPreset::RTCamFOV' has a wrong offset!");
//static_assert(offsetof(UGSRTAvatarConfigPreset, LightConfigs) == 0x000108, "Member 'UGSRTAvatarConfigPreset::LightConfigs' has a wrong offset!");

// Class UnrealExtent.BGUAsyncLineTraceObject
// 0x0030 (0x0058 - 0x0028)
class UBGUAsyncLineTraceObject final : public UObject
{
public:
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void RequestAsyncLineTraceByChannelSingleStatic(class UBGUAsyncLineTraceObject* InLineTraceObject, int32 ReqID, const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool bTraceComplex, bool bDebug);
	static void RequestAsyncLineTraceByObjectTypeSingleStatic(class UBGUAsyncLineTraceObject* InLineTraceObject, int32 ReqID, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, bool bDebug);

	int32 GetAndCleanLineTraceResults(TArray<struct FAsyncLineTraceSingleResult>* OutAsyncLineTraceResults);
	void RequestAsyncLineTraceByChannelOnlyCheck(int32 ReqID, const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool bTraceComplex, bool bDebug);
	void RequestAsyncLineTraceByChannelSingle(int32 ReqID, const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool bTraceComplex, bool bDebug);
	void RequestAsyncLineTraceByChannelSingle_Batch(const TArray<struct FAsyncLineTraceReq>& ReqList, ECollisionChannel TraceChannel, bool bTraceComplex, bool bDebug);
	void RequestAsyncLineTraceByObjectTypeSingle(int32 ReqID, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, bool bDebug);
	void RequestAsyncLineTraceByObjectTypeSingle_Batch(const TArray<struct FAsyncLineTraceReq>& ReqList, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, bool bDebug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUAsyncLineTraceObject">();
	}
	static class UBGUAsyncLineTraceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUAsyncLineTraceObject>();
	}
};
//static_assert(alignof(UBGUAsyncLineTraceObject) == 0x000008, "Wrong alignment on UBGUAsyncLineTraceObject");
//static_assert(sizeof(UBGUAsyncLineTraceObject) == 0x000058, "Wrong size on UBGUAsyncLineTraceObject");
//static_assert(offsetof(UBGUAsyncLineTraceObject, IgnoreActors) == 0x000028, "Member 'UBGUAsyncLineTraceObject::IgnoreActors' has a wrong offset!");

// Class UnrealExtent.BGUMovieSceneParameterSection
// 0x0038 (0x0120 - 0x00E8)
class UBGUMovieSceneParameterSection final : public UMovieSceneSection
{
public:
	bool                                          bAffectClothMaterial;                              // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectAllMaterial;                                // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBGUScalarParameterInfoAndCurve> ScalarParameterInfosAndCurves;                     // 0x00F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBGUVectorParameterInfoAndCurves> VectorParameterInfosAndCurves;                     // 0x0100(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBGUColorParameterInfoAndCurves> ColorParameterInfosAndCurves;                      // 0x0110(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddColorParameterKey(const struct FBGUMaterialParameterInfo& InParameterInfo, const struct FFrameNumber& InTime, const struct FLinearColor& InValue);
	void AddScalarParameterKey(const struct FBGUMaterialParameterInfo& InParameterInfo, const struct FFrameNumber& InTime, float InValue);
	void AddVectorParameterKey(const struct FBGUMaterialParameterInfo& InParameterInfo, const struct FFrameNumber& InTime, const struct FVector& InValue);
	bool RemoveColorParameter(const struct FBGUMaterialParameterInfo& InParameterInfo);
	bool RemoveColorParameterByName(const class FName& InParameterInfoName);
	bool RemoveScalarParameter(const struct FBGUMaterialParameterInfo& InParameterInfo);
	bool RemoveScalarParameterByName(const class FName& InParameterInfoName);
	bool RemoveVectorParameter(const struct FBGUMaterialParameterInfo& InParameterInfo);
	bool RemoveVectorParameterByName(const class FName& InParameterInfoName);

	void GetParameterInfos(TSet<struct FBGUMaterialParameterInfo>* ParameterInfos) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUMovieSceneParameterSection">();
	}
	static class UBGUMovieSceneParameterSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUMovieSceneParameterSection>();
	}
};
//static_assert(alignof(UBGUMovieSceneParameterSection) == 0x000008, "Wrong alignment on UBGUMovieSceneParameterSection");
//static_assert(sizeof(UBGUMovieSceneParameterSection) == 0x000120, "Wrong size on UBGUMovieSceneParameterSection");
//static_assert(offsetof(UBGUMovieSceneParameterSection, bAffectClothMaterial) == 0x0000E8, "Member 'UBGUMovieSceneParameterSection::bAffectClothMaterial' has a wrong offset!");
//static_assert(offsetof(UBGUMovieSceneParameterSection, bAffectAllMaterial) == 0x0000E9, "Member 'UBGUMovieSceneParameterSection::bAffectAllMaterial' has a wrong offset!");
//static_assert(offsetof(UBGUMovieSceneParameterSection, ScalarParameterInfosAndCurves) == 0x0000F0, "Member 'UBGUMovieSceneParameterSection::ScalarParameterInfosAndCurves' has a wrong offset!");
//static_assert(offsetof(UBGUMovieSceneParameterSection, VectorParameterInfosAndCurves) == 0x000100, "Member 'UBGUMovieSceneParameterSection::VectorParameterInfosAndCurves' has a wrong offset!");
//static_assert(offsetof(UBGUMovieSceneParameterSection, ColorParameterInfosAndCurves) == 0x000110, "Member 'UBGUMovieSceneParameterSection::ColorParameterInfosAndCurves' has a wrong offset!");

// Class UnrealExtent.BGWBlockingVolume
// 0x0010 (0x02C0 - 0x02B0)
class ABGWBlockingVolume final : public AVolume
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNavModify;                                        // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaskFillCollisionUnderneathForNavmesh;            // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA[0x6];                                      // 0x02BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWBlockingVolume">();
	}
	static class ABGWBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWBlockingVolume>();
	}
};
//static_assert(alignof(ABGWBlockingVolume) == 0x000008, "Wrong alignment on ABGWBlockingVolume");
//static_assert(sizeof(ABGWBlockingVolume) == 0x0002C0, "Wrong size on ABGWBlockingVolume");
//static_assert(offsetof(ABGWBlockingVolume, bNavModify) == 0x0002B8, "Member 'ABGWBlockingVolume::bNavModify' has a wrong offset!");
//static_assert(offsetof(ABGWBlockingVolume, bMaskFillCollisionUnderneathForNavmesh) == 0x0002B9, "Member 'ABGWBlockingVolume::bMaskFillCollisionUnderneathForNavmesh' has a wrong offset!");

// Class UnrealExtent.CLRBindingTrigger
// 0x0000 (0x0278 - 0x0278)
class ACLRBindingTrigger final : public AActor
{
public:
	void GenerateClrBindingCode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLRBindingTrigger">();
	}
	static class ACLRBindingTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLRBindingTrigger>();
	}
};
//static_assert(alignof(ACLRBindingTrigger) == 0x000008, "Wrong alignment on ACLRBindingTrigger");
//static_assert(sizeof(ACLRBindingTrigger) == 0x000278, "Wrong size on ACLRBindingTrigger");

// Class UnrealExtent.ExedreScriptedTexture
// 0x0080 (0x0330 - 0x02B0)
class UExedreScriptedTexture final : public USceneComponent
{
public:
	bool                                          UseMipMaps;                                        // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureRenderTargetFormat                    RTFormat;                                          // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x66];                                     // 0x02B2(0x0066)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 ScriptedTexture;                                   // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            RenderingWidget;                                   // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExedreScriptedTexture">();
	}
	static class UExedreScriptedTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExedreScriptedTexture>();
	}
};
//static_assert(alignof(UExedreScriptedTexture) == 0x000010, "Wrong alignment on UExedreScriptedTexture");
//static_assert(sizeof(UExedreScriptedTexture) == 0x000330, "Wrong size on UExedreScriptedTexture");
//static_assert(offsetof(UExedreScriptedTexture, UseMipMaps) == 0x0002B0, "Member 'UExedreScriptedTexture::UseMipMaps' has a wrong offset!");
//static_assert(offsetof(UExedreScriptedTexture, RTFormat) == 0x0002B1, "Member 'UExedreScriptedTexture::RTFormat' has a wrong offset!");
//static_assert(offsetof(UExedreScriptedTexture, ScriptedTexture) == 0x000318, "Member 'UExedreScriptedTexture::ScriptedTexture' has a wrong offset!");
//static_assert(offsetof(UExedreScriptedTexture, RenderingWidget) == 0x000320, "Member 'UExedreScriptedTexture::RenderingWidget' has a wrong offset!");

// Class UnrealExtent.FoliageInteractiveVolume
// 0x0000 (0x0280 - 0x0280)
class AFoliageInteractiveVolume final : public ATriggerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageInteractiveVolume">();
	}
	static class AFoliageInteractiveVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoliageInteractiveVolume>();
	}
};
//static_assert(alignof(AFoliageInteractiveVolume) == 0x000008, "Wrong alignment on AFoliageInteractiveVolume");
//static_assert(sizeof(AFoliageInteractiveVolume) == 0x000280, "Wrong size on AFoliageInteractiveVolume");

// Class UnrealExtent.GenerateLandscapeHeightfieldVolume
// 0x0000 (0x02B0 - 0x02B0)
class AGenerateLandscapeHeightfieldVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenerateLandscapeHeightfieldVolume">();
	}
	static class AGenerateLandscapeHeightfieldVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGenerateLandscapeHeightfieldVolume>();
	}
};
//static_assert(alignof(AGenerateLandscapeHeightfieldVolume) == 0x000008, "Wrong alignment on AGenerateLandscapeHeightfieldVolume");
//static_assert(sizeof(AGenerateLandscapeHeightfieldVolume) == 0x0002B0, "Wrong size on AGenerateLandscapeHeightfieldVolume");

// Class UnrealExtent.GenerateLandscapeVolume
// 0x00A0 (0x0350 - 0x02B0)
class AGenerateLandscapeVolume final : public AVolume
{
public:
	class FString                                 ExportFilename;                                    // 0x02B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandscapeHeightLiftUp;                             // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResolutionPerComponent;                            // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LandscapeMaterial;                                 // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LandscapeHoleMaterial;                             // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             StaticMeshToPMGrassList;                           // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreActorTags;                                   // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              ComponentScaleXY;                                  // 0x02F0(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3d                              OriginPoint;                                       // 0x0300(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeltaZ;                                         // 0x0318(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ComponentMinIndex;                                 // 0x031C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ComponentNum;                                      // 0x0324(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              HeightfieldResolution;                             // 0x032C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALandscape*                             LandscapeActor;                                    // 0x0338(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         LandscapeStreamingProxies;                         // 0x0340(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenerateLandscapeVolume">();
	}
	static class AGenerateLandscapeVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGenerateLandscapeVolume>();
	}
};
//static_assert(alignof(AGenerateLandscapeVolume) == 0x000008, "Wrong alignment on AGenerateLandscapeVolume");
//static_assert(sizeof(AGenerateLandscapeVolume) == 0x000350, "Wrong size on AGenerateLandscapeVolume");
//static_assert(offsetof(AGenerateLandscapeVolume, ExportFilename) == 0x0002B0, "Member 'AGenerateLandscapeVolume::ExportFilename' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, LandscapeHeightLiftUp) == 0x0002C0, "Member 'AGenerateLandscapeVolume::LandscapeHeightLiftUp' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, ResolutionPerComponent) == 0x0002C4, "Member 'AGenerateLandscapeVolume::ResolutionPerComponent' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, LandscapeMaterial) == 0x0002C8, "Member 'AGenerateLandscapeVolume::LandscapeMaterial' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, LandscapeHoleMaterial) == 0x0002D0, "Member 'AGenerateLandscapeVolume::LandscapeHoleMaterial' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, StaticMeshToPMGrassList) == 0x0002D8, "Member 'AGenerateLandscapeVolume::StaticMeshToPMGrassList' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, IgnoreActorTags) == 0x0002E0, "Member 'AGenerateLandscapeVolume::IgnoreActorTags' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, ComponentScaleXY) == 0x0002F0, "Member 'AGenerateLandscapeVolume::ComponentScaleXY' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, OriginPoint) == 0x000300, "Member 'AGenerateLandscapeVolume::OriginPoint' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, MaxDeltaZ) == 0x000318, "Member 'AGenerateLandscapeVolume::MaxDeltaZ' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, ComponentMinIndex) == 0x00031C, "Member 'AGenerateLandscapeVolume::ComponentMinIndex' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, ComponentNum) == 0x000324, "Member 'AGenerateLandscapeVolume::ComponentNum' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, HeightfieldResolution) == 0x00032C, "Member 'AGenerateLandscapeVolume::HeightfieldResolution' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, LandscapeActor) == 0x000338, "Member 'AGenerateLandscapeVolume::LandscapeActor' has a wrong offset!");
//static_assert(offsetof(AGenerateLandscapeVolume, LandscapeStreamingProxies) == 0x000340, "Member 'AGenerateLandscapeVolume::LandscapeStreamingProxies' has a wrong offset!");

// Class UnrealExtent.GSBitmapFontBox
// 0x0140 (0x0270 - 0x0130)
class UGSBitmapFontBox final : public UWidget
{
public:
	struct FSlateBrush                            Brush;                                             // 0x0130(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0200(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0218(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x0230(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FontScaleFactor;                                   // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharSpacing;                                       // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSBitmapJustification                        Justification;                                     // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x27];                                     // 0x0249(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSBitmapFontBox">();
	}
	static class UGSBitmapFontBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSBitmapFontBox>();
	}
};
//static_assert(alignof(UGSBitmapFontBox) == 0x000010, "Wrong alignment on UGSBitmapFontBox");
//static_assert(sizeof(UGSBitmapFontBox) == 0x000270, "Wrong size on UGSBitmapFontBox");
//static_assert(offsetof(UGSBitmapFontBox, Brush) == 0x000130, "Member 'UGSBitmapFontBox::Brush' has a wrong offset!");
//static_assert(offsetof(UGSBitmapFontBox, BrushDelegate) == 0x000200, "Member 'UGSBitmapFontBox::BrushDelegate' has a wrong offset!");
//static_assert(offsetof(UGSBitmapFontBox, Font) == 0x000210, "Member 'UGSBitmapFontBox::Font' has a wrong offset!");
//static_assert(offsetof(UGSBitmapFontBox, Text) == 0x000218, "Member 'UGSBitmapFontBox::Text' has a wrong offset!");
//static_assert(offsetof(UGSBitmapFontBox, TextDelegate) == 0x000230, "Member 'UGSBitmapFontBox::TextDelegate' has a wrong offset!");
//static_assert(offsetof(UGSBitmapFontBox, FontScaleFactor) == 0x000240, "Member 'UGSBitmapFontBox::FontScaleFactor' has a wrong offset!");
//static_assert(offsetof(UGSBitmapFontBox, CharSpacing) == 0x000244, "Member 'UGSBitmapFontBox::CharSpacing' has a wrong offset!");
//static_assert(offsetof(UGSBitmapFontBox, Justification) == 0x000248, "Member 'UGSBitmapFontBox::Justification' has a wrong offset!");

// Class UnrealExtent.GSCrowdManagerV1
// 0x00B0 (0x01A0 - 0x00F0)
class UGSCrowdManagerV1 final : public UCrowdManager
{
public:
	uint8                                         Pad_F0[0xB0];                                      // 0x00F0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCrowdManagerV1">();
	}
	static class UGSCrowdManagerV1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCrowdManagerV1>();
	}
};
//static_assert(alignof(UGSCrowdManagerV1) == 0x000008, "Wrong alignment on UGSCrowdManagerV1");
//static_assert(sizeof(UGSCrowdManagerV1) == 0x0001A0, "Wrong size on UGSCrowdManagerV1");

// Class UnrealExtent.GSDropCanvasPanel
// 0x0010 (0x0168 - 0x0158)
class UGSDropCanvasPanel final : public UCanvasPanel
{
public:
	FMulticastInlineDelegateProperty_             OnDropEvent;                                       // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSDropCanvasPanel">();
	}
	static class UGSDropCanvasPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSDropCanvasPanel>();
	}
};
//static_assert(alignof(UGSDropCanvasPanel) == 0x000008, "Wrong alignment on UGSDropCanvasPanel");
//static_assert(sizeof(UGSDropCanvasPanel) == 0x000168, "Wrong size on UGSDropCanvasPanel");
//static_assert(offsetof(UGSDropCanvasPanel, OnDropEvent) == 0x000158, "Member 'UGSDropCanvasPanel::OnDropEvent' has a wrong offset!");

// Class UnrealExtent.GSEWaterBodyRiver
// 0x0000 (0x02A8 - 0x02A8)
class AGSEWaterBodyRiver final : public AWaterBodyRiver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEWaterBodyRiver">();
	}
	static class AGSEWaterBodyRiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSEWaterBodyRiver>();
	}
};
//static_assert(alignof(AGSEWaterBodyRiver) == 0x000008, "Wrong alignment on AGSEWaterBodyRiver");
//static_assert(sizeof(AGSEWaterBodyRiver) == 0x0002A8, "Wrong size on AGSEWaterBodyRiver");

// Class UnrealExtent.GSE_AIFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_AIFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void AISetBT(class AActor* Actor, class UBehaviorTree* BTAsset);
	static void ListenerForgetsActor(class UAIPerceptionComponent* PerceptionComp, class AActor* ActorToForget);
	static void SetAIBTPause(class UBrainComponent* BrainComponent, bool bEnable);
	static void SetAIBTStop(class UBehaviorTreeComponent* BTComp);
	static void SetAISenseConfig(class UAIPerceptionComponent* PerceptionComp, float HearRange, float SightRange, float LoseSightRange, float VisionAngleDegrees, float ASRangeFromLastSeenLoc, bool IsSightDominantSense, bool* IsHearingSet, bool* IsSightSet);
	static void SetPerceptionForgetAll(class UAIPerceptionComponent* PerceptionComp);
	static void SinglePerceptionSetEnable(class UAIPerceptionComponent* PerceptionComp, bool IsHearing, bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_AIFuncLib">();
	}
	static class UGSE_AIFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_AIFuncLib>();
	}
};
//static_assert(alignof(UGSE_AIFuncLib) == 0x000008, "Wrong alignment on UGSE_AIFuncLib");
//static_assert(sizeof(UGSE_AIFuncLib) == 0x000028, "Wrong size on UGSE_AIFuncLib");

// Class UnrealExtent.GSE_AnimationFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_AnimationFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void AnimationBindAllPossessableObject(class UUserWidget* RootWidget, class UWidgetAnimation* Animation, bool UseDisplayName);
	static void AnimationBindPossessableObjectCS(class UWidgetAnimation* Animation, const struct FSequenceBindingIDInCS& BindingID, class UObject* BindObj, class UObject* Ctx);
	static class UWidgetAnimation* DuplicateAnimation(class UWidgetAnimation* InAnimation, class UObject* Outer_0, class FName Name_0);
	static struct FMovieSceneObjectBindingID GetAnimationBindingIDByDisplayName(class UWidgetAnimation* Animation, const class FName& TargetName);
	static struct FMovieSceneObjectBindingID GetAnimationBindingIDByName(class UWidgetAnimation* Animation, const class FName& TargetName);
	static struct FSequenceBindingIDInCS GetAnimationBindingIDByNameCS(class UWidgetAnimation* Animation, const class FName& TargetName);
	static bool SaveAsset(class UWidgetAnimation* InAnimation, const class FString& Path, const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_AnimationFuncLib">();
	}
	static class UGSE_AnimationFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_AnimationFuncLib>();
	}
};
//static_assert(alignof(UGSE_AnimationFuncLib) == 0x000008, "Wrong alignment on UGSE_AnimationFuncLib");
//static_assert(sizeof(UGSE_AnimationFuncLib) == 0x000028, "Wrong size on UGSE_AnimationFuncLib");

// Class UnrealExtent.GSE_AnimDistanceMatchingLibrary
// 0x0000 (0x0028 - 0x0028)
class UGSE_AnimDistanceMatchingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FSequenceEvaluatorReference AdvanceTimeByDistanceMatchToTarget(const struct FAnimUpdateContext& UpdateContext, const struct FSequenceEvaluatorReference& SequenceEvaluator, float DistanceToTarget, class FName DistanceCurveName, const struct FVector2D& PlayRateClamp);
	static struct FSequenceEvaluatorReference AdvanceTimeBySpeedMatching(const struct FAnimUpdateContext& UpdateContext, const struct FSequenceEvaluatorReference& SequenceEvaluator, float SpeedToMatch, const struct FVector2D& PlayRateClamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_AnimDistanceMatchingLibrary">();
	}
	static class UGSE_AnimDistanceMatchingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_AnimDistanceMatchingLibrary>();
	}
};
//static_assert(alignof(UGSE_AnimDistanceMatchingLibrary) == 0x000008, "Wrong alignment on UGSE_AnimDistanceMatchingLibrary");
//static_assert(sizeof(UGSE_AnimDistanceMatchingLibrary) == 0x000028, "Wrong size on UGSE_AnimDistanceMatchingLibrary");

// Class UnrealExtent.GSE_AnimFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_AnimFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static float ABPStateMachineGetGlobalWeight(class UAnimInstance* AnimInst, const class FName& StateMachineName, const class FName& StateName);
	static bool AddAnimSequence(class UAnimMontage* TargetMontage, class UAnimSequence* Sequence);
	static bool AddPoint(class UBlendSpace* BlendSpace, class UAnimSequence* PointSequence, const struct FVector& PointValue);
	static bool AddPreviewAssetToSkeleton(class USkeleton* InUSkeleton, const class FString& BoneName, class UObject* PreviewAsset);
	static bool AddSocketToSkeleton(class USkeleton* InUSkeleton, const class FString& BoneName, const class FString& SocketName, const struct FTransform& Offset);
	static void AnimInstanceMontageSetPos(class UAnimInstance* AnimInst, float MontagePos);
	static void AnimMontageGetBlendInAndOutTime(class UAnimMontage* AnimMontage, float* BlendInTime, float* BlendOutTime);
	static struct FTransform AnimMontageGetBoneTransformWS(class UAnimMontage* AnimMontage, const class USkeletalMeshComponent* MeshComponent, class FName BoneName, float Pos, bool IsNeedFixRotator, const struct FRotator& FixRotator);
	static float AnimMontageGetMontageEndTimeForScale(class UAnimMontage* AnimMontage);
	static struct FTransform AnimMontageGetQTEBoneTransform(class UAnimMontage* AnimMontage, const class USkeletalMeshComponent* MeshComponent, class FName BoneName, float Pos);
	static bool AnimMontageGetRootMotionLocationForScale(class UAnimMontage* AnimMontage, struct FVector* OutStartPos, struct FVector* OutEndPos, float LeftScaleTime, float RightScaleTime);
	static bool AnimMontageGetRootMotionRotationForScale(class UAnimMontage* AnimMontage, struct FRotator* OutStartRotation, struct FRotator* OutEndRotation, float LeftScaleTime, float RightScaleTime);
	static bool AnimMontageGetSocketLocationForScale(class UAnimMontage* AnimMontage, struct FVector* OutEndPos, float ScaleTime, const class FString& SocketName);
	static float AnimSequenceFindPosWithDistanceCurve(class UAnimSequence* AnimationSequence, class FName CurveName, float DistanceValue);
	static bool AnimSequenceGetRootMotionLocationForScale(class UAnimSequence* AnimMontage, struct FVector* OutStartPos, struct FVector* OutEndPos, float LeftScaleTime, float RightScaleTime);
	static bool AnimSequenceGetRootMotionRotationForScale(class UAnimSequence* AnimMontage, struct FQuat* OutStartPos, struct FQuat* OutEndPos, float LeftScaleTime, float RightScaleTime);
	static void ApplyDamage(class UDestructibleComponent* Destructible, float DamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float ImpulseStrength);
	static void ApplyRadiusDamage(class UDestructibleComponent* Destructible, float BaseDamage, const struct FVector& HurtOrigin, float DamageRadius, float ImpulseStrength, bool bFullDamage);
	static float CalcSlotMontageLocalWeight(class UAnimInstance* AnimInst, const class FName& SlotNodeName);
	static bool ChangeAnimSeqParamAndSave(class UAnimSequence* AnimMontage, bool bRootMotion, bool bForceRootLock);
	static void ConditionallyDispatchQueuedAnimEvents(class USkeletalMeshComponent* SkeletalMeshComp);
	static class UAimOffsetBlendSpace* CreateAimOffsetBlendSpace(const class FString& Path, const class FString& Name_0, class USkeleton* TargetSkeleton);
	static class UAnimMontage* CreateAnimMontage(const class FString& Path, const class FString& Name_0, class USkeleton* TargetSkeleton);
	static class UBlendSpace* CreateBlendSpace(const class FString& Path, const class FString& Name_0, class USkeleton* TargetSkeleton);
	static class UBlendSpace1D* CreateBlendSpace1D(const class FString& Path, const class FString& Name_0, class USkeleton* TargetSkeleton);
	static void DisableMontageRootMotionByInstanceID(class ACharacter* Character, int32 MontageInstanceID);
	static struct FTransform ExtractRootMotionFromAnimation(const class UAnimSequenceBase* Animation, float StartTime, float EndTime);
	static void FindAsset(const class FString& Path, class UClass* InClass, TArray<struct FAssetData>* AssetData);
	static class UObject* FindDestructibleMeshFromPathByBoneName(const class FString& FolderPath, const class FString& BoneName);
	static bool GenerateAimOffsetBlendSpace(class UAimOffsetBlendSpace* AimOffset, const class FString& Path, const class FString& ExampleName);
	static bool GenerateDefaultAxisParameters(class UBlendSpace* BlendSpace);
	static bool GenerateDestructibleComponentFromPath(const class FString& FolderPath, class USkeletalMeshComponent* TargetSkeletalMeshComp, TArray<class UDestructibleComponent*>* DestructibleMeshArray, TArray<class FName>* BoneNameArray);
	static bool GenerateDestructibleComponentFromPathWithEditor(const class FString& FolderPath, class UObject* TargetActor);
	static int32 GetActiveMontageInstanceID(const class UAnimInstance* AnimInstance);
	static TArray<class UAnimationAsset*> GetAllAnimationsOfSkeleton(class USkeletalMesh* SkeletonMesh, const class FString& AnimationBasePath);
	static bool GetAllAnimSyncMarkers(const class UAnimSequence* AnimSequence, TArray<struct FAnimSyncMarker>* OutSyncMarkers);
	static void GetAllNotifyEvent(class UAnimMontage* TargetMontage, TArray<struct FAnimNotifyEvent>* AnimNotifyEventList);
	static TArray<struct FAnimNotifyEvent> GetAllNotifyEventInAM(class UAnimMontage* TargetMontage, TArray<struct FGSNotifyEventTimeInfo>* TimeInfoList);
	static void GetAnimAllNotifyEventIncludeAS(const TArray<class UAnimSequenceBase*>& AnimBases, TArray<struct FAnimNotifyEvent>* AnimNotifyEventList);
	static float GetAnimCurrentTime(class UAnimInstance* AnimInst, int32 FromInstanceID);
	static struct FTransform GetBoneTransform(class USkeletalMeshComponent* Mesh, int32 BoneIndex);
	static struct FTransform GetBoneTransformByTime(class UAnimSequence* AnimationSequence, float Time, int32 TrackIndex, bool UseRawData);
	static int32 GetChildBones(class USkeleton* InSkeleton, const class FName& ParentBoneName, const TArray<class FName>& BoneNameFilter, TSet<class FName>* ChildBones);
	static void GetChildSockets(class USkeletalMeshComponent* SkeletalMeshComp, const class FName& BaseBoneName, TArray<class FName>* ChildSocketNames);
	static int32 GetCurrentActiveMontageInstanceID(class ACharacter* Character);
	static class FString GetFolderPathFromFullPath(const class FString& FullPath);
	static int32 GetMontageComboSkillID(class UAnimMontage* AnimInst, int32 Index_0);
	static int32 GetMontageEffectID(class UAnimMontage* AnimInst, int32 Index_0);
	static class FName GetMontageNextSection(class UAnimInstance* AnimInstance, class UAnimMontage* AnimMontage);
	static class FString GetMontageNotifyName(class UAnimMontage* AnimInst, int32 Index_0);
	static float GetMontageNotifyTriggerTime(class UAnimMontage* AnimInst, int32 FromInstanceID);
	static class FName GetMontageSectionName(class UAnimMontage* AnimMontage, int32 Index_0);
	static void GetMontageSectionStartAndEndTime(class UAnimMontage* AnimMontage, const class FName& SectionName, float* OutStartTime, float* OutEndTime);
	static class FName GetMontageSlotName(const class UAnimMontage* Montage, int32 SlotIndex);
	static float GetNotifyComboEndTime(class UAnimMontage* AnimInst, int32 Index_0);
	static float GetNotifyEndTriggerTime(const struct FAnimNotifyEvent& AnimNotifyEvent);
	static float GetNotifyTriggerTime(const struct FAnimNotifyEvent& AnimNotifyEvent);
	static void GetOneAnimAllNotifyEventIncludeAS(class UAnimSequenceBase* TargetAnim, TArray<struct FAnimNotifyEvent>* AnimNotifyEventList);
	static class USkeleton* GetSkeleton(class UAnimSequenceBase* AnimSequenceBase);
	static void InitAnimGraphNode(class UAnimInstance* AnimInst, const class FName Tag);
	static bool IsInRootMotionAM(class ACharacter* Character);
	static bool IsSlotPlayingMontage(class UAnimInstance* AnimInst, class FName SlotNodeName);
	static void MarkDirty(class UObject* Obj);
	static struct FTransform Montage_GetBoneRelativeTransformCS(const class UAnimMontage* InMontage, const float InTime, const class FName InBoneName, const class FName InSlotName, bool bExtractRootMotion);
	static struct FTransform Montage_GetBoneTransformCS(const class UAnimMontage* InMontage, const float InTime, const class FName InBoneName, const class FName InSlotName, bool bExtractRootMotion);
	static void ReinitAnim(class AActor* Owner);
	static bool RemoveAllPoints(class UBlendSpace* BlendSpace);
	static void RemoveNotifyEventByIndex(class UAnimMontage* TargetMontage, int32 Index_0);
	static void RemoveNotifyTrackByName(class UAnimMontage* TargetMontage, class FName Name_0);
	static bool RemovePreviewAssetFromSkeleton(class USkeleton* InUSkeleton, const class FString& BoneName);
	static struct FTransform Sequence_GetBoneTransformCS(const class UAnimSequence* AnimSeq, const float InTime, const class FName BoneName, bool bExtractRootMotion);
	static struct FTransform Sequence_GetRelativeBoneTransformCS(const class UAnimSequence* AnimSeq, const float InTime, const class FName BoneName, bool bExtractRootMotion);
	static bool SetAnimcurveType(class USkeleton* Skeleton, const class FString& CurveName, bool Value);
	static void SetBlendSpaceInput(class USkeletalMeshComponent* Obj, const struct FVector& BlendParams);
	static void SetMaterial(class UMaterialInterface* Material, class UDestructibleMesh* TargetMesh, int32 Index_0);
	static void SetRootMotionFromEverythingSwitch(class ACharacter* Character, bool IsOpen);
	static void StopAllMontages(class AActor* Owner, float BlendOutTime);
	static void TickAnimation(class AActor* Owner);
	static void TickAnimationAndRefreshBone(class AActor* Owner);
	static void TickAnimationAndRefreshBone_SkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_AnimFuncLib">();
	}
	static class UGSE_AnimFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_AnimFuncLib>();
	}
};
//static_assert(alignof(UGSE_AnimFuncLib) == 0x000008, "Wrong alignment on UGSE_AnimFuncLib");
//static_assert(sizeof(UGSE_AnimFuncLib) == 0x000028, "Wrong size on UGSE_AnimFuncLib");

// Class UnrealExtent.GSE_BehaviorTreeFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_BehaviorTreeFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool BTDecoratorOverrideChildIdx(class UBTDecorator_BlueprintBase* BTDecorator, int32 NewIndex);
	static void GetBTTaskNodes(class UBehaviorTree* BT, struct FBehaviorTreeNodeData* NodeData);
	static TArray<class FString> GetCurrentBTActiveNodeInfo(class UBehaviorTreeComponent* BehaviorTreeComp);
	static class UBehaviorTree* GetCurrentTree(class AAIController* AIController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_BehaviorTreeFuncLib">();
	}
	static class UGSE_BehaviorTreeFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_BehaviorTreeFuncLib>();
	}
};
//static_assert(alignof(UGSE_BehaviorTreeFuncLib) == 0x000008, "Wrong alignment on UGSE_BehaviorTreeFuncLib");
//static_assert(sizeof(UGSE_BehaviorTreeFuncLib) == 0x000028, "Wrong size on UGSE_BehaviorTreeFuncLib");

// Class UnrealExtent.GSE_ActorFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_ActorFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class UActorComponent* AddComponentByClass(class AActor* Actor, TSubclassOf<class UActorComponent> Class_0, bool bManualAttachment, const struct FTransform& RelativeTransform, bool bDeferredFinish);
	static void AddInstanceComponent(class AActor* Actor, class UActorComponent* Component);
	static void AddNamePrefix(class AActor* Actor, const class FString& NamePrefix);
	static void CacheCapturingStreamingMeshLodStats();
	static void CaptureStreamingMeshLodStats();
	static bool CheckActorWasRecentlyRendered(class AActor* Actor);
	static void DetectRegionCenter(class AActor* Actor, const TArray<struct FVector>& TraceDirectionList, float TraceDistance, ETraceTypeQuery TraceChannel, EDrawDebugTrace DrawDebugType, float DrawTime, float VaildRange, struct FVector* AdjustedLocation, double* AdjustedRadius, bool* IsSuccess);
	static void EndCapturingStreamingMeshLodStats();
	static void ExcuteStreamingMeshMemoryStats();
	static void FinishAddComponent(class AActor* Actor, class UActorComponent* NewActorComp, bool bManualAttachment, const struct FTransform& RelativeTransform);
	static void GetActorForwardVector(class AActor* Actor, struct FVector* OutDir);
	static void GetActorHasAuthority(class AActor* Actor, bool* OutHasAuthority);
	static void GetActorLocationSimple(class AActor* Actor, struct FVector* OutPos);
	static void GetActorRotationSimple(class AActor* Actor, struct FRotator* OutRot);
	static void GetActorTransformSimple(class AActor* Actor, struct FTransform* OutTrans);
	static void GetAttachParentActor(class AActor* Actor, class AActor* AttachParentActor);
	static void GetVelocity(class AActor* Actor, struct FVector* OutVelocity);
	static void GetWorldTransformFast(class USceneComponent* SceneComp, struct FTransform* OutWorldTransform);
	static bool IsAABoundBoxInVolume(class AVolume* VolumeActor, const struct FVector& BoundOrigin, const struct FVector& BoundExtent, bool* IsFullContain);
	static bool IsActorBeginningPlayFromLevelStreaming(class AActor* Actor);
	static bool IsPointInVolume(class AVolume* VolumeActor, const struct FVector& Point, float Radius);
	static void LoadCapturingStreamingMeshLodStats();
	static void LoadReflectionCubeLocation(TArray<struct FVector>* PathPointList, const class FString& FilePathUnderProjFolder);
	static void RemoveComponent(class UActorComponent* Component);
	static void SetActorComponentsTickEnable(class AActor* Actor, bool bEnable);
	static void SetActorComponentsTickInterval(class AActor* Actor, float NewInterval);
	static void SetActorLocationAndRotationSimple(class AActor* Actor, const struct FVector& Pos, const struct FRotator& Rot, bool bSweep, int32 ITeleportType);
	static void SetActorLocationSimple(class AActor* Actor, const struct FVector& Pos, bool bSweep, int32 ITeleportType);
	static void SetActorRotationSimple(class AActor* Actor, const struct FRotator& Rot, int32 ITeleportType);
	static void SetActorTransformSimple(class AActor* Actor, const struct FTransform& Trans, bool bSweep, int32 ITeleportType);
	static void SetMaterialInterfaceQualityLevel(class AActor* Actor, class UMaterialInterface* Material, int32 QualityLevel);
	static class AActor* SpawnBlueprintActorByFactory(class UBlueprint* InAsset, class ULevel* InLevel, const struct FTransform& InTransform);
	static class AActor* SpawnBlueprintActorByFactory_BP(class UBlueprint* InAsset, class UObject* Obj, const struct FTransform& InTransform);
	static void SpawnSphereUniformPoints(TArray<struct FVector>* SphereUniformPoints, int32 NumOfPoints, float Radius);
	static void StatLevelNaniteMemory(const TArray<class ULevel*>& LoadedLevels, const class FString& WorldPositionFile, const class FString& MemoryFile);
	static void UpdateActorOverlaps(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_ActorFuncLib">();
	}
	static class UGSE_ActorFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_ActorFuncLib>();
	}
};
//static_assert(alignof(UGSE_ActorFuncLib) == 0x000008, "Wrong alignment on UGSE_ActorFuncLib");
//static_assert(sizeof(UGSE_ActorFuncLib) == 0x000028, "Wrong size on UGSE_ActorFuncLib");

// Class UnrealExtent.GSE_SceneComponentFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_SceneComponentFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void SetWorldLocationAndRotationSimple(class USceneComponent* InSceneComponent, const struct FVector& Pos, const struct FRotator& Rot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SceneComponentFuncLib">();
	}
	static class UGSE_SceneComponentFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_SceneComponentFuncLib>();
	}
};
//static_assert(alignof(UGSE_SceneComponentFuncLib) == 0x000008, "Wrong alignment on UGSE_SceneComponentFuncLib");
//static_assert(sizeof(UGSE_SceneComponentFuncLib) == 0x000028, "Wrong size on UGSE_SceneComponentFuncLib");

// Class UnrealExtent.GSE_SplineComponentFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_SplineComponentFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SplineComponentFuncLib">();
	}
	static class UGSE_SplineComponentFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_SplineComponentFuncLib>();
	}
};
//static_assert(alignof(UGSE_SplineComponentFuncLib) == 0x000008, "Wrong alignment on UGSE_SplineComponentFuncLib");
//static_assert(sizeof(UGSE_SplineComponentFuncLib) == 0x000028, "Wrong size on UGSE_SplineComponentFuncLib");

// Class UnrealExtent.GSE_CharacterFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_CharacterFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static float CalculateMaxDistanceFactor(class AActor* Actor);
	static float CalculateScreenPercentageFromController(class AActor* Actor, class AController* Controller);
	static float GetActorBoundingSphereRadius(class AActor* Actor);
	static struct FTransform GetBoneTransform(class ACharacter* Character, int32 BoneIndex);
	static struct FTransform GetBoneTransformByMesh(class USkeletalMeshComponent* Mesh, int32 BoneIndex);
	static float GetPathFollowingBrakingDistance(class UCharacterMovementComponent* CharacterMovement);
	static class USceneComponent* GetSceneComponentByName(class AActor* Actor, const class FString& ComponentName);
	static struct FTransform GetSceneComponentTransformByName(class AActor* Actor, const class FString& ComponentName);
	static struct FVector GetSocketLocation(class USceneComponent* Comp, const class FName& SocketName);
	static struct FRotator GetSocketRotation(class USceneComponent* Comp, const class FName& SocketName);
	static struct FTransform GetSocketTransform(class USceneComponent* Comp, const class FName& SocketName, ERelativeTransformSpace TransfromSpace);
	static void RecreatePhysicsState(class USkeletalMeshComponent* Mesh);
	static void SetActorSKMeshesUpdateRateOptimizations(class AActor* Actor, bool bEnable);
	static void SetAllPABodiesBelowResponseToAllChannels(class USkeletalMeshComponent* Mesh, const class FName& BoneName, ECollisionResponse NewResponse);
	static void SetAllPABodiesBelowResponseToChannels(class USkeletalMeshComponent* Mesh, const class FName& BoneName, const TArray<ECollisionChannel>& Channels, ECollisionResponse NewResponse);
	static void SetAnimRootMotionTranslationScale(class ACharacter* Character, float Scale);
	static void SetLocalScreenPercentageIfLocalController(class AActor* Actor, class AController* Controller, float ScreenPercentage, float* OutLocalScreenPercentage);
	static void SetMontagePlayRate(class ACharacter* Character, float PlayRate);
	static void Tick(class AActor* Actor, float DeltaTime);
	static void ToggleActorTickEnabled(class AActor* InActor, bool bEnable, bool ToggleActorTick, bool ToggleMoveComp, bool ToggleAIComp, bool ToggleSKMeshComp, bool ToggleAkComp, bool ToggleINCLUDE_CHILD_ACTOR);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_CharacterFuncLib">();
	}
	static class UGSE_CharacterFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_CharacterFuncLib>();
	}
};
//static_assert(alignof(UGSE_CharacterFuncLib) == 0x000008, "Wrong alignment on UGSE_CharacterFuncLib");
//static_assert(sizeof(UGSE_CharacterFuncLib) == 0x000028, "Wrong size on UGSE_CharacterFuncLib");

// Class UnrealExtent.GSE_ChunkFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_ChunkFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool IsPlayGoInstalling();
	static bool TryGetPlayGoInfo(int64* ProgressSize, int64* TotalSize, double* CurrentTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_ChunkFuncLib">();
	}
	static class UGSE_ChunkFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_ChunkFuncLib>();
	}
};
//static_assert(alignof(UGSE_ChunkFuncLib) == 0x000008, "Wrong alignment on UGSE_ChunkFuncLib");
//static_assert(sizeof(UGSE_ChunkFuncLib) == 0x000028, "Wrong size on UGSE_ChunkFuncLib");

// Class UnrealExtent.GSE_ConfigFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_ConfigFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void Flush(EConfigIniFileNames ConfigFile, const bool bRefreshInConfigSystem);
	static TArray<class FString> GetArray(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static bool GetBool(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static struct FColor GetColor(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static float GetFloat(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static int32 GetInt(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static struct FRotator GetRotator(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static class FString GetString(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static class FText GetText(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static struct FVector GetVector(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static struct FVector2D GetVector2D(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static struct FVector4 GetVector4(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, bool* bWasFound);
	static void SetArray(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const TArray<class FString>& ArrayValue);
	static void SetBool(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const bool BoolValue);
	static void SetColor(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const struct FColor& ColorValue);
	static void SetFloat(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const float FloatValue);
	static void SetInt(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const int32 IntValue);
	static void SetRotator(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const struct FRotator& RotatorValue);
	static void SetString(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const class FString& StringValue);
	static void SetText(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const class FText& TextValue);
	static void SetVector(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const struct FVector& VectorValue);
	static void SetVector2D(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const struct FVector2D& Vector2DValue);
	static void SetVector4(EConfigIniFileNames ConfigFile, const class FString& SectionName, const class FString& PropertyName, const struct FVector4& Vector4Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_ConfigFuncLib">();
	}
	static class UGSE_ConfigFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_ConfigFuncLib>();
	}
};
//static_assert(alignof(UGSE_ConfigFuncLib) == 0x000008, "Wrong alignment on UGSE_ConfigFuncLib");
//static_assert(sizeof(UGSE_ConfigFuncLib) == 0x000028, "Wrong size on UGSE_ConfigFuncLib");

// Class UnrealExtent.GSE_CppExport
// 0x0000 (0x0028 - 0x0028)
class UGSE_CppExport final : public UBlueprintFunctionLibrary
{
public:
	static TMap<class FString, struct FIntPtr> GetActorFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetAIFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetAnimFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetAsyncLineTraceReqFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetCVarFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetGameplayTagFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetGSCVarFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetInputFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetLineTraceFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetMathFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetNiagaraFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetProfilerFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetRenderFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetSceneComponentFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetSplineComponentFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetTaskGraphFuncAsMap();
	static TMap<class FString, struct FIntPtr> GetUMGFuncAsMap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_CppExport">();
	}
	static class UGSE_CppExport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_CppExport>();
	}
};
//static_assert(alignof(UGSE_CppExport) == 0x000008, "Wrong alignment on UGSE_CppExport");
//static_assert(sizeof(UGSE_CppExport) == 0x000028, "Wrong size on UGSE_CppExport");

// Class UnrealExtent.GSE_EditorFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_EditorFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class UObject* AssetPath_GetCDO(class UObject* Outer_0, const class FString& Path, class UBlueprint** Blueprint);
	static class UStaticMeshComponent* BGUGetStaticMeshComp(class AActor* Actor);
	static void BGULandscapeCameraCollsion(class UObject* WorldContextObject, int32 SurfaceType, float CellSize, float MaxHeightOffset, float MaxDisplacement, float CameraCollisionOffset);
	static void CheckActorBoundsInfo(class AActor* InActor, bool bIncludeNonCollision, bool* OutActorLevelBoundsRelevant, struct FBox* OutActorBounds);
	static void CompileText();
	static class UObject* FAssetData_GetAsset(class UAssetDataArray* AssetData);
	static class UClass* FAssetData_GetClass(class UAssetDataArray* AssetData);
	static class FString FAssetData_GetTagValue(class UAssetDataArray* AssetData, const class FName& TagName);
	static void GatherText();
	static struct FBoxSphereBounds GetBrushBounds(class UBrushComponent* BrushCom);
	static TArray<class UActorComponent*> GetCDONodeComponents(class AActor* CDO);
	static class UAssetDataArray* GetContentBrowserSelections();
	static TArray<class APostProcessVolume*> GetValidPostProcessVolumes(class UWorld* InWorld);
	static void ImportCSVToStringTable(class FName TableId, const class FString& CSVPath);
	static bool IsClassPlaceable(class UClass* AssetClass);
	static void SetActorEditorOnly(class AActor* Actor, bool NewEnable);
	static void SetActorLevelBoundsRelevant(class AActor* InActor, bool bRelevant);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_EditorFuncLib">();
	}
	static class UGSE_EditorFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_EditorFuncLib>();
	}
};
//static_assert(alignof(UGSE_EditorFuncLib) == 0x000008, "Wrong alignment on UGSE_EditorFuncLib");
//static_assert(sizeof(UGSE_EditorFuncLib) == 0x000028, "Wrong size on UGSE_EditorFuncLib");

// Class UnrealExtent.ActorComponentCS
// 0x0000 (0x00B0 - 0x00B0)
class UActorComponentCS : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorComponentCS">();
	}
	static class UActorComponentCS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorComponentCS>();
	}
};
//static_assert(alignof(UActorComponentCS) == 0x000008, "Wrong alignment on UActorComponentCS");
//static_assert(sizeof(UActorComponentCS) == 0x0000B0, "Wrong size on UActorComponentCS");

// Class UnrealExtent.GSE_EngineFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_EngineFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void AdjustPSOPrecompileBatch(int32 BatchSize, float BatchTime);
	static class UAsyncTaskDownloadImage* AsyncDownloadImage(const class FString& URL);
	static bool BindAudioUtilAndBox(class AActor* AudioUtilActor, class UUserWidget* AudioBox);
	static bool BinkMediaPlayerGoTo(class UBinkMediaPlayer* MediaPlayer, int32 TargetFrame);
	static bool BinkMediaPlayerGoToWithProcMs(class UBinkMediaPlayer* MediaPlayer, int32 TargetFrame, int32 ProcMS);
	static void BinkMediaPlayerTimeSeek(class UBinkMediaPlayer* MediaPlayer, double Time);
	static void BlockTillLevelStreamingCompleted(const class UObject* WorldContextObject);
	static void BlockTillSuspendedLevelsCompleted(const class UObject* WorldContextObject);
	static void CaptureCurrentViewport(bool bCapture);
	static void ClientSeamlessTravel(class APlayerController* PC, const class FString& URL);
	static void CloseNetConnection(class UObject* WorldContext);
	static int32 ConsoleVarGetInt(const class FString& Name_0);
	static void ConsoleVariableSetMouseCursor(bool MouseCursor);
	static void CopyToClipBoard(const class FString& InStr);
	static class UObject* CreateAsset(const class FString& Path, const class FString& Name_0, class UClass* CreatedClass);
	static class UDragDropOperation* CreateDragDropOperation(TSubclassOf<class UDragDropOperation> OperationClass);
	static void CreateNamedNetDriver(class UWorld* InWorld, class FName NetDriverName, class FName NetDriverDefinition);
	static class UReplicationDriver* CreateReplicationDriver(class UNetDriver* NetDriver, class UWorld* World);
	static void DelayGC();
	static void DestroyActor(class AActor* Actor);
	static void DestroyActorsWithSpecifiedKeyword(const class UObject* InWorldContext, const class FString& InKeyword);
	static struct FEventReply DetectDragIfPressed(const struct FPointerEvent& PointerEvent, class UWidget* WidgetDetectingDrag, const class FName& KeyName);
	static void DisableDebugExecBindings(class UObject* WorldCtx, bool IsDisable);
	static void DrawDebugCircleArc(const class UObject* WorldContextObject, const struct FVector& Center, float Radius, const struct FVector& Direction, float AngleWidth, int32 NumSegments, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static class UObject* DuplicateAsset(const class FString& AssetName, const class FString& PackagePath, class UObject* OriginalObject);
	static void EnableForceStreamdOutLevelGCCheck(bool Enable, bool IgnoreEditor);
	static void EngineGC(bool bFullPurge);
	static void ExecCmdOutGLog(const class FString& Cmd, class UObject* WorldCtx);
	static class FString FindAndPrintStaleReferencesToObject(class UObject* Obj);
	static class FString FindAndPrintStaleRefsByObjectPath(const class FString& InObjectPath);
	static class UNetDriver* FindNamedNetDriver(const class UWorld* InWorld, class FName NetDriverName);
	static TArray<struct FVector> FindPathSync(class AController* Controller, const struct FVector& TargetLocation);
	static void FlushMainAudioDevice(const int32 DeviceID);
	static bool GameInstanceIsDedicatedServer(const class UGameInstance* GameInst);
	static TArray<struct FInputActionKeyMapping> GetActionMappings(class APlayerController* PlayerController);
	static EGSQualityLevel GetActualQualityLevel(bool bLogInfo);
	static const struct FKey GetAnalogInputKey(const struct FAnalogInputEvent& AnalogInputEvent);
	static float GetAnalogValue(const struct FAnalogInputEvent& AnalogInputEvent);
	static float GetAsyncLoadPercentage(const class FName& PackageName);
	static class UAudioComponent* GetAudioInfoOfAudioVisualize(class AActor* AudioUtilActor, float* AudioDuration);
	static float GetAvailablePhysical();
	static TArray<struct FInputAxisKeyMapping> GetAxisMappings(class APlayerController* PlayerController);
	static int32 GetBinkMediaPlayerCurFrame(const class UBinkMediaPlayer* MediaPlayer);
	static double GetBinkMediaPlayerDuartion(const class UBinkMediaPlayer* MediaPlayer);
	static float GetBinkMediaPlayerFrameRate(const class UBinkMediaPlayer* MediaPlayer);
	static double GetBinkMediaPlayerTime(const class UBinkMediaPlayer* MediaPlayer);
	static int32 GetBinkMediaPlayerTotalFrames(const class UBinkMediaPlayer* MediaPlayer);
	static TArray<class AActor*> GetChildActors(class AActor* Actor);
	static class FString GetCurrentRhiName();
	static class FString GetDefaultLanguageCS();
	static class FString GetDeviceId();
	static void GetDeviceInfo(class FString* Cpu, class FString* Gpu, int32* MemSize);
	static float GetDisplayGamma(const class UObject* WorldCtx);
	static class FString GetDisplayName(const class UObject* Object);
	static int32 GetEngineMinorVersion();
	static class APlayerController* GetFirstLocalPlayerController(class UObject* WorldCtx);
	static int64 GetGFrameCounter();
	static float GetInputDeadZone(class APlayerController* PlayerController, const class FName& AxisName);
	static const struct FKey GetInputKey(const struct FKeyEvent& KeyEvent);
	static class FString GetLaunchValue(const class FString& Option);
	static class APlayerCameraManager* GetLocalPlayerCameraManager(class UObject* WorldCtx);
	static class FString GetLoginId();
	static TArray<uint8> GetMacAddress();
	static double GetMediaPlayerDuartion(const class UMediaPlayer* MediaPlayer);
	static double GetMediaPlayerTime(const class UMediaPlayer* MediaPlayer);
	static int32 GetPawnAutoPossessConfig(class APawn* PC);
	static double GetPlatformTime();
	static struct FMatrix GetPlayerViewProjectionMatrix(class APlayerController* Player);
	static struct FMatrix GetPlayerViewProjectionMatrixInv(class APlayerController* Player);
	static void GetPlayerViewRect(class APlayerController* Player, struct FVector2D* OutConstrainedViewRectMin, struct FVector2D* OutConstrainedViewRectMax, struct FVector2D* OutViewRectMin, struct FVector2D* OutViewRectMax);
	static void GetPlayerViewRectMatrixInfo(class APlayerController* Player, struct FMatrix* ViewProjectionMatrixInv, struct FVector2D* OutConstrainedViewRectMin, struct FVector2D* OutConstrainedViewRectMax, struct FVector2D* OutViewRectMin, struct FVector2D* OutViewRectMax);
	static class FString GetProjectDir();
	static TSubclassOf<class AGameModeBase> GetProjectSettingDefaultGameMode();
	static EGSQualityLevel GetRecommendedQualityLevel(bool bLogInfo);
	static void GetRegexMatchInfo(const class FString& InStr, const class FString& RegexExpression, TArray<class FString>* ExtractedInfo);
	static int32 GetRemainingPsoPrecompileNum();
	static int32 GetShadowQualityLevel();
	static struct FTimespan GetTimeSpanFromSeconds(double Seconds);
	static int32 GetTotalPsoPrecompileNum();
	static class UPackage* GetTransientPackage();
	static TArray<class FString> GetWarningPhysicsAssetList(class UObject* WorldContext, const class FString& TraverseRootPath);
	static TArray<class FString> GetWarningUITexList(class UObject* WorldContext, const class FString& TraverseRootPath, const class FString& SourceFileCommPath, const TArray<class FString>& ExcludedPathList);
	static struct FVector2D GetWindowScreenResolution();
	static class UWorld* GetWorldFromObj(class UObject* Context);
	static int32 GetWorldMainAudioDeviceID(const class UObject* WorldContextObject);
	static void GSSaveConfig(class UObject* WorldContext);
	static bool HasLaunchOption(const class FString& Option);
	static bool HasValidCaptureData(class UReflectionCaptureComponent* Component);
	static bool IsClient(class UWorld* World);
	static bool IsCommandLineHasParam(const class FString& QueryParam);
	static bool IsControllerInPlayState(class AController* Controller);
	static bool IsDedicateServer(class UWorld* World);
	static bool IsDevelopmentBuild();
	static bool IsDriverVersionMismatch();
	static bool IsEditor();
	static bool IsListenServer(class UWorld* World);
	static bool IsPSOBatchingPaused();
	static bool IsRegexMatched(const class FString& InStr, const class FString& RegexExpression);
	static bool IsSavePSOCacheInErrorState();
	static bool IsShippingBuild();
	static bool IsStandAlone(class UWorld* World);
	static bool IsStandaloneGame();
	static bool IsTestBuild();
	static bool IsUnloadPSOFinished();
	static class FString LoadFileToString(const class FString& Path);
	static void LogDbg(const class FString& Str, bool bPrintScreen, float TimeToDisplay);
	static void LogDbgWithColor(const class FString& Str, bool bPrintScreen, float TimeToDisplay, const struct FColor& Color, int32 Key);
	static void LogError(const class FString& Str);
	static void LogInfo(const class FString& Str);
	static void LogShipping(const class FString& Str);
	static void LogShippingError(const class FString& Str);
	static void LogWarning(const class FString& Str);
	static void LogWLevel(const class FString& Str, int32 InLogLevel);
	static void MarkUnloadPsoState();
	static float MathEase(float A, float B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps);
	static struct FVector2D MathEase2D(const struct FVector2D& A, const struct FVector2D& B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps);
	static struct FLinearColor MathEaseLinearColor(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps);
	static struct FRotator MathEaseR(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath, EEasingFunc EasingFunc, float BlendExp, int32 Steps);
	static struct FVector MathEaseV(const struct FVector& A, const struct FVector& B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps);
	static void MediaPlayerTimeSeek(class UMediaPlayer* MediaPlayer, double Time);
	static struct FLinearColor MultipleColorLerp(const struct FLinearColor& V1, const struct FLinearColor& V2, const struct FLinearColor& V3, const struct FLinearColor& V4, float LerpAlpha);
	static void PauseAudio(class AActor* AudioUtilActor);
	static void PausePsoBatching();
	static void PerfTest(int32 CaseID, int32 Count);
	static void PlayAudio(class AActor* AudioUtilActor, bool VisualOnly);
	static void PrepareLevelsNeedToBeUnloaded(const class UObject* WorldContextObject);
	static void PSOFullCompilation();
	static void QAGenCrash();
	static void QAGetSimpleCollisionCylinder(class AActor* AgentActor, float* CollisionRadius, float* CollisionHalfHeight);
	static bool QAHasReached(class AActor* AgentActor, class AActor* GoalActor);
	static bool QAIsCompiling();
	static void QuitEditor();
	static void QuitGame(class UObject* WorldCtx);
	static void RegisteConsoleKey(const TArray<class FName>& Keys);
	static void RegisterComponent(class UActorComponent* ActorComponent);
	static void ReplaceInputActionList(class APlayerController* PlayerController, const TArray<struct FGSInputActionKeyMapping>& ActionMappings);
	static void ReplaceInputAxisList(class APlayerController* PlayerController, const TArray<struct FGSInputAxisKeyMapping>& AxisMappings);
	static void RequestExit(bool Force);
	static void RequestQuit(const class FString& Desc);
	static void ResetAudioVisualizing(class UUserWidget* AudioBox);
	static void RestartApplication();
	static void RestartGame(class AGameMode* GameMode);
	static void ResumePsoBatching();
	static void RunProcess(const class FString& InProcessPath);
	static void RunProcessWithCheck(const class FString& InProcessPath);
	static void SavePSOCacheFile();
	static void SaveStringToFile(const class FString& Path, const class FString& Data);
	static void ServerSeamlessTravel(class UWorld* World, const class FString& URL);
	static void SetActorComponentMobilityMovable(class AActor* Actor, bool IsMovable);
	static void SetAudioBoxFreqNum(class UUserWidget* AudioBox, const int32 InFreqNum);
	static bool SetCanEverTick(class UObject* Obj, bool bEnable);
	static void SetDesiredQualityLevel(EGSQualityLevel TargetGSQualityLevel);
	static void SetDisplayGamma(const class UObject* WorldCtx, float Gamma);
	static void SetInputDeadZone(class APlayerController* PlayerController, const class FName& AxisName, float DeadZone);
	static void SetInputModeGameOnly(class APlayerController* PlayerController);
	static void SetInputModeUIOnly(class APlayerController* Target, class UWidget* InWidgetToFocus, EMouseLockMode InMouseLockMode);
	static void SetLevelRequestSuspend(bool ShouldSuspend);
	static void SetLogEnable(bool bEnableDbg, bool bEnableDbgDisplay, bool bEnableInfo);
	static void SetMouseCursorWidgetVisible(class APlayerController* PlayerController, bool bVisible);
	static void SetPSOCacheUsageMask(int32 MapIndex, int32 MaterialQualityLevel, int32 NiagaraQualityLevel, int32 ShadowQualityLevel);
	static void StopAudio(class AActor* AudioUtilActor);
	static bool TestPathSync(class AController* Controller, const struct FVector& TargetLocation);
	static float ToMilliseconds(const int64 Cycles);
	static void UpdateAudioUtilAnalyzer(class AActor* AudioUtilActor, const class FString& LoudnessAnalyzerAssetPath, const class FString& ConstantAnalyzerAssetPath);
	static void UploadPSOHttpRequest(int32 Num);
	static bool UseStatsMacro();
	static void VLogBoxError(const class UObject* WorldContext, const class FName& Catogary, const struct FBox& Box, const struct FColor& Color, const class FString& Text);
	static void VLogBoxInfo(const class UObject* WorldContext, const class FName& Catogary, const struct FBox& Box, const struct FColor& Color, const class FString& Text);
	static void VLogBoxWarning(const class UObject* WorldContext, const class FName& Catogary, const struct FBox& Box, const struct FColor& Color, const class FString& Text);
	static void VLogError(const class UObject* WorldContext, const class FName& Catogary, const class FString& Text);
	static void VLogInfo(const class UObject* WorldContext, const class FName& Catogary, const class FString& Text);
	static void VLogLocationError(const class UObject* WorldContext, const class FName& Catogary, const struct FVector& Location, float Radius, const struct FColor& Color, const class FString& Text);
	static void VLogLocationInfo(const class UObject* WorldContext, const class FName& Catogary, const struct FVector& Location, float Radius, const struct FColor& Color, const class FString& Text);
	static void VLogLocationWarning(const class UObject* WorldContext, const class FName& Catogary, const struct FVector& Location, float Radius, const struct FColor& Color, const class FString& Text);
	static void VLogSegmentError(const class UObject* WorldContext, const class FName& Catogary, const struct FVector& SegmentStart, const struct FVector& SegmentEnd, const struct FColor& Color, float Thickness, const class FString& Text);
	static void VLogSegmentInfo(const class UObject* WorldContext, const class FName& Catogary, const struct FVector& SegmentStart, const struct FVector& SegmentEnd, const struct FColor& Color, float Thickness, const class FString& Text);
	static void VLogSegmentWarning(const class UObject* WorldContext, const class FName& Catogary, const struct FVector& SegmentStart, const struct FVector& SegmentEnd, const struct FColor& Color, float Thickness, const class FString& Text);
	static void VLogWarning(const class UObject* WorldContext, const class FName& Catogary, const class FString& Text);
	static void VLogWLevel(const class UObject* WorldContext, int32 InLogLevel, const class FName& Catogary, const class FString& Text);
	static bool WasActorRecentlyRendered(class AActor* InActor, const float InTolerence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_EngineFuncLib">();
	}
	static class UGSE_EngineFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_EngineFuncLib>();
	}
};
//static_assert(alignof(UGSE_EngineFuncLib) == 0x000008, "Wrong alignment on UGSE_EngineFuncLib");
//static_assert(sizeof(UGSE_EngineFuncLib) == 0x000028, "Wrong size on UGSE_EngineFuncLib");

// Class UnrealExtent.GSE_WorldFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_WorldFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class AWorldSettings* GetWorldSettings(class ULevel* Level, bool bChecked);
	static void NotifyWorldSettingsBeginPlay(class UWorld* World);
	static void NotifyWorldSettingsMatchStart(class UWorld* World);
	static class ULevel* WorldGetCurrentLevel(class UWorld* World);
	static class ULevel* WorldGetPersistentLevel(class UWorld* World);
	static bool WorldViewportCursorVisible(class UWorld* World);
	static bool WorldViewportForeground(class UWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_WorldFuncLib">();
	}
	static class UGSE_WorldFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_WorldFuncLib>();
	}
};
//static_assert(alignof(UGSE_WorldFuncLib) == 0x000008, "Wrong alignment on UGSE_WorldFuncLib");
//static_assert(sizeof(UGSE_WorldFuncLib) == 0x000028, "Wrong size on UGSE_WorldFuncLib");

// Class UnrealExtent.GSE_FoliageFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_FoliageFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class FString IFA_GetSelectedInstanceName(class AInstancedFoliageActor* FoliageActor);
	static void InstancedFoliageActorSetCullDistance(class AInstancedFoliageActor* FoliageActor, int32 MinLodDist, int32 MaxLodDist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_FoliageFuncLib">();
	}
	static class UGSE_FoliageFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_FoliageFuncLib>();
	}
};
//static_assert(alignof(UGSE_FoliageFuncLib) == 0x000008, "Wrong alignment on UGSE_FoliageFuncLib");
//static_assert(sizeof(UGSE_FoliageFuncLib) == 0x000028, "Wrong size on UGSE_FoliageFuncLib");

// Class UnrealExtent.GSE_ProfilerFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_ProfilerFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FGSCapturedStatResult> CaptureAllStatsInfo();
	static TArray<struct FGSCapturedStatResult> CaptureSpecificStatsInfo(const TArray<class FString>& StatNames);
	static void GSStatsMasterEnableAdd();
	static void StartRecordingPerfChart(const class FString& TargetFileName, int32 InTotalFrames, bool bCollectInsightData);
	static void StopRecordingPerfChart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_ProfilerFuncLib">();
	}
	static class UGSE_ProfilerFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_ProfilerFuncLib>();
	}
};
//static_assert(alignof(UGSE_ProfilerFuncLib) == 0x000008, "Wrong alignment on UGSE_ProfilerFuncLib");
//static_assert(sizeof(UGSE_ProfilerFuncLib) == 0x000028, "Wrong size on UGSE_ProfilerFuncLib");

// Class UnrealExtent.GSE_PostProcessFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_PostProcessFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static struct FPostProcessSettings GetSceneViewFinalPostProcessSettings(class AActor* WorldContext);
	static void RemovePPCompWeightBlendable(class UPostProcessComponent* PPComp, class UMaterialInterface* PPMaterialInterface);
	static void RemovePPVWeightBlendable(class APostProcessVolume* PPV, class UMaterialInterface* PPMaterialInterface);
	static void SetCameraCompWeightedBlendableWeightByIndex(class UCameraComponent* CameraComp, int32 PPMatIndex, float Weight);
	static void SetCameraWeightedBlendableWeightByIndex(class AActor* CameraActor, int32 PPMatIndex, float Weight);
	static void SetPPCompWeightedBlendableWeight(class UPostProcessComponent* PPComp, class UMaterialInterface* PPMaterialInterface, float Weight);
	static void SetPPCompWeightedBlendableWeightByIndex(class UPostProcessComponent* PPComp, int32 PPMatIndex, float Weight);
	static void SetPPVWeightedBlendableWeight(class APostProcessVolume* PPV, class UMaterialInterface* PPMaterialInterface, float Weight);
	static void SetPPVWeightedBlendableWeightByIndex(class APostProcessVolume* PPV, int32 PPMatIndex, float Weight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_PostProcessFuncLib">();
	}
	static class UGSE_PostProcessFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_PostProcessFuncLib>();
	}
};
//static_assert(alignof(UGSE_PostProcessFuncLib) == 0x000008, "Wrong alignment on UGSE_PostProcessFuncLib");
//static_assert(sizeof(UGSE_PostProcessFuncLib) == 0x000028, "Wrong size on UGSE_PostProcessFuncLib");

// Class UnrealExtent.GSE_CameraUtilFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_CameraUtilFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void GetCameraFocalParams(class UCameraComponent* InCamera, float* OutFocalDistance, float* OutDepthBlurKm, float* OutDepthBlurRadius);
	static class AActor* GetCameraViewTarget(class APlayerCameraManager* CameraManager);
	static bool IsPositionInScreenViewport(class UObject* WorldContext, const struct FVector& Position);
	static void SetCameraFocalParams(class UCameraComponent* InCamera, float InFocalDistance, float InDepthBlurKm, float DepthBlurRadius);
	static bool SetLocalPlayerAspectRatioAxisConstraint(class APlayerController* PlayerController, EAspectRatioAxisConstraint TargetAspectRatioAxisConstraint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_CameraUtilFuncLib">();
	}
	static class UGSE_CameraUtilFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_CameraUtilFuncLib>();
	}
};
//static_assert(alignof(UGSE_CameraUtilFuncLib) == 0x000008, "Wrong alignment on UGSE_CameraUtilFuncLib");
//static_assert(sizeof(UGSE_CameraUtilFuncLib) == 0x000028, "Wrong size on UGSE_CameraUtilFuncLib");

// Class UnrealExtent.GSE_AssetUtilFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_AssetUtilFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class UObject* GetAssetDataAsset(class UAssetDataArray* AssetData);
	static class UClass* GetAssetDataClass(class UAssetDataArray* AssetData);
	static class UAssetDataArray* GetAssetDataFromPackageObj(const TArray<class UObject*>& PackageObjects);
	static class FString GetAssetDataTagValue(class UAssetDataArray* AssetData, const class FName& TagName);
	static class UAssetDataArray* GetAssetsByPath(const TArray<class FString>& Paths);
	static class UAssetDataArray* GetAssetsInFolder(class FName FolderPath, bool bRecursive, bool bIncludeOnlyOnDiskAssets);
	static class UAssetDataArray* GetDependenciesAssetsFromAssets(class UAssetDataArray* Assets);
	static class UAssetDataArray* GetReferenceAssetsFromAssets(class UAssetDataArray* Assets);
	static class UAssetDataArray* GetReferenceAssetsFromObjects(const TArray<class UObject*>& LoadedSourceAssets);
	static TArray<class UObject*> LoadObjectsFromAssetData(class UAssetDataArray* Assets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_AssetUtilFuncLib">();
	}
	static class UGSE_AssetUtilFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_AssetUtilFuncLib>();
	}
};
//static_assert(alignof(UGSE_AssetUtilFuncLib) == 0x000008, "Wrong alignment on UGSE_AssetUtilFuncLib");
//static_assert(sizeof(UGSE_AssetUtilFuncLib) == 0x000028, "Wrong size on UGSE_AssetUtilFuncLib");

// Class UnrealExtent.GSE_LoadingUtilFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_LoadingUtilFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void ClientSetBlockOnAsyncLoading(class APlayerController* PlayerController);
	static class UObject* SyncLoadObject(const class FString& Path);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_LoadingUtilFuncLib">();
	}
	static class UGSE_LoadingUtilFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_LoadingUtilFuncLib>();
	}
};
//static_assert(alignof(UGSE_LoadingUtilFuncLib) == 0x000008, "Wrong alignment on UGSE_LoadingUtilFuncLib");
//static_assert(sizeof(UGSE_LoadingUtilFuncLib) == 0x000028, "Wrong size on UGSE_LoadingUtilFuncLib");

// Class UnrealExtent.GSE_OnlineSocketFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_OnlineSocketFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetLocalListenIp(class UObject* WorldContext);
	static int32 GetLocalListenPort(class UObject* WorldContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_OnlineSocketFuncLib">();
	}
	static class UGSE_OnlineSocketFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_OnlineSocketFuncLib>();
	}
};
//static_assert(alignof(UGSE_OnlineSocketFuncLib) == 0x000008, "Wrong alignment on UGSE_OnlineSocketFuncLib");
//static_assert(sizeof(UGSE_OnlineSocketFuncLib) == 0x000028, "Wrong size on UGSE_OnlineSocketFuncLib");

// Class UnrealExtent.GSE_TraceFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_TraceFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool CharacterCapsuleTraceSingleByProfile(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, class FName ProfileName, bool bTraceComplex, class AActor* IgnoreActor, struct FVector* OutHitLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_TraceFuncLib">();
	}
	static class UGSE_TraceFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_TraceFuncLib>();
	}
};
//static_assert(alignof(UGSE_TraceFuncLib) == 0x000008, "Wrong alignment on UGSE_TraceFuncLib");
//static_assert(sizeof(UGSE_TraceFuncLib) == 0x000028, "Wrong size on UGSE_TraceFuncLib");

// Class UnrealExtent.GSE_OverlapFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_OverlapFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool BoxOverlapActorsByProfile(const class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, class FName ProfileName, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool BoxOverlapComponentsByProfile(const class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, class FName ProfileName, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_OverlapFuncLib">();
	}
	static class UGSE_OverlapFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_OverlapFuncLib>();
	}
};
//static_assert(alignof(UGSE_OverlapFuncLib) == 0x000008, "Wrong alignment on UGSE_OverlapFuncLib");
//static_assert(sizeof(UGSE_OverlapFuncLib) == 0x000028, "Wrong size on UGSE_OverlapFuncLib");

// Class UnrealExtent.GSE_FileFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_FileFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool AndroidExtractFolderFromApk(const class FString& SrcPath, const class FString& DestPath);
	static bool AndroidHasFileInApk(const class FString& SrcPath);
	static bool ExtractDirToPath(const class FString& Src, const class FString& Dest);
	static bool ExtractFileToPath(const class FString& Src, const class FString& Dest);
	static bool FindFiles(const class FString& Directory, TArray<class FString>* FoundFiles, const class FString& FileExtension);
	static bool FindFilesRecursively(const class FString& Directory, TArray<class FString>* FoundFiles, const class FString& FileExtension);
	static bool LoadFileToArray(const class FString& Path, TArray<uint8>* FileData);
	static bool MountAllPakFiles(const TArray<class FString>& PakFolders);
	static bool MountPak(const class FString& InPakFilename, int32 PakOrder);
	static bool MountPakWithInPath(const class FString& InPakFilename, int32 PakOrder, const class FString& InPath);
	static bool ReadFile(const class FString& Path, TArray<uint8>* BytesToRead);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_FileFuncLib">();
	}
	static class UGSE_FileFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_FileFuncLib>();
	}
};
//static_assert(alignof(UGSE_FileFuncLib) == 0x000008, "Wrong alignment on UGSE_FileFuncLib");
//static_assert(sizeof(UGSE_FileFuncLib) == 0x000028, "Wrong size on UGSE_FileFuncLib");

// Class UnrealExtent.GSE_GamePresetsFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_GamePresetsFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool GetPlatformGamePresets(struct FGamePresets* GamePresets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_GamePresetsFuncLib">();
	}
	static class UGSE_GamePresetsFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_GamePresetsFuncLib>();
	}
};
//static_assert(alignof(UGSE_GamePresetsFuncLib) == 0x000008, "Wrong alignment on UGSE_GamePresetsFuncLib");
//static_assert(sizeof(UGSE_GamePresetsFuncLib) == 0x000028, "Wrong size on UGSE_GamePresetsFuncLib");

// Class UnrealExtent.GSE_GSGameSettingsFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_GSGameSettingsFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyGSGameResolutionSettings(bool bSaveSettings);
	static void ApplyGSGameSettings(bool bSaveSettings);
	static int32 GetCurGameMainScreen();
	static class FString GetDefaultLanguage();
	static bool GetGRHISupportsRayTracing();
	static bool GetIsHDRViewport(class UWorld* World);
	static class FString GetMainMonitorID();
	static class FString GetRHIAdapterName();
	static bool IsLowFeatureLevelGPU();
	static void SetRayTracingQuality(int32 RTXLevel);
	static void SetXeSSPercentage(float Percentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_GSGameSettingsFuncLib">();
	}
	static class UGSE_GSGameSettingsFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_GSGameSettingsFuncLib>();
	}
};
//static_assert(alignof(UGSE_GSGameSettingsFuncLib) == 0x000008, "Wrong alignment on UGSE_GSGameSettingsFuncLib");
//static_assert(sizeof(UGSE_GSGameSettingsFuncLib) == 0x000028, "Wrong size on UGSE_GSGameSettingsFuncLib");

// Class UnrealExtent.GSE_LandscapeFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_LandscapeFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void AddLocationsToStreamingManager(const TArray<struct FVector>& Locations, float Duration);
	static struct FVector GetLandscapeOriginOffset(class AActor* LandscapeActor);
	static void RecreateLandscapeActorByProxy(class AActor* LandscapeProxy);
	static class UTexture2D* SaveLandscapeLayerWeightTex(const class FString& PackagePath, const class FString& AssetName, class AActor* LandscapeActor, const class FString& LayerName);
	static struct FVector SaveLandscapeWeight(const class FString& PackagePath, class AActor* LandscapeActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_LandscapeFuncLib">();
	}
	static class UGSE_LandscapeFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_LandscapeFuncLib>();
	}
};
//static_assert(alignof(UGSE_LandscapeFuncLib) == 0x000008, "Wrong alignment on UGSE_LandscapeFuncLib");
//static_assert(sizeof(UGSE_LandscapeFuncLib) == 0x000028, "Wrong size on UGSE_LandscapeFuncLib");

// Class UnrealExtent.GSE_NavigationFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_NavigationFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void SetCollisionNavAreaClass(class UShapeComponent* Collision, TSubclassOf<class UNavAreaBase> AreaClass);
	static void SetCollisionNavDynamicObstacle(class UShapeComponent* Collision, bool bDynamicObstacle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_NavigationFuncLib">();
	}
	static class UGSE_NavigationFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_NavigationFuncLib>();
	}
};
//static_assert(alignof(UGSE_NavigationFuncLib) == 0x000008, "Wrong alignment on UGSE_NavigationFuncLib");
//static_assert(sizeof(UGSE_NavigationFuncLib) == 0x000028, "Wrong size on UGSE_NavigationFuncLib");

// Class UnrealExtent.GSE_NiagaraFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_NiagaraFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void ForceDestroyNiagaraComponent(class UNiagaraComponent* NC);
	static ENCPoolMethod GetNiagaraComponentPoolMethod(class UNiagaraComponent* NC);
	static void SetEffectTypeManagerState(EEffectTypeManagerCullMode NewMode);
	static void SetTextureParameterValueOnMeshRenderMaterials(class UNiagaraComponent* NiagaraComponent, const class FName& ParameterName, class UTexture* ParameterValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_NiagaraFuncLib">();
	}
	static class UGSE_NiagaraFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_NiagaraFuncLib>();
	}
};
//static_assert(alignof(UGSE_NiagaraFuncLib) == 0x000008, "Wrong alignment on UGSE_NiagaraFuncLib");
//static_assert(sizeof(UGSE_NiagaraFuncLib) == 0x000028, "Wrong size on UGSE_NiagaraFuncLib");

// Class UnrealExtent.GSE_SaveGameFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_SaveGameFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FString> GetAllSaveGameSlotNames();
	static bool LoadDataFromSlot(TArray<uint8>* OutSaveData, const class FString& SlotName, const int32 UserIndex);
	static bool SaveDataToSlot(const TArray<uint8>& InSaveData, const class FString& SlotName, const int32 UserIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SaveGameFuncLib">();
	}
	static class UGSE_SaveGameFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_SaveGameFuncLib>();
	}
};
//static_assert(alignof(UGSE_SaveGameFuncLib) == 0x000008, "Wrong alignment on UGSE_SaveGameFuncLib");
//static_assert(sizeof(UGSE_SaveGameFuncLib) == 0x000028, "Wrong size on UGSE_SaveGameFuncLib");

// Class UnrealExtent.HttpResposeListener
// 0x0008 (0x0030 - 0x0028)
class UHttpResposeListener : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReponseComplete(bool bSuccess, int32 HttpCode, const TArray<uint8>& Content);
	void OnRequestProgress(int32 SentBytes, int32 LReceivedBytes, int32 LTotalBytes);

	bool IsNeedProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HttpResposeListener">();
	}
	static class UHttpResposeListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHttpResposeListener>();
	}
};
//static_assert(alignof(UHttpResposeListener) == 0x000008, "Wrong alignment on UHttpResposeListener");
//static_assert(sizeof(UHttpResposeListener) == 0x000030, "Wrong size on UHttpResposeListener");

// Class UnrealExtent.GSE_SDKFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_SDKFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool AddCrashUserData(const class FString& Key, const class FString& Value);
	static void FCommandLine_AddArg(const class FString& Command);
	static class FString FCommandLine_Get();
	static void GetGameRunEnvContext(TMap<class FString, class FString>* OutContext);
	static class FString GetIOSBundlePath();
	static class FString GetIOSDocumentPath();
	static EBGWNATType GetNatInfo();
	static class FString GetPS5UserAccountRegionCode();
	static int32 GetPS5UserDefinedParam(int32 Index_0);
	static bool HttpPostFile(const class FString& PostUrl, const TMap<class FString, class FString>& ExHeaders, const class FString& FilePath, class UHttpResposeListener* Listener);
	static bool HttpPostFileContent(const class FString& PostUrl, const TMap<class FString, class FString>& ExHeaders, const class FString& Filename, const TArray<uint8>& FileContentData, class UHttpResposeListener* Listener);
	static bool HttpPostFileList(const class FString& PostUrl, const TMap<class FString, class FString>& ExHeaders, const TArray<class FString>& FilePathList, class UHttpResposeListener* Listener);
	static bool IsCleanVersion();
	static bool IsPureVersion();
	static int32 NonGameThreadStartHttpRawDataRequestWithBlockMode(const class FString& URL, const class FString& Method, const TMap<class FString, class FString>& ExHeaders, const TArray<uint8>& PostRawData, int32 RequestTimeout, TMap<class FString, class FString>* OutResponse);
	static bool PostException(int32 Type, const class FString& Name_0, const class FString& Message, const class FString& StackTrace);
	static bool PostExceptionSample(const class FString& Message);
	static void PrintCachedEntitlements();
	static void SentryCrashReporterSetContext(const class FString& Key, const TMap<class FString, class FString>& ContextValues);
	static void SentryCrashReporterSetRoot(const class FString& RootKey, const class FString& RootValue);
	static void SentryCrashReporterSetTag(const class FString& Key, const class FString& Value);
	static void SentryCrashReporterSetUser(const class FString& UserKey, const class FString& UserValue);
	static void SetAppIsAutoTestingMode(int32 bEnable);
	static bool SetBuglyUserMap(const class FString& Key, const class FString& Value);
	static void SetCrashReportClientEnable(int32 bEnable);
	static bool StartHttpBase64DataRequest(const class FString& URL, const class FString& Method, const TMap<class FString, class FString>& ExHeaders, const class FString& Base64PostData, class UHttpResposeListener* Listener, int32 RequestTimeout);
	static bool StartHttpRawDataRequest(const class FString& URL, const class FString& Method, const TMap<class FString, class FString>& ExHeaders, const TArray<uint8>& PostRawData, class UHttpResposeListener* Listener, int32 RequestTimeout);
	static bool TestCallAndroidFunc(const class FString& Content);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SDKFuncLib">();
	}
	static class UGSE_SDKFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_SDKFuncLib>();
	}
};
//static_assert(alignof(UGSE_SDKFuncLib) == 0x000008, "Wrong alignment on UGSE_SDKFuncLib");
//static_assert(sizeof(UGSE_SDKFuncLib) == 0x000028, "Wrong size on UGSE_SDKFuncLib");

// Class UnrealExtent.GSE_SequencerFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_SequencerFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static float FQualifiedTimeAsSeconds(const struct FQualifiedFrameTime& FrameTime);
	static struct FMovieSceneObjectBindingID GetLevelSequenceBindingIDByDisplayName(class ULevelSequence* LevelSequence, const class FName& TargetName);
	static struct FMovieSceneObjectBindingID GetLevelSequenceBindingIDByName(class ULevelSequence* LevelSequence, const class FName& TargetName);
	static struct FSequenceBindingIDInCS GetLevelSequenceBindingIDByNameCS(class ULevelSequence* LevelSequence, const class FName& TargetName);
	static bool IsMovieSceneObjectBindingIDValidCS(const struct FSequenceBindingIDInCS& BindID);
	static void LevelSequenceBindPossessableObjectCS(class ULevelSequence* LevelSequence, const struct FSequenceBindingIDInCS& BindingID, class UObject* BindObj, class UObject* Ctx);
	static void LevelSequenceUnbindPossessableObjectCS(class ULevelSequence* LevelSequence, const struct FSequenceBindingIDInCS& BindingID);
	static void SequenceActorAddBindingCS(class ALevelSequenceActor* SeqActor, const struct FSequenceBindingIDInCS& BindingID, class AActor* Actor);
	static void SequenceActorInitPlayerCS(class ALevelSequenceActor* SeqActor, class ULevel* Lvl, class ULevelSequence* LevelSeq);
	static bool SequenceActorSetBindingByName(class ALevelSequenceActor* SequenceActor, const class FName& TargetName, const TArray<class AActor*>& Actors, bool bUseDisplayName);
	static int32 SequenceMasterAutoBind(class ALevelSequenceActor* SequenceActor, class AActor* MasterActor);
	static bool SequenceSetClockSource(class UMovieSceneSequencePlayer* SequencePlayer, EUpdateClockSource ClockSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SequencerFuncLib">();
	}
	static class UGSE_SequencerFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_SequencerFuncLib>();
	}
};
//static_assert(alignof(UGSE_SequencerFuncLib) == 0x000008, "Wrong alignment on UGSE_SequencerFuncLib");
//static_assert(sizeof(UGSE_SequencerFuncLib) == 0x000028, "Wrong size on UGSE_SequencerFuncLib");

// Class UnrealExtent.GSE_SkeletalMeshFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_SkeletalMeshFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void BakeSkinInfoToUVs(class USkeletalMesh* TargetSkeletalMesh);
	static class FName GetBodyInstanceCollisionProfileName(class USkeletalMeshComponent* SkMeshComp, class FName BoneName, bool bGetWelded);
	static ECollisionEnabled GetBodyInstanceShapeCollisionEnable(class USkeletalMeshComponent* SkMeshComp, class FName BoneName, int32 ShapeIndex, bool bGetWelded);
	static int32 GetLODSettingsGroupNum(class USkeletalMeshLODSettings* LODSettings);
	static int32 GetNumOverrideMaterials(const class USkeletalMeshComponent* SKComp);
	static struct FTransform GetRefPoseTransform(class USkinnedMeshComponent* MeshComp, int32 BoneIndex, bool bIsLocal);
	static bool GetUROResult(class AActor* OwnerActor, float* OutAccumulatedDeltaTime);
	static void GS_SetEndPhysicsTickEnabled(class USkeletalMeshComponent* SKComp, bool bVal);
	static bool IsCPUAccess(class USkeletalMesh* SKMesh);
	static void SetAllBodiesShapeCollisionEnabled(const class USkeletalMeshComponent* SKComp, ECollisionEnabled Type, bool bUpdateFilterData);
	static void SetBodyInstanceAutoWeld(class USkeletalMeshComponent* SkMeshComp, class FName BoneName, bool bAutoWeld, bool bGetWelded);
	static void SetBodyInstanceCollisionEnable(class USkeletalMeshComponent* SkMeshComp, class FName BoneName, ECollisionEnabled NewType, bool bUpdatePhysicsFilterData, bool bGetWelded);
	static void SetBodyInstanceCollisionProfileName(class USkeletalMeshComponent* SkMeshComp, class FName BoneName, class FName InCollisionProfileName, bool bGetWelded);
	static void SetBodyInstanceShapeCollisionEnable(class USkeletalMeshComponent* SkMeshComp, class FName BoneName, int32 ShapeIndex, ECollisionEnabled NewType, bool bUpdatePhysicsFilterData, bool bGetWelded);
	static void SetTextureParameterValueOnMaterials(class UMeshComponent* MeshComp, const class FName& ParameterName, class UTexture* ParameterValue);
	static void SetUpdateOverlapsOnAnimationFinalize(class USkeletalMeshComponent* SKComp, bool bVal);
	static void UpdateUROParams(class AActor* OwnerActor, const TArray<float>& BaseVisibleDistanceFactorThesholds, int32 BaseNonRenderedUpdateRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SkeletalMeshFuncLib">();
	}
	static class UGSE_SkeletalMeshFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_SkeletalMeshFuncLib>();
	}
};
//static_assert(alignof(UGSE_SkeletalMeshFuncLib) == 0x000008, "Wrong alignment on UGSE_SkeletalMeshFuncLib");
//static_assert(sizeof(UGSE_SkeletalMeshFuncLib) == 0x000028, "Wrong size on UGSE_SkeletalMeshFuncLib");

// Class UnrealExtent.GSE_StaticMeshFunLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_StaticMeshFunLib final : public UBlueprintFunctionLibrary
{
public:
	static ECollisionTraceFlag GetCollisionComplexity(class UStaticMesh* TargetStaticMesh);
	static int32 GetCollisionPremitiveNumbers(class UStaticMesh* TargetStaticMesh);
	static TArray<float> GetCustomPrimitiveData(class UStaticMeshComponent* StaticMeshComponent);
	static int32 GetStaticMeshMaterialNum(class UStaticMesh* TargetStaticMesh);
	static bool IsCPUAccess(class UStaticMesh* StaticMesh);
	static void SetCollisionComplexity(class UStaticMesh* TargetStaticMesh, ECollisionTraceFlag _CollisionTraceFlag);
	static void SetLinearColorParameterValueOnMaterials(class UMeshComponent* MeshComp, const class FName& ParamName, const struct FLinearColor& ParamValue);
	static void SetStaticMeshActorVisibility(class AStaticMeshActor* TargetActor, bool Visible, bool RecurseToChildActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_StaticMeshFunLib">();
	}
	static class UGSE_StaticMeshFunLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_StaticMeshFunLib>();
	}
};
//static_assert(alignof(UGSE_StaticMeshFunLib) == 0x000008, "Wrong alignment on UGSE_StaticMeshFunLib");
//static_assert(sizeof(UGSE_StaticMeshFunLib) == 0x000028, "Wrong size on UGSE_StaticMeshFunLib");

// Class UnrealExtent.GSE_SubsystemFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGSE_SubsystemFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UEngineSubsystem* GetEngineSubsystem(TSubclassOf<class UEngineSubsystem> Class_0);
	static class UGameInstanceSubsystem* GetGameInstanceSubsystem(class UObject* ContextObject, TSubclassOf<class UGameInstanceSubsystem> Class_0);
	static class ULocalPlayerSubsystem* GetLocalPlayerSubsystem(class UObject* ContextObject, TSubclassOf<class ULocalPlayerSubsystem> Class_0);
	static class ULocalPlayerSubsystem* GetLocalPlayerSubSystemFromPlayerController(class APlayerController* PlayerController, TSubclassOf<class ULocalPlayerSubsystem> Class_0);
	static class UWorldSubsystem* GetWorldSubsystem(class UObject* ContextObject, TSubclassOf<class UWorldSubsystem> Class_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SubsystemFunctionLibrary">();
	}
	static class UGSE_SubsystemFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_SubsystemFunctionLibrary>();
	}
};
//static_assert(alignof(UGSE_SubsystemFunctionLibrary) == 0x000008, "Wrong alignment on UGSE_SubsystemFunctionLibrary");
//static_assert(sizeof(UGSE_SubsystemFunctionLibrary) == 0x000028, "Wrong size on UGSE_SubsystemFunctionLibrary");

// Class UnrealExtent.GSE_SuperRSFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_SuperRSFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool GetDLSSLisFeatureSupported();
	static bool GetIsDX12();
	static bool GetIsXeSSSupported();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SuperRSFuncLib">();
	}
	static class UGSE_SuperRSFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_SuperRSFuncLib>();
	}
};
//static_assert(alignof(UGSE_SuperRSFuncLib) == 0x000008, "Wrong alignment on UGSE_SuperRSFuncLib");
//static_assert(sizeof(UGSE_SuperRSFuncLib) == 0x000028, "Wrong size on UGSE_SuperRSFuncLib");

// Class UnrealExtent.BenchmarkMonitorSubsystem
// 0x0028 (0x0058 - 0x0030)
class UBenchmarkMonitorSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BenchmarkMonitorSubsystem">();
	}
	static class UBenchmarkMonitorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBenchmarkMonitorSubsystem>();
	}
};
//static_assert(alignof(UBenchmarkMonitorSubsystem) == 0x000008, "Wrong alignment on UBenchmarkMonitorSubsystem");
//static_assert(sizeof(UBenchmarkMonitorSubsystem) == 0x000058, "Wrong size on UBenchmarkMonitorSubsystem");

// Class UnrealExtent.GSE_SystemSettingsFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_SystemSettingsFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void ApplySystemSettings(bool bSaveSettings);
	static void BGUBindOnCultureChangedEvent(class UObject* Obj, class FName FuncName);
	static void BGUBindOnMonitorAsPrimaryChange(class UObject* Obj, class FName FuncName);
	static void BGUBindOnViewportResizedEvent(class UObject* Obj, class FName FuncName);
	static void BGUUnBindOnCultureChangedEvent(class UObject* Obj, class FName FuncName);
	static void BGUUnBindOnMonitorAsPrimaryChange(class UObject* Obj, class FName FuncName);
	static void BGUUnBindOnViewportResizedEvent(class UObject* Obj, class FName FuncName);
	static class FString EngineSettingGetString(const class FString& Section, const class FString& Key);
	static TArray<struct FGSMonitorInfo> GetAllMonitorInfo();
	static float GetAvailableGraphicsMemory(EGSGraphicsMemoryMode InQueryType);
	static TArray<struct FIntPoint> GetAvailableResolutions();
	static TArray<struct FIntPoint> GetAvailableResolutionsByMonitorID(int32 InMonitorID);
	static int32 GetCPUUsedPercentage();
	static float GetCPUUsedTime();
	static float GetCurrentFPS();
	static struct FIntPoint GetCurrentResolution();
	static struct FGSScalabilityQualities GetCurrentScalabilityQualities(bool bLogInfo);
	static struct FGSScalabilityQualities GetCurrentScalabilityQuality(bool bLogInfo);
	static EGSScreenMode GetCurrentScreenMode();
	static EWindowMode GetCurrentScreenModeV2();
	static float GetFrameRateLimit();
	static int32 GetGPUUsedPercentage();
	static float GetGPUUsedTime();
	static int32 GetGraphicsMemoryInfo(EGSGraphicsMemoryMode InGraphicsMemoryMode);
	static struct FIntPoint GetGSystemResolution();
	static TArray<struct FIntPoint> GetProportionalResolutions(const struct FIntPoint& AspectRatio);
	static struct FGSScalabilityQualities GetRecommendedScalabilityQuality(bool bLogInfo);
	static float GetResolutionScaleFromQualityLevel(EScalabilityQuality InQualityLevel);
	static struct FVector2D GetScreenSize();
	static float GetUsedGraphicsMemory(EGSGraphicsMemoryMode InQueryType);
	static bool GetVSyncEnabled();
	static void GMChangeMonitorAsPrimary(int32 MonitorIdx);
	static void Init();
	static void RefreshBenchmarkMonitor();
	static void SetAntiAliasingQuality(EScalabilityQuality InAntiAliasingQuality);
	static void SetEffectsQuality(EScalabilityQuality InEffectQuality);
	static void SetFoliageQuality(EScalabilityQuality InFoliageQuality);
	static void SetFrameRateLimit(float InFrameRateLimit);
	static void SetGlobalIlluminationQuality(EScalabilityQuality InGIQuality);
	static void SetMonitorAsPrimary(const class FString& MonitorID);
	static void SetMonitorAsPrimaryV2(const class FString& InMonitorID);
	static void SetPostProcessQuality(EScalabilityQuality InPostProcessQuality);
	static void SetPriorityMode(EGSPriorityMode InPriorityMode);
	static void SetReflectionQuality(EScalabilityQuality InReflectionQuality);
	static void SetResolutionQualityLevel(EScalabilityQuality InResolutionQualityLevel);
	static void SetResolutionQualityScale(float InResolutionQualityScale);
	static void SetScalabilityQualities(const struct FGSScalabilityQualities& Qualities);
	static void SetScalabilityQuality(EScalabilityQuality TargetGSQualityLevel);
	static void SetScreenPos(const struct FVector2D& Position);
	static void SetShadingQuality(EScalabilityQuality InShadingQuality);
	static void SetShadowQuality(EScalabilityQuality InShadowQuality);
	static void SetTargetResolution(const struct FIntPoint& TargetResolution, bool NeedFresh);
	static void SetTargetScreenMode(EGSScreenMode TargetScreenMode);
	static void SetTargetScreenModeV2(EWindowMode TargetWindowMode);
	static void SetTextureQuality(EScalabilityQuality InTextureQuality);
	static void SetViewDistanceQuality(EScalabilityQuality InViewDistanceQuality);
	static void SetVSyncEnabled(bool bEnableVSync);

	void OnMonitorAsPrimaryChange(int32 TargetPrimaryMonitorIndex);
	void OnViewportResizedEvent(const struct FIntPoint& NewSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_SystemSettingsFuncLib">();
	}
	static class UGSE_SystemSettingsFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_SystemSettingsFuncLib>();
	}
};
//static_assert(alignof(UGSE_SystemSettingsFuncLib) == 0x000008, "Wrong alignment on UGSE_SystemSettingsFuncLib");
//static_assert(sizeof(UGSE_SystemSettingsFuncLib) == 0x000028, "Wrong size on UGSE_SystemSettingsFuncLib");

// Class UnrealExtent.GSE_TextureFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_TextureFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void BuildStreamedLowMips(class URuntimeVirtualTextureComponent* RVTComponent);
	static TArray<float> CalculateAverageColorInTiles(class UTexture2D* InTexture, const struct FIntPoint& TileCount, bool bDebugLog);
	static void CaptureStreamingTextureStats();
	static class UMaterialInstanceDynamic* ChangeImageMaterial(class UObject* WorldContextObject, class UImage* Image, const class FString& MatPath);
	static void CollectNonPowerOfTwoUdimVT();
	static class UTextureRenderTarget2D* CreateRenderTarget2D(class UObject* WorldContextObject, int32 Width, int32 Height, const struct FLinearColor& ClearColor);
	static void CreateStaticTexture2D(class UTextureRenderTarget2D* SourceRT, const class FString& OutputPath, const class FString& OutputFileName);
	static class UTexture2D* CreateTexture2D(int32 SrcWidth, int32 SrcHeight, const class FString& Name_0, EPixelFormat InFormat);
	static class UTexture2D* CreateTexture2DFromColorData(int32 SrcWidth, int32 SrcHeight, const TArray<struct FColor>& ColorData, const class FString& Name_0);
	static void DumpStreamingTextureStats();
	static void EndCapturingStreamingTextureStats();
	static void ExportColorDataAsPNG(int32 SrcWidth, int32 SrcHeight, const class FString& FilePath, const struct FColorBufferPtr& ColorBuffer, int32 Count);
	static void ExportTexture2D(class UObject* WorldContextObject, class UTexture2D* Texture, const class FString& FilePath, const class FString& Filename);
	static void OutputNonPowerOfTwoUdimVTInfo();
	static void ReleaseRenderTarget(class UTextureRenderTarget2D* TextureRenderTarget);
	static void StartCapturingStreamingTextureStats();
	static bool WriteToTexture_GameThread(class UTexture2D* TargetTexture, const struct FColorBufferPtr& ColorBuffer, int32 Count, int32 MipMapIndex);
	static void WriteToTexture_RenderingThread(class UTexture2D* TargetTexture, const struct FColorBufferPtr& ColorBuffer, int32 Count, int32 MipMapIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_TextureFuncLib">();
	}
	static class UGSE_TextureFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_TextureFuncLib>();
	}
};
//static_assert(alignof(UGSE_TextureFuncLib) == 0x000008, "Wrong alignment on UGSE_TextureFuncLib");
//static_assert(sizeof(UGSE_TextureFuncLib) == 0x000028, "Wrong size on UGSE_TextureFuncLib");

// Class UnrealExtent.GSE_UINavigationFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_UINavigationFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void AddNavigationActionKey(EUINavigationAction TargetNavigationAction, const class FName& KeyName);
	static void AddNavigationKey(EUINavigation TargetNavigation, const class FName& KeyName);
	static void BlockConflictNavigation(EGSUIConflictNavigationType ConflictNavigationType, bool bBlock, const TArray<EUINavigation>& NotBlockNavigations);
	static void ClearAllNavigationActionKey();
	static void ClearAllNavigationKey();
	static void ClearNavigationActionKey(const class FName& KeyName);
	static void ClearNavigationActionKeyByAction(EUINavigationAction TargetNavigationAction);
	static void ClearNavigationKey(const class FName& KeyName);
	static void ClearNavigationKeyByNavigation(EUINavigation TargetNavigation);
	static bool GetIsNeedAnalogNavigation();
	static bool GetIsNeedKeyNavigation();
	static bool GetIsNeedNavigationAction();
	static bool GetIsNeedTabKeyNavigation();
	static EUINavigationAction GetNavigationActionFromKey(const struct FKeyEvent& InKeyEvent);
	static EUINavigation GetNavigationDirectionFromAnalogForOP(const struct FAnalogInputEvent& InAnalogEvent);
	static EUINavigation GetNavigationDirectionFromKey(const struct FKeyEvent& InKeyEvent);
	static void InitSetWorkingGSUINavigation();
	static bool IsRepeatAction(const struct FKeyEvent& InKeyEvent);
	static void SetAnalogNavigationHorizontalThreshold(float TargetThreshold);
	static void SetAnalogNavigationVerticalThreshold(float TargetThreshold);
	static void SetNeedAnalogNavigation(bool IsNeed);
	static void SetNeedKeyNavigation(bool IsNeed);
	static void SetNeedNavigationAction(bool IsNeed);
	static void SetNeedTabKeyNavigation(bool IsNeed);
	static void SetRepeatFactor(float RepeatFactorInDefault, float RepeatFactorInPressure, float RepeatPressureFactor, float RepeatPressureCondition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_UINavigationFuncLib">();
	}
	static class UGSE_UINavigationFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_UINavigationFuncLib>();
	}
};
//static_assert(alignof(UGSE_UINavigationFuncLib) == 0x000008, "Wrong alignment on UGSE_UINavigationFuncLib");
//static_assert(sizeof(UGSE_UINavigationFuncLib) == 0x000028, "Wrong size on UGSE_UINavigationFuncLib");

// Class UnrealExtent.GSViewPortHelper
// 0x0010 (0x0038 - 0x0028)
class UGSViewPortHelper final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnViewPortResized;                                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSViewPortHelper">();
	}
	static class UGSViewPortHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSViewPortHelper>();
	}
};
//static_assert(alignof(UGSViewPortHelper) == 0x000008, "Wrong alignment on UGSViewPortHelper");
//static_assert(sizeof(UGSViewPortHelper) == 0x000038, "Wrong size on UGSViewPortHelper");
//static_assert(offsetof(UGSViewPortHelper, OnViewPortResized) == 0x000028, "Member 'UGSViewPortHelper::OnViewPortResized' has a wrong offset!");

// Class UnrealExtent.GSE_UMGFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_UMGFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void ActiveVirtualKeyboard(bool IsActive);
	static void AddUserWidgetAsSlateToViewport(class UUserWidget* Widget, const int32 ZOrder);
	static bool BindBorderOnMouseDownEvent(class UBorder* Border, class UObject* TargetObj, const class FName& Name_0);
	static bool BindImageOnMouseDownEvent(class UImage* Image, class UObject* TargetObj, const class FName& Name_0);
	static void CalcImageTexture(class UImage* InImage, TArray<struct FColor>* OutColorArray, TArray<struct FVector2D>* OutPosArray);
	static class UUserWidget* CloneUserWidget(class UUserWidget* BaseWidget, const class FName& Name_0);
	static class UWidget* ConstructUWidgetWithClass(class UUserWidget* FromWidget, class UClass* WidgetClass);
	static class FText ConvertToDateText(int32 Year, int32 Month, int32 Day, int32 Hour, int32 Minute, int32 Second);
	static class FText ConvertToTimeText(int32 Year, int32 Month, int32 Day, int32 Hour, int32 Minute, int32 Second);
	static class UUserWidget* CreateEditorStandaloneWidget(class UWidget* OwningWidget, const class FString& ResPath, const class FName& Name_0);
	static class UGSAnimKeyStateBlender* CreateGSAnimKeyStateBlender(class UObject* WorldContext);
	static class UGSViewPortHelper* CreateGSViewPortHelper(class UObject* WorldContext);
	static class UUserWidget* CreateUserWidget(class UObject* WorldContext, const class FString& ResPath);
	static class UUserWidget* CreateUserWidgetWithClass(class UObject* WorldContext, class UClass* WidgetClass);
	static class UWidget* FindChildWidget(class UUserWidget* UserWidget, class UPanelWidget* ParentWidget, class FName ChildWidgetName);
	static int32 FindChildWidgetIndex(class UUserWidget* UserWidget, class UPanelWidget* ParentWidget, class FName ChildWidgetName);
	static void FoldTextContent(class UTextBlock* InTextBlock, const struct FTextFoldingConfig& InFoldingConfig);
	static TArray<class UUserWidget*> GetAllChildUserWidget(class UPanelWidget* ParentWidget);
	static TArray<class UWidget*> GetAllChildUserWidgetWithClass(class UUserWidget* UserWidget, class UClass* WidgetClass);
	static TArray<class UWidget*> GetAllChildWidget(class UUserWidget* UserWidget);
	static TArray<class UWidget*> GetAllChildWidgetWithClass(class UUserWidget* UserWidget, class UClass* WidgetClass);
	static struct FKey GetAnalogKey(const struct FAnalogInputEvent& AnalogInputEvent);
	static bool GetAnalogKeyIsRepeat(const struct FAnalogInputEvent& AnalogInputEvent);
	static float GetAnalogValue(const struct FAnalogInputEvent& AnalogInputEvent);
	static class UWidget* GetChildWidgetAt(class UPanelWidget* ParentWidget, int32 ChildIndex);
	static class FString GetCurrentCulture();
	static EFocusCause GetFocusEventCause(const struct FFocusEvent& FocusEvent);
	static int32 GetFocusEventUser(const struct FFocusEvent& FocusEvent);
	static bool GetIsAxis1DKey(class FName KeyName);
	static bool GetIsGamepadKey(class FName KeyName);
	static struct FKey GetKeyWithName(class FName KeyName);
	static double GetMediaPlayerTimer(class UMediaPlayer* MediaPlayer);
	static struct FKey GetMouseKey(const struct FPointerEvent& PointerEvent);
	static bool GetMousePositionFromViewport(struct FVector2D* OutPosition);
	static float GetMouseWheelDelta(const struct FPointerEvent& PointerEvent);
	static class UWidget* GetRootWidget(class UUserWidget* Widget);
	static struct FMargin GetSafeZonePaddingSize(class UObject* WorldContextObject);
	static class UMaterialInstanceDynamic* GetTextBlockOutlineDynamicMaterial(class UTextBlock* TextBlock);
	static struct FVector2D GetViewPortAbsPosition(class UObject* WorldContextObject);
	static float GetViewPortScale(class UObject* WorldContextObject);
	static struct FVector2D GetViewportSize(class UObject* WorldContextObject);
	static struct FIntPoint GetViewportSizeXY();
	static struct FVector2D GetWidgetAbsolutePosition(class UWidget* Widget);
	static struct FVector2D GetWidgetAbsolutePositionAtCoordinates(class UWidget* Widget, const struct FVector2D& NormalCoordinates);
	static struct FVector2D GetWidgetAbsolutePositionAtCoordinatesWithPaintSpace(class UWidget* Widget, const struct FVector2D& NormalCoordinates);
	static struct FVector2D GetWidgetAbsoluteSize(class UWidget* Widget);
	static float GetWidgetAbsScale(class UWidget* Widget);
	static class UWidgetAnimation* GetWidgetAnimationByName(class UUserWidget* Widget, const class FString& Name_0);
	static class FString GetWidgetAnimationName(class UWidgetAnimation* Animation);
	static class UWidget* GetWidgetFromName(class UUserWidget* Widget, const class FName& Name_0);
	static bool GetWidgetIsVariable(const class UWidget* Widget);
	static struct FVector2D GetWidgetLocalPositionAtCoordinates(class UWidget* Widget, const struct FVector2D& NormalCoordinates);
	static struct FVector2D GetWidgetLocalPositionAtCoordinatesWithPaintSpace(class UWidget* Widget, const struct FVector2D& NormalCoordinates);
	static struct FVector2D GetWidgetLocalSize(class UWidget* Widget);
	static void GetWidgetPositionSizeRefViewPort(class UWidget* Widget, struct FVector2D* Position, struct FVector2D* WidgetSize);
	static void GSProjectWidgetList(class APlayerController* PlayerController, class UWidget* Canvas, const TArray<struct FProjWidgetInfo>& ProjWidgetInfos, TArray<struct FProjResult>* Results);
	static bool GSProjectWorldLocationToWidgetPosition(class APlayerController* PlayerController, const struct FVector& WorldLocation, struct FVector2D* ViewportPosition, bool* bIsInFront);
	static void InvokeWidgetInputEvent(class UWidget* UWidget, int32 InputType, const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	static bool IsBinkMediaBeginPlay(const class UBinkMediaPlayer* BinkMediaPlayer);
	static bool IsMediaBeginPlay(const class UMediaPlayer* MediaPlayer);
	static bool IsWidgetVisiableWithParent(class UWidget* TargetWidget);
	static void IsWidgetVisiableWithParentInList(const TArray<class UUserWidget*>& InWidgetList, TArray<class UUserWidget*>* OutWidgetList);
	static int32 LoadTexture2DToAreaIDArray(class UTexture2D* TargetTexture, const TMap<struct FColor, int32>& AreaColorIDMap, TMap<int32, uint8>* AreaData, struct FVector2D* OutOriginPos, struct FVector2D* OutMapSize, class FString* ErrMsg);
	static struct FVector2D LocalToViewPortPixelPos(class UObject* WorldContextObject, const struct FGeometry& Geometry);
	static struct FVector2D LocalToViewPortPos(class UObject* WorldContextObject, const struct FGeometry& Geometry);
	static void LogHittestGrid();
	static struct FEventReply MakeEventReply(bool IsHandled);
	static bool NeedExecuteAction(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent, class UTexture2D* AdvancedHitTexture, float AdvancedHitAlpha);
	static bool NeedExecuteActionWithDA(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent, class UDataAsset* HitAreaDA, float AdvancedHitAlpha);
	static bool NewLocalStringTable(const class FName& ID, const class FString& Namespace);
	static int32 PointerEvent_GetPointerIndex(const struct FPointerEvent& PointerEvent);
	static struct FVector2D PointerEvent_GetPositionInGeometry(const struct FGeometry& Geometry, const struct FPointerEvent& PointerEvent);
	static struct FVector2D PointerEvent_GetScreenSpacePosition(const struct FPointerEvent& PointerEvent);
	static bool PointerEvent_IsMouseButtonDown(const struct FPointerEvent& PointerEvent, const class FName& MouseButtonName);
	static bool PointerEvent_IsMouseTouchEvent(const struct FPointerEvent& PointerEvent);
	static bool PointerEvent_IsTouchFirstMove(const struct FPointerEvent& PointerEvent);
	static void QAGetAllWidgetsOfClass(class UObject* WorldContextObject, TArray<class UWidget*>* FoundWidgets, TSubclassOf<class UWidget> WidgetClass);
	static void QAGetWidgetCenterPosition(class UWidget* Widget, struct FVector2D* WidgetPosition, struct FVector2D* CenterPosition, struct FVector2D* WidgetSize);
	static void QAGetWidgetWithText(class UObject* WorldContextObject, TArray<class UWidget*>* FoundWidgets, const class FString& Text);
	static void RefreshDPIScale(class UObject* WorldContext);
	static void RefreshRichTextDefaultStyle(class URichTextBlock* RichTextBlock);
	static void RemoveUserWidgetAsSlateFromViewport(class UUserWidget* Widget);
	static void SetColorVisionDeficiencyType(EColorVisionDeficiency Type, float Severity, bool CorrectDeficiency, bool ShowCorrectionWithDeficiency);
	static bool SetCurrentCulture(const class FString& CultureName);
	static bool SetHardwareCursor(class UObject* WorldContextObject, EMouseCursor CursorShape, class FName CursorName, const struct FVector2D& HotSpot);
	static bool SetLocalStringTableEntry(const class FName& ID, const class FString& Key, const class FString& Src);
	static void SetTextToBitmapFontBox(class UWidget* Widget, const class FText& Text);
	static void SetUserFocusWithCause(class APlayerController* PlayerController, class UWidget* Widget, EFocusCause Cause);
	static void SetWidgetEnable(class UWidget* Widget, bool Enable);
	static struct FVector2D SlateAbsoluteToLocal(const struct FGeometry& Geometry, const struct FVector2D& AbsolutePos);
	static struct FVector2D SlateLocalToAbsolute(const struct FGeometry& Geometry, const struct FVector2D& LocalPos);
	static struct FVector2D WidgetAbsoluteToLocal(class UWidget* Widget, const struct FVector2D& AbsoluteCoordinates);
	static struct FVector2D WidgetLocalToAbsolute(class UWidget* Widget, const struct FVector2D& LocalCoordinates);
	static struct FVector2D WidgetLocalToRoundedLocal(class UWidget* Widget, const struct FVector2D& LocalCoordinates);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_UMGFuncLib">();
	}
	static class UGSE_UMGFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_UMGFuncLib>();
	}
};
//static_assert(alignof(UGSE_UMGFuncLib) == 0x000008, "Wrong alignment on UGSE_UMGFuncLib");
//static_assert(sizeof(UGSE_UMGFuncLib) == 0x000028, "Wrong size on UGSE_UMGFuncLib");

// Class UnrealExtent.GSE_WidgetCompFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_WidgetCompFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void DestoryWidgetComponent(class UWidgetComponent* Comp);
	static void RegisterWidgetComponent(class UWidgetComponent* Comp);
	static void UnregisterWidgetComponent(class UWidgetComponent* Comp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_WidgetCompFuncLib">();
	}
	static class UGSE_WidgetCompFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_WidgetCompFuncLib>();
	}
};
//static_assert(alignof(UGSE_WidgetCompFuncLib) == 0x000008, "Wrong alignment on UGSE_WidgetCompFuncLib");
//static_assert(sizeof(UGSE_WidgetCompFuncLib) == 0x000028, "Wrong size on UGSE_WidgetCompFuncLib");

// Class UnrealExtent.GSFocusWidget
// 0x0018 (0x0148 - 0x0130)
class UGSFocusWidget final : public UWidget
{
public:
	bool                                          IsFocusable;                                       // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x17];                                     // 0x0131(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSFocusWidget">();
	}
	static class UGSFocusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSFocusWidget>();
	}
};
//static_assert(alignof(UGSFocusWidget) == 0x000008, "Wrong alignment on UGSFocusWidget");
//static_assert(sizeof(UGSFocusWidget) == 0x000148, "Wrong size on UGSFocusWidget");
//static_assert(offsetof(UGSFocusWidget, IsFocusable) == 0x000130, "Member 'UGSFocusWidget::IsFocusable' has a wrong offset!");

// Class UnrealExtent.GSLerpCon
// 0x0010 (0x0158 - 0x0148)
class UGSLerpCon final : public UContentWidget
{
public:
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSLerpCon">();
	}
	static class UGSLerpCon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSLerpCon>();
	}
};
//static_assert(alignof(UGSLerpCon) == 0x000008, "Wrong alignment on UGSLerpCon");
//static_assert(sizeof(UGSLerpCon) == 0x000158, "Wrong size on UGSLerpCon");

// Class UnrealExtent.GSLerpConSlot
// 0x0010 (0x0048 - 0x0038)
class UGSLerpConSlot final : public UPanelSlot
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSLerpConSlot">();
	}
	static class UGSLerpConSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSLerpConSlot>();
	}
};
//static_assert(alignof(UGSLerpConSlot) == 0x000008, "Wrong alignment on UGSLerpConSlot");
//static_assert(sizeof(UGSLerpConSlot) == 0x000048, "Wrong size on UGSLerpConSlot");

// Class UnrealExtent.GSNavigationChunkContainerActor
// 0x0008 (0x0280 - 0x0278)
class AGSNavigationChunkContainerActor final : public APartitionActor
{
public:
	uint32                                        ChunkActorGridSize;                                // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSNavigationChunkContainerActor">();
	}
	static class AGSNavigationChunkContainerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSNavigationChunkContainerActor>();
	}
};
//static_assert(alignof(AGSNavigationChunkContainerActor) == 0x000008, "Wrong alignment on AGSNavigationChunkContainerActor");
//static_assert(sizeof(AGSNavigationChunkContainerActor) == 0x000280, "Wrong size on AGSNavigationChunkContainerActor");
//static_assert(offsetof(AGSNavigationChunkContainerActor, ChunkActorGridSize) == 0x000278, "Member 'AGSNavigationChunkContainerActor::ChunkActorGridSize' has a wrong offset!");

// Class UnrealExtent.GSNavigationSystemModuleConfig
// 0x0000 (0x0058 - 0x0058)
class UGSNavigationSystemModuleConfig final : public UNavigationSystemModuleConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSNavigationSystemModuleConfig">();
	}
	static class UGSNavigationSystemModuleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSNavigationSystemModuleConfig>();
	}
};
//static_assert(alignof(UGSNavigationSystemModuleConfig) == 0x000008, "Wrong alignment on UGSNavigationSystemModuleConfig");
//static_assert(sizeof(UGSNavigationSystemModuleConfig) == 0x000058, "Wrong size on UGSNavigationSystemModuleConfig");

// Class UnrealExtent.GSNavigationSystemV1
// 0x0050 (0x1698 - 0x1648)
class UGSNavigationSystemV1 final : public UNavigationSystemV1
{
public:
	uint8                                         Pad_1648[0x50];                                    // 0x1648(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSNavigationSystemV1">();
	}
	static class UGSNavigationSystemV1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSNavigationSystemV1>();
	}
};
//static_assert(alignof(UGSNavigationSystemV1) == 0x000008, "Wrong alignment on UGSNavigationSystemV1");
//static_assert(sizeof(UGSNavigationSystemV1) == 0x001698, "Wrong size on UGSNavigationSystemV1");

// Class UnrealExtent.GSNavigationWorldSubsystem
// 0x00B0 (0x00F0 - 0x0040)
class UGSNavigationWorldSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0xB0];                                      // 0x0040(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSNavigationWorldSubsystem">();
	}
	static class UGSNavigationWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSNavigationWorldSubsystem>();
	}
};
//static_assert(alignof(UGSNavigationWorldSubsystem) == 0x000008, "Wrong alignment on UGSNavigationWorldSubsystem");
//static_assert(sizeof(UGSNavigationWorldSubsystem) == 0x0000F0, "Wrong size on UGSNavigationWorldSubsystem");

// Class UnrealExtent.GSOfflineFontBox
// 0x0060 (0x0190 - 0x0130)
class UGSOfflineFontBox final : public UWidget
{
public:
	TArray<struct FSlateBrush>                    BrushArray;                                        // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0148(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x0160(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntPoint                              FontScaleFactor;                                   // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              UVPadding;                                         // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSOfflineFontBox">();
	}
	static class UGSOfflineFontBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSOfflineFontBox>();
	}
};
//static_assert(alignof(UGSOfflineFontBox) == 0x000008, "Wrong alignment on UGSOfflineFontBox");
//static_assert(sizeof(UGSOfflineFontBox) == 0x000190, "Wrong size on UGSOfflineFontBox");
//static_assert(offsetof(UGSOfflineFontBox, BrushArray) == 0x000130, "Member 'UGSOfflineFontBox::BrushArray' has a wrong offset!");
//static_assert(offsetof(UGSOfflineFontBox, Font) == 0x000140, "Member 'UGSOfflineFontBox::Font' has a wrong offset!");
//static_assert(offsetof(UGSOfflineFontBox, Text) == 0x000148, "Member 'UGSOfflineFontBox::Text' has a wrong offset!");
//static_assert(offsetof(UGSOfflineFontBox, TextDelegate) == 0x000160, "Member 'UGSOfflineFontBox::TextDelegate' has a wrong offset!");
//static_assert(offsetof(UGSOfflineFontBox, FontScaleFactor) == 0x000170, "Member 'UGSOfflineFontBox::FontScaleFactor' has a wrong offset!");
//static_assert(offsetof(UGSOfflineFontBox, UVPadding) == 0x000178, "Member 'UGSOfflineFontBox::UVPadding' has a wrong offset!");

// Class UnrealExtent.GSRetainerBox
// 0x0030 (0x0178 - 0x0148)
class UnrealExtent::UGSRetainerBox : public UContentWidget
{
public:
	bool                                          bRetainRender;                                     // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RenderOnInvalidation;                              // 0x0149(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RenderOnPhase;                                     // 0x014A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14B[0x1];                                      // 0x014B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Phase;                                             // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseCount;                                        // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGSPixToPix;                                      // 0x0154(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     EffectMaterial;                                    // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TextureParameter;                                  // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnViewWidgetSizeChangedEvent(const struct FVector2D& Size);
	void RequestRender();
	void SetEffectMaterial(class UMaterialInterface* EffectMaterial_0);
	void SetRenderingPhase(int32 RenderPhase, int32 TotalPhases);
	void SetRetainRendering(bool bInRetainRendering);
	void SetTextureParameter(class FName TextureParameter_0);

	class UMaterialInstanceDynamic* GetEffectMaterial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Class UnrealExtent.GSRetainerBox", true>();
	}
	static class UnrealExtent::UGSRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UnrealExtent::UGSRetainerBox>();
	}
};
//static_assert(alignof(UnrealExtent::UGSRetainerBox) == 0x000008, "Wrong alignment on UnrealExtent::UGSRetainerBox");
//static_assert(sizeof(UnrealExtent::UGSRetainerBox) == 0x000178, "Wrong size on UnrealExtent::UGSRetainerBox");
//static_assert(offsetof(UnrealExtent::UGSRetainerBox, bRetainRender) == 0x000148, "Member 'UnrealExtent::UGSRetainerBox::bRetainRender' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSRetainerBox, RenderOnInvalidation) == 0x000149, "Member 'UnrealExtent::UGSRetainerBox::RenderOnInvalidation' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSRetainerBox, RenderOnPhase) == 0x00014A, "Member 'UnrealExtent::UGSRetainerBox::RenderOnPhase' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSRetainerBox, Phase) == 0x00014C, "Member 'UnrealExtent::UGSRetainerBox::Phase' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSRetainerBox, PhaseCount) == 0x000150, "Member 'UnrealExtent::UGSRetainerBox::PhaseCount' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSRetainerBox, IsGSPixToPix) == 0x000154, "Member 'UnrealExtent::UGSRetainerBox::IsGSPixToPix' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSRetainerBox, EffectMaterial) == 0x000158, "Member 'UnrealExtent::UGSRetainerBox::EffectMaterial' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSRetainerBox, TextureParameter) == 0x000160, "Member 'UnrealExtent::UGSRetainerBox::TextureParameter' has a wrong offset!");

// Class UnrealExtent.GSRichTextBlock
// 0x00B0 (0x0970 - 0x08C0)
class UGSRichTextBlock : public URichTextBlock
{
public:
	bool                                          UseIndent;                                         // 0x08B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B9[0x7];                                      // 0x08B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Ellipsis;                                          // 0x08C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultIndentSize;                                 // 0x08D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGSRichCaltureConfig                   DefaultCaltureConfig;                              // 0x08D4(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGSRichCaltureConfig                   JapanCaltureConfig;                                // 0x08E8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8FC[0x4];                                      // 0x08FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Content;                                           // 0x0900(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_918[0x58];                                     // 0x0918(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyText(const class FText& InText);
	void MakeContentDirty();
	void NativeCheckText();
	void OnTextPrePaint();
	void SetDefaultIndentSize(float InDefaultIndentSize);
	void SetUseIndent(bool InUseIndent);

	class FString GetContent() const;
	float GetDefaultIndentSize() const;
	bool GetUseIndent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSRichTextBlock">();
	}
	static class UGSRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSRichTextBlock>();
	}
};
//static_assert(alignof(UGSRichTextBlock) == 0x000010, "Wrong alignment on UGSRichTextBlock");
//static_assert(sizeof(UGSRichTextBlock) == 0x000970, "Wrong size on UGSRichTextBlock");
//static_assert(offsetof(UGSRichTextBlock, UseIndent) == 0x0008B8, "Member 'UGSRichTextBlock::UseIndent' has a wrong offset!");
//static_assert(offsetof(UGSRichTextBlock, Ellipsis) == 0x0008C0, "Member 'UGSRichTextBlock::Ellipsis' has a wrong offset!");
//static_assert(offsetof(UGSRichTextBlock, DefaultIndentSize) == 0x0008D0, "Member 'UGSRichTextBlock::DefaultIndentSize' has a wrong offset!");
//static_assert(offsetof(UGSRichTextBlock, DefaultCaltureConfig) == 0x0008D4, "Member 'UGSRichTextBlock::DefaultCaltureConfig' has a wrong offset!");
//static_assert(offsetof(UGSRichTextBlock, JapanCaltureConfig) == 0x0008E8, "Member 'UGSRichTextBlock::JapanCaltureConfig' has a wrong offset!");
//static_assert(offsetof(UGSRichTextBlock, Content) == 0x000900, "Member 'UGSRichTextBlock::Content' has a wrong offset!");

// Class UnrealExtent.GSRichScaleText
// 0x0050 (0x09C0 - 0x0970)
class UGSRichScaleText final : public UGSRichTextBlock
{
public:
	float                                         GSWidthOverride;                                   // 0x0970(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSHeightOverride;                                  // 0x0974(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMinDesiredWidth;                                 // 0x0978(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMinDesiredHeight;                                // 0x097C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMaxDesiredWidth;                                 // 0x0980(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMaxDesiredHeight;                                // 0x0984(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMinAspectRatio;                                  // 0x0988(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMaxAspectRatio;                                  // 0x098C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GSWidthOverride : 1;                     // 0x0990(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSHeightOverride : 1;                    // 0x0990(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMinDesiredWidth : 1;                   // 0x0990(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMinDesiredHeight : 1;                  // 0x0990(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMaxDesiredWidth : 1;                   // 0x0990(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMaxDesiredHeight : 1;                  // 0x0990(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMinAspectRatio : 1;                    // 0x0990(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMaxAspectRatio : 1;                    // 0x0990(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EStretch                                      Stretch;                                           // 0x0991(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStretchDirection                             StretchDirection;                                  // 0x0992(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_993[0x1];                                      // 0x0993(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UserSpecifiedScale;                                // 0x0994(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreInheritedScale;                              // 0x0998(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0999(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x099A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99B[0x25];                                     // 0x099B(0x0025)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearGSHeightOverride();
	void ClearGSMaxAspectRatio();
	void ClearGSMaxDesiredHeight();
	void ClearGSMaxDesiredWidth();
	void ClearGSMinAspectRatio();
	void ClearGSMinDesiredHeight();
	void ClearGSMinDesiredWidth();
	void ClearGSWidthOverride();
	void SetGSHeightOverride(float InGSHeightOverride);
	void SetGSMaxAspectRatio(float InGSMaxAspectRatio);
	void SetGSMaxDesiredHeight(float InGSMaxDesiredHeight);
	void SetGSMaxDesiredWidth(float InGSMaxDesiredWidth);
	void SetGSMinAspectRatio(float InGSMinAspectRatio);
	void SetGSMinDesiredHeight(float InGSMinDesiredHeight);
	void SetGSMinDesiredWidth(float InGSMinDesiredWidth);
	void SetGSWidthOverride(float InGSWidthOverride);
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetIgnoreInheritedScale(bool bInIgnoreInheritedScale);
	void SetStretch(EStretch InStretch);
	void SetStretchDirection(EStretchDirection InStretchDirection);
	void SetUserSpecifiedScale(float InUserSpecifiedScale);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSRichScaleText">();
	}
	static class UGSRichScaleText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSRichScaleText>();
	}
};
//static_assert(alignof(UGSRichScaleText) == 0x000010, "Wrong alignment on UGSRichScaleText");
//static_assert(sizeof(UGSRichScaleText) == 0x0009C0, "Wrong size on UGSRichScaleText");
//static_assert(offsetof(UGSRichScaleText, GSWidthOverride) == 0x000970, "Member 'UGSRichScaleText::GSWidthOverride' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, GSHeightOverride) == 0x000974, "Member 'UGSRichScaleText::GSHeightOverride' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, GSMinDesiredWidth) == 0x000978, "Member 'UGSRichScaleText::GSMinDesiredWidth' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, GSMinDesiredHeight) == 0x00097C, "Member 'UGSRichScaleText::GSMinDesiredHeight' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, GSMaxDesiredWidth) == 0x000980, "Member 'UGSRichScaleText::GSMaxDesiredWidth' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, GSMaxDesiredHeight) == 0x000984, "Member 'UGSRichScaleText::GSMaxDesiredHeight' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, GSMinAspectRatio) == 0x000988, "Member 'UGSRichScaleText::GSMinAspectRatio' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, GSMaxAspectRatio) == 0x00098C, "Member 'UGSRichScaleText::GSMaxAspectRatio' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, Stretch) == 0x000991, "Member 'UGSRichScaleText::Stretch' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, StretchDirection) == 0x000992, "Member 'UGSRichScaleText::StretchDirection' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, UserSpecifiedScale) == 0x000994, "Member 'UGSRichScaleText::UserSpecifiedScale' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, IgnoreInheritedScale) == 0x000998, "Member 'UGSRichScaleText::IgnoreInheritedScale' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, HorizontalAlignment) == 0x000999, "Member 'UGSRichScaleText::HorizontalAlignment' has a wrong offset!");
//static_assert(offsetof(UGSRichScaleText, VerticalAlignment) == 0x00099A, "Member 'UGSRichScaleText::VerticalAlignment' has a wrong offset!");

// Class UnrealExtent.GSRoundRect
// 0x0000 (0x0158 - 0x0158)
class UGSRoundRect : public UOverlay
{
public:
	bool CalcMappingRoundRectPoint(const struct FVector2D& PosInViewPort, bool IsInFront, const struct FVector2D& InnerContentRectSize, const struct FVector2D& InnerContentRectAlign, bool IsOuter, struct FVector2D* BorderPosRefRoundRect, float* RectAngle, int32* OutIndicatorType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSRoundRect">();
	}
	static class UGSRoundRect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSRoundRect>();
	}
};
//static_assert(alignof(UGSRoundRect) == 0x000008, "Wrong alignment on UGSRoundRect");
//static_assert(sizeof(UGSRoundRect) == 0x000158, "Wrong size on UGSRoundRect");

// Class UnrealExtent.GSRoundRectQuick
// 0x0098 (0x01F0 - 0x0158)
class UGSRoundRectQuick final : public UOverlay
{
public:
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               RadiusCfg;                                         // 0x0160(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x70];                                     // 0x0180(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSRoundRectQuick">();
	}
	static class UGSRoundRectQuick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSRoundRectQuick>();
	}
};
//static_assert(alignof(UGSRoundRectQuick) == 0x000010, "Wrong alignment on UGSRoundRectQuick");
//static_assert(sizeof(UGSRoundRectQuick) == 0x0001F0, "Wrong size on UGSRoundRectQuick");
//static_assert(offsetof(UGSRoundRectQuick, RadiusCfg) == 0x000160, "Member 'UGSRoundRectQuick::RadiusCfg' has a wrong offset!");

// Class UnrealExtent.GSSafeZone
// 0x0020 (0x0150 - 0x0130)
class UGSSafeZone final : public UWidget
{
public:
	struct FLinearColor                           SafeZoneBrushColor;                                // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSSafeZone">();
	}
	static class UGSSafeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSSafeZone>();
	}
};
//static_assert(alignof(UGSSafeZone) == 0x000008, "Wrong alignment on UGSSafeZone");
//static_assert(sizeof(UGSSafeZone) == 0x000150, "Wrong size on UGSSafeZone");
//static_assert(offsetof(UGSSafeZone, SafeZoneBrushColor) == 0x000130, "Member 'UGSSafeZone::SafeZoneBrushColor' has a wrong offset!");

// Class UnrealExtent.GSTextBlock
// 0x0080 (0x03D0 - 0x0350)
class UGSTextBlock : public UTextBlock
{
public:
	bool                                          UseIndent;                                         // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Ellipsis;                                          // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultIndentSize;                                 // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Content;                                           // 0x0370(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x48];                                     // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyText(const class FText& InText);
	void MakeContentDirty();
	void NativeCheckText();
	void OnTextPrePaint();
	void SetDefaultIndentSize(float InDefaultIndentSize);
	void SetUseIndent(bool InUseIndent);

	class FString GetContent() const;
	float GetDefaultIndentSize() const;
	bool GetUseIndent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSTextBlock">();
	}
	static class UGSTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSTextBlock>();
	}
};
//static_assert(alignof(UGSTextBlock) == 0x000010, "Wrong alignment on UGSTextBlock");
//static_assert(sizeof(UGSTextBlock) == 0x0003D0, "Wrong size on UGSTextBlock");
//static_assert(offsetof(UGSTextBlock, UseIndent) == 0x000350, "Member 'UGSTextBlock::UseIndent' has a wrong offset!");
//static_assert(offsetof(UGSTextBlock, Ellipsis) == 0x000358, "Member 'UGSTextBlock::Ellipsis' has a wrong offset!");
//static_assert(offsetof(UGSTextBlock, DefaultIndentSize) == 0x000368, "Member 'UGSTextBlock::DefaultIndentSize' has a wrong offset!");
//static_assert(offsetof(UGSTextBlock, Content) == 0x000370, "Member 'UGSTextBlock::Content' has a wrong offset!");

// Class UnrealExtent.GSScaleText
// 0x0050 (0x0420 - 0x03D0)
class UGSScaleText final : public UGSTextBlock
{
public:
	float                                         GSWidthOverride;                                   // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSHeightOverride;                                  // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMinDesiredWidth;                                 // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMinDesiredHeight;                                // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMaxDesiredWidth;                                 // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMaxDesiredHeight;                                // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMinAspectRatio;                                  // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GSMaxAspectRatio;                                  // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GSWidthOverride : 1;                     // 0x03F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSHeightOverride : 1;                    // 0x03F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMinDesiredWidth : 1;                   // 0x03F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMinDesiredHeight : 1;                  // 0x03F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMaxDesiredWidth : 1;                   // 0x03F0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMaxDesiredHeight : 1;                  // 0x03F0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMinAspectRatio : 1;                    // 0x03F0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GSMaxAspectRatio : 1;                    // 0x03F0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EStretch                                      Stretch;                                           // 0x03F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStretchDirection                             StretchDirection;                                  // 0x03F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F3[0x1];                                      // 0x03F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UserSpecifiedScale;                                // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreInheritedScale;                              // 0x03F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x03F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x03FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FB[0x25];                                     // 0x03FB(0x0025)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearGSHeightOverride();
	void ClearGSMaxAspectRatio();
	void ClearGSMaxDesiredHeight();
	void ClearGSMaxDesiredWidth();
	void ClearGSMinAspectRatio();
	void ClearGSMinDesiredHeight();
	void ClearGSMinDesiredWidth();
	void ClearGSWidthOverride();
	void SetGSHeightOverride(float InGSHeightOverride);
	void SetGSMaxAspectRatio(float InGSMaxAspectRatio);
	void SetGSMaxDesiredHeight(float InGSMaxDesiredHeight);
	void SetGSMaxDesiredWidth(float InGSMaxDesiredWidth);
	void SetGSMinAspectRatio(float InGSMinAspectRatio);
	void SetGSMinDesiredHeight(float InGSMinDesiredHeight);
	void SetGSMinDesiredWidth(float InGSMinDesiredWidth);
	void SetGSWidthOverride(float InGSWidthOverride);
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetIgnoreInheritedScale(bool bInIgnoreInheritedScale);
	void SetStretch(EStretch InStretch);
	void SetStretchDirection(EStretchDirection InStretchDirection);
	void SetUserSpecifiedScale(float InUserSpecifiedScale);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSScaleText">();
	}
	static class UGSScaleText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSScaleText>();
	}
};
//static_assert(alignof(UGSScaleText) == 0x000010, "Wrong alignment on UGSScaleText");
//static_assert(sizeof(UGSScaleText) == 0x000420, "Wrong size on UGSScaleText");
//static_assert(offsetof(UGSScaleText, GSWidthOverride) == 0x0003D0, "Member 'UGSScaleText::GSWidthOverride' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, GSHeightOverride) == 0x0003D4, "Member 'UGSScaleText::GSHeightOverride' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, GSMinDesiredWidth) == 0x0003D8, "Member 'UGSScaleText::GSMinDesiredWidth' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, GSMinDesiredHeight) == 0x0003DC, "Member 'UGSScaleText::GSMinDesiredHeight' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, GSMaxDesiredWidth) == 0x0003E0, "Member 'UGSScaleText::GSMaxDesiredWidth' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, GSMaxDesiredHeight) == 0x0003E4, "Member 'UGSScaleText::GSMaxDesiredHeight' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, GSMinAspectRatio) == 0x0003E8, "Member 'UGSScaleText::GSMinAspectRatio' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, GSMaxAspectRatio) == 0x0003EC, "Member 'UGSScaleText::GSMaxAspectRatio' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, Stretch) == 0x0003F1, "Member 'UGSScaleText::Stretch' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, StretchDirection) == 0x0003F2, "Member 'UGSScaleText::StretchDirection' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, UserSpecifiedScale) == 0x0003F4, "Member 'UGSScaleText::UserSpecifiedScale' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, IgnoreInheritedScale) == 0x0003F8, "Member 'UGSScaleText::IgnoreInheritedScale' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, HorizontalAlignment) == 0x0003F9, "Member 'UGSScaleText::HorizontalAlignment' has a wrong offset!");
//static_assert(offsetof(UGSScaleText, VerticalAlignment) == 0x0003FA, "Member 'UGSScaleText::VerticalAlignment' has a wrong offset!");

// Class UnrealExtent.GSScrollBox
// 0x07E8 (0x0930 - 0x0148)
class UnrealExtent::UGSScrollBox final : public UPanelWidget
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x0150(0x0770)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 BarStyle;                                          // 0x08C0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x08C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              ScrollBarVisibility;                               // 0x08C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8CA[0x6];                                      // 0x08CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScrollbarThickness;                                // 0x08D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                ScrollbarPadding;                                  // 0x08E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          AlwaysShowScrollbar;                               // 0x08F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysShowScrollbarTrack;                          // 0x08F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NavCanLoop;                                        // 0x08F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F3[0x5];                                      // 0x08F3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUserScrolled;                                    // 0x08F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_908[0x28];                                     // 0x0908(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBottomSpacer();
	float GetTopSpacer();
	void ScrollWidgetIntoView(class UWidget* WidgetToFind, bool AnimateScroll, EDescendantScrollDestination ScrollDestination, float Padding);
	void SetAlwaysShowScrollbar(bool NewAlwaysShowScrollbar);
	void SetBottomSpacer(float InBottomSpacer);
	void SetNavCanLoop(bool InNavCanLoop);
	void SetNavigationDestination(const EDescendantScrollDestination NewNavigationDestination);
	void SetNavigationScrollPadding(const float NewNavigationScrollPadding);
	void SetOrientation(EOrientation NewOrientation);
	void SetScrollbarPadding(const struct FMargin& NewScrollbarPadding);
	void SetScrollbarThickness(const struct FVector2D& NewScrollbarThickness);
	void SetScrollbarVisibility(ESlateVisibility NewScrollBarVisibility);
	void SetScrollOffset(float InScrollOffset);
	void SetScrollWhenFocusChanges(EScrollWhenFocusChanges NewScrollWhenFocusChanges);
	void SetTargetScrollOffset(float InTargetScrollOffset);
	void SetTopSpacer(float InTopSpacer);

	float GetScrollContent() const;
	float GetScrollContentWithOutSpacer() const;
	float GetScrollOffset() const;
	float GetScrollOffsetOfEnd() const;
	float GetViewOffsetFraction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Class UnrealExtent.GSScrollBox", true>();
	}
	static class UnrealExtent::UGSScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UnrealExtent::UGSScrollBox>();
	}
};
//static_assert(alignof(UnrealExtent::UGSScrollBox) == 0x000010, "Wrong alignment on UnrealExtent::UGSScrollBox");
//static_assert(sizeof(UnrealExtent::UGSScrollBox) == 0x000930, "Wrong size on UnrealExtent::UGSScrollBox");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, WidgetBarStyle) == 0x000150, "Member 'UnrealExtent::UGSScrollBox::WidgetBarStyle' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, BarStyle) == 0x0008C0, "Member 'UnrealExtent::UGSScrollBox::BarStyle' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, Orientation) == 0x0008C8, "Member 'UnrealExtent::UGSScrollBox::Orientation' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, ScrollBarVisibility) == 0x0008C9, "Member 'UnrealExtent::UGSScrollBox::ScrollBarVisibility' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, ScrollbarThickness) == 0x0008D0, "Member 'UnrealExtent::UGSScrollBox::ScrollbarThickness' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, ScrollbarPadding) == 0x0008E0, "Member 'UnrealExtent::UGSScrollBox::ScrollbarPadding' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, AlwaysShowScrollbar) == 0x0008F0, "Member 'UnrealExtent::UGSScrollBox::AlwaysShowScrollbar' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, AlwaysShowScrollbarTrack) == 0x0008F1, "Member 'UnrealExtent::UGSScrollBox::AlwaysShowScrollbarTrack' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, NavCanLoop) == 0x0008F2, "Member 'UnrealExtent::UGSScrollBox::NavCanLoop' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSScrollBox, OnUserScrolled) == 0x0008F8, "Member 'UnrealExtent::UGSScrollBox::OnUserScrolled' has a wrong offset!");

// Class UnrealExtent.GSScrollBoxSlot
// 0x0020 (0x0058 - 0x0038)
class UGSScrollBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0xE];                                       // 0x004A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSScrollBoxSlot">();
	}
	static class UGSScrollBoxSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSScrollBoxSlot>();
	}
};
//static_assert(alignof(UGSScrollBoxSlot) == 0x000008, "Wrong alignment on UGSScrollBoxSlot");
//static_assert(sizeof(UGSScrollBoxSlot) == 0x000058, "Wrong size on UGSScrollBoxSlot");
//static_assert(offsetof(UGSScrollBoxSlot, Padding) == 0x000038, "Member 'UGSScrollBoxSlot::Padding' has a wrong offset!");
//static_assert(offsetof(UGSScrollBoxSlot, HorizontalAlignment) == 0x000048, "Member 'UGSScrollBoxSlot::HorizontalAlignment' has a wrong offset!");
//static_assert(offsetof(UGSScrollBoxSlot, VerticalAlignment) == 0x000049, "Member 'UGSScrollBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UnrealExtent.GSTestWidget
// 0x0018 (0x02B0 - 0x0298)
class UGSTestWidget final : public UUserWidget
{
public:
	int32                                         TestNum;                                           // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 TestImage;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          TestAudioEvent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSTestWidget">();
	}
	static class UGSTestWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSTestWidget>();
	}
};
//static_assert(alignof(UGSTestWidget) == 0x000008, "Wrong alignment on UGSTestWidget");
//static_assert(sizeof(UGSTestWidget) == 0x0002B0, "Wrong size on UGSTestWidget");
//static_assert(offsetof(UGSTestWidget, TestNum) == 0x000298, "Member 'UGSTestWidget::TestNum' has a wrong offset!");
//static_assert(offsetof(UGSTestWidget, TestImage) == 0x0002A0, "Member 'UGSTestWidget::TestImage' has a wrong offset!");
//static_assert(offsetof(UGSTestWidget, TestAudioEvent) == 0x0002A8, "Member 'UGSTestWidget::TestAudioEvent' has a wrong offset!");

// Class UnrealExtent.GSTileView
// 0x0030 (0x0C20 - 0x0BF0)
class UnrealExtent::UGSTileView : public UListView
{
public:
	float                                         EntryHeight;                                       // 0x0BF0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EntryWidth;                                        // 0x0BF4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EListItemAlignment                            TileAlignment;                                     // 0x0BF8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF9[0x3];                                      // 0x0BF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TopSpacerSize;                                     // 0x0BFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BottomSpacerSize;                                  // 0x0C00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowScrollBar;                                     // 0x0C04(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWrapHorizontalNavigation;                         // 0x0C05(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C06[0x1A];                                     // 0x0C06(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBottomScrollWidget(class UUserWidget* WidgetToAppend);
	void AddTopScrollWidget(class UUserWidget* WidgetToAppend);
	void ClearAllWidget();
	void ClearBottomScrollWidgets();
	void ClearTopScrollWidgets();
	float GetFirstLine();
	void InsertBottomScrollWidget(class UUserWidget* WidgetToInset);
	void InsertTopScrollWidget(class UUserWidget* WidgetToInset);
	void ItemScrolledIntoViewEvent(class UObject* Item, class UUserWidget* Widget);
	void OnEntryInitializedEvent(class UObject* Item, class UUserWidget* Widget);
	void OnEntryWidgetGeneratedEvent(class UUserWidget* Widget);
	void OnEntryWidgetReleasedEvent(class UUserWidget* Widget);
	void OnViewWidgetSizeChangedEvent(const struct FVector2D& Size);
	void SetBottomItemPosList(const TArray<float>& InChildsPosList);
	void SetBottomSpacerSize(float InBottomSpacerSize);
	void SetEntryHeight(float NewHeight);
	void SetEntryWidth(float NewWidth);
	void SetForceNeedBottomSpacer(bool InForceNeedBottomSpacer);
	void SetForceNeedTopSpacer(bool InForceNeedTopSpacer);
	void SetItemWidget(TSubclassOf<class UUserWidget> InItemWidget);
	void SetOrientation(EOrientation InOrientation);
	void SetShowScrollBar(bool InShowScrollBar);
	void SetTileAlignment(EListItemAlignment InTileAlignment);
	void SetTopItemPosList(const TArray<float>& InChildsPosList);
	void SetTopSpacerSize(float InTopSpacerSize);

	float GetBottomSpacerSize() const;
	float GetEntryHeight() const;
	float GetEntryWidth() const;
	float GetTopSpacerSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Class UnrealExtent.GSTileView", true>();
	}
	static class UnrealExtent::UGSTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UnrealExtent::UGSTileView>();
	}
};
//static_assert(alignof(UnrealExtent::UGSTileView) == 0x000010, "Wrong alignment on UnrealExtent::UGSTileView");
//static_assert(sizeof(UnrealExtent::UGSTileView) == 0x000C20, "Wrong size on UnrealExtent::UGSTileView");
//static_assert(offsetof(UnrealExtent::UGSTileView, EntryHeight) == 0x000BF0, "Member 'UnrealExtent::UGSTileView::EntryHeight' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSTileView, EntryWidth) == 0x000BF4, "Member 'UnrealExtent::UGSTileView::EntryWidth' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSTileView, TileAlignment) == 0x000BF8, "Member 'UnrealExtent::UGSTileView::TileAlignment' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSTileView, TopSpacerSize) == 0x000BFC, "Member 'UnrealExtent::UGSTileView::TopSpacerSize' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSTileView, BottomSpacerSize) == 0x000C00, "Member 'UnrealExtent::UGSTileView::BottomSpacerSize' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSTileView, ShowScrollBar) == 0x000C04, "Member 'UnrealExtent::UGSTileView::ShowScrollBar' has a wrong offset!");
//static_assert(offsetof(UnrealExtent::UGSTileView, bWrapHorizontalNavigation) == 0x000C05, "Member 'UnrealExtent::UGSTileView::bWrapHorizontalNavigation' has a wrong offset!");

// Class UnrealExtent.GSUINavigationDel
// 0x0000 (0x0028 - 0x0028)
class UGSUINavigationDel final : public UObject
{
public:
	void GSOnNavigationChangedFocus(class UWidget* OldWidget, class UWidget* NewWidget, const struct FFocusEvent& FocusEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSUINavigationDel">();
	}
	static class UGSUINavigationDel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSUINavigationDel>();
	}
};
//static_assert(alignof(UGSUINavigationDel) == 0x000008, "Wrong alignment on UGSUINavigationDel");
//static_assert(sizeof(UGSUINavigationDel) == 0x000028, "Wrong size on UGSUINavigationDel");

// Class UnrealExtent.GSUserWidgetOnFocusChange
// 0x0000 (0x0298 - 0x0298)
class UGSUserWidgetOnFocusChange final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSUserWidgetOnFocusChange">();
	}
	static class UGSUserWidgetOnFocusChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSUserWidgetOnFocusChange>();
	}
};
//static_assert(alignof(UGSUserWidgetOnFocusChange) == 0x000008, "Wrong alignment on UGSUserWidgetOnFocusChange");
//static_assert(sizeof(UGSUserWidgetOnFocusChange) == 0x000298, "Wrong size on UGSUserWidgetOnFocusChange");

// Class UnrealExtent.GSWCStreamingSourceActor
// 0x0008 (0x0280 - 0x0278)
class AGSWCStreamingSourceActor final : public AActor
{
public:
	class UGSWorldCompositionStreamingSourceComponent* StreamingSorceComponent;                           // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSWCStreamingSourceActor">();
	}
	static class AGSWCStreamingSourceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSWCStreamingSourceActor>();
	}
};
//static_assert(alignof(AGSWCStreamingSourceActor) == 0x000008, "Wrong alignment on AGSWCStreamingSourceActor");
//static_assert(sizeof(AGSWCStreamingSourceActor) == 0x000280, "Wrong size on AGSWCStreamingSourceActor");
//static_assert(offsetof(AGSWCStreamingSourceActor, StreamingSorceComponent) == 0x000278, "Member 'AGSWCStreamingSourceActor::StreamingSorceComponent' has a wrong offset!");

// Class UnrealExtent.GSWidgetRender
// 0x0060 (0x0310 - 0x02B0)
class UGSWidgetRender final : public USceneComponent
{
public:
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyGammaCorrection;                             // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoUpdate;                                     // 0x02C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUseViewPortWindowSize;                          // 0x02C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3[0x5];                                      // 0x02C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RefWindowSize;                                     // 0x02C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            InstWidget;                                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateRenderTarget2D();

	class UUserWidget* GetUserWidgetObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSWidgetRender">();
	}
	static class UGSWidgetRender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSWidgetRender>();
	}
};
//static_assert(alignof(UGSWidgetRender) == 0x000010, "Wrong alignment on UGSWidgetRender");
//static_assert(sizeof(UGSWidgetRender) == 0x000310, "Wrong size on UGSWidgetRender");
//static_assert(offsetof(UGSWidgetRender, WidgetClass) == 0x0002B0, "Member 'UGSWidgetRender::WidgetClass' has a wrong offset!");
//static_assert(offsetof(UGSWidgetRender, RenderTarget) == 0x0002B8, "Member 'UGSWidgetRender::RenderTarget' has a wrong offset!");
//static_assert(offsetof(UGSWidgetRender, bApplyGammaCorrection) == 0x0002C0, "Member 'UGSWidgetRender::bApplyGammaCorrection' has a wrong offset!");
//static_assert(offsetof(UGSWidgetRender, bIsAutoUpdate) == 0x0002C1, "Member 'UGSWidgetRender::bIsAutoUpdate' has a wrong offset!");
//static_assert(offsetof(UGSWidgetRender, bIsUseViewPortWindowSize) == 0x0002C2, "Member 'UGSWidgetRender::bIsUseViewPortWindowSize' has a wrong offset!");
//static_assert(offsetof(UGSWidgetRender, RefWindowSize) == 0x0002C8, "Member 'UGSWidgetRender::RefWindowSize' has a wrong offset!");
//static_assert(offsetof(UGSWidgetRender, InstWidget) == 0x0002D8, "Member 'UGSWidgetRender::InstWidget' has a wrong offset!");

// Class UnrealExtent.GS_PCGStaticMeshSpawner
// 0x00F8 (0x02B0 - 0x01B8)
class UGS_PCGStaticMeshSpawner final : public UPCGStaticMeshSpawnerSettings
{
public:
	TMap<class FName, bool>                       MatSwitchParams;                                   // 0x01B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      MatScalarParams;                                   // 0x0208(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        MatVectorParams;                                   // 0x0258(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         ICPDVersion;                                       // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSaveICPDMat;                                  // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetOriginalCPDParams;                             // 0x02AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearICPDMat;                                     // 0x02AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeleteICPDMatWhenClear;                           // 0x02AF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GS_PCGStaticMeshSpawner">();
	}
	static class UGS_PCGStaticMeshSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGS_PCGStaticMeshSpawner>();
	}
};
//static_assert(alignof(UGS_PCGStaticMeshSpawner) == 0x000008, "Wrong alignment on UGS_PCGStaticMeshSpawner");
//static_assert(sizeof(UGS_PCGStaticMeshSpawner) == 0x0002B0, "Wrong size on UGS_PCGStaticMeshSpawner");
//static_assert(offsetof(UGS_PCGStaticMeshSpawner, MatSwitchParams) == 0x0001B8, "Member 'UGS_PCGStaticMeshSpawner::MatSwitchParams' has a wrong offset!");
//static_assert(offsetof(UGS_PCGStaticMeshSpawner, MatScalarParams) == 0x000208, "Member 'UGS_PCGStaticMeshSpawner::MatScalarParams' has a wrong offset!");
//static_assert(offsetof(UGS_PCGStaticMeshSpawner, MatVectorParams) == 0x000258, "Member 'UGS_PCGStaticMeshSpawner::MatVectorParams' has a wrong offset!");
//static_assert(offsetof(UGS_PCGStaticMeshSpawner, ICPDVersion) == 0x0002A8, "Member 'UGS_PCGStaticMeshSpawner::ICPDVersion' has a wrong offset!");
//static_assert(offsetof(UGS_PCGStaticMeshSpawner, bAutoSaveICPDMat) == 0x0002AC, "Member 'UGS_PCGStaticMeshSpawner::bAutoSaveICPDMat' has a wrong offset!");
//static_assert(offsetof(UGS_PCGStaticMeshSpawner, bGetOriginalCPDParams) == 0x0002AD, "Member 'UGS_PCGStaticMeshSpawner::bGetOriginalCPDParams' has a wrong offset!");
//static_assert(offsetof(UGS_PCGStaticMeshSpawner, bClearICPDMat) == 0x0002AE, "Member 'UGS_PCGStaticMeshSpawner::bClearICPDMat' has a wrong offset!");
//static_assert(offsetof(UGS_PCGStaticMeshSpawner, bDeleteICPDMatWhenClear) == 0x0002AF, "Member 'UGS_PCGStaticMeshSpawner::bDeleteICPDMatWhenClear' has a wrong offset!");

// Class UnrealExtent.HitPhysicalAnimComp
// 0x00A0 (0x0190 - 0x00F0)
class UHitPhysicalAnimComp final : public UPhysicalAnimationComponent
{
public:
	struct FPhysicalAnimationData                 PhysicalAnimationData;                             // 0x00F0(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            WeightCurve;                                       // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitSegmentation;                                   // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveWeightAtTime;                                 // 0x0124(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSum;                                           // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HitBoneNames;                                      // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ForceVector;                                       // 0x0140(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceStrength;                                     // 0x0158(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x28];                                     // 0x0168(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeHit(const TArray<class FName>& BoneList, const struct FVector& InForceVector, float InForceStrength);
	TArray<class FName> BonesSphereMask(class USkeletalMeshComponent* TargetSkeletalMesh, float Radius, const struct FVector& WorldPosition, const TArray<class FName>& WhiteNamesList);
	bool CreateTimer(float TimeDelay);
	void HitBoneImpulse();
	void InitiazliePhysicalAnimation();
	void SetBodyBonePhysic(class USkeletalMeshComponent* TargetMesh, class FName BoneName, bool NewBool);
	void SetBonesKinematic(const TArray<class FName>& BoneNames);
	void SetBonesPhysic(const TArray<class FName>& BoneNames);
	void SetBonesPhysicWeight(const TArray<class FName>& BoneNames);
	void TimerCallback();
	void TimerTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitPhysicalAnimComp">();
	}
	static class UHitPhysicalAnimComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitPhysicalAnimComp>();
	}
};
//static_assert(alignof(UHitPhysicalAnimComp) == 0x000008, "Wrong alignment on UHitPhysicalAnimComp");
//static_assert(sizeof(UHitPhysicalAnimComp) == 0x000190, "Wrong size on UHitPhysicalAnimComp");
//static_assert(offsetof(UHitPhysicalAnimComp, PhysicalAnimationData) == 0x0000F0, "Member 'UHitPhysicalAnimComp::PhysicalAnimationData' has a wrong offset!");
//static_assert(offsetof(UHitPhysicalAnimComp, WeightCurve) == 0x000118, "Member 'UHitPhysicalAnimComp::WeightCurve' has a wrong offset!");
//static_assert(offsetof(UHitPhysicalAnimComp, HitSegmentation) == 0x000120, "Member 'UHitPhysicalAnimComp::HitSegmentation' has a wrong offset!");
//static_assert(offsetof(UHitPhysicalAnimComp, CurveWeightAtTime) == 0x000124, "Member 'UHitPhysicalAnimComp::CurveWeightAtTime' has a wrong offset!");
//static_assert(offsetof(UHitPhysicalAnimComp, TimeSum) == 0x000128, "Member 'UHitPhysicalAnimComp::TimeSum' has a wrong offset!");
//static_assert(offsetof(UHitPhysicalAnimComp, HitBoneNames) == 0x000130, "Member 'UHitPhysicalAnimComp::HitBoneNames' has a wrong offset!");
//static_assert(offsetof(UHitPhysicalAnimComp, ForceVector) == 0x000140, "Member 'UHitPhysicalAnimComp::ForceVector' has a wrong offset!");
//static_assert(offsetof(UHitPhysicalAnimComp, ForceStrength) == 0x000158, "Member 'UHitPhysicalAnimComp::ForceStrength' has a wrong offset!");
//static_assert(offsetof(UHitPhysicalAnimComp, Mesh) == 0x000160, "Member 'UHitPhysicalAnimComp::Mesh' has a wrong offset!");

// Class UnrealExtent.IKMeshControlComponent
// 0x0038 (0x00E8 - 0x00B0)
class UIKMeshControlComponent final : public UActorComponent
{
public:
	class ACharacter*                             TargetMeshOwner;                                   // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMeshZOffset;                                // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTraceDebug;                                     // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIKActive;                                       // 0x00C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IKFootLeftBoneName;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IKFootRightoneName;                                // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCheckSpeed;                                     // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDepth;                                        // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetLerpAlpha;                                   // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKMeshControlComponent">();
	}
	static class UIKMeshControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKMeshControlComponent>();
	}
};
//static_assert(alignof(UIKMeshControlComponent) == 0x000008, "Wrong alignment on UIKMeshControlComponent");
//static_assert(sizeof(UIKMeshControlComponent) == 0x0000E8, "Wrong size on UIKMeshControlComponent");
//static_assert(offsetof(UIKMeshControlComponent, TargetMeshOwner) == 0x0000B0, "Member 'UIKMeshControlComponent::TargetMeshOwner' has a wrong offset!");
//static_assert(offsetof(UIKMeshControlComponent, TargetMesh) == 0x0000B8, "Member 'UIKMeshControlComponent::TargetMesh' has a wrong offset!");
//static_assert(offsetof(UIKMeshControlComponent, DefaultMeshZOffset) == 0x0000C0, "Member 'UIKMeshControlComponent::DefaultMeshZOffset' has a wrong offset!");
//static_assert(offsetof(UIKMeshControlComponent, bIsTraceDebug) == 0x0000C4, "Member 'UIKMeshControlComponent::bIsTraceDebug' has a wrong offset!");
//static_assert(offsetof(UIKMeshControlComponent, bIsIKActive) == 0x0000C5, "Member 'UIKMeshControlComponent::bIsIKActive' has a wrong offset!");
//static_assert(offsetof(UIKMeshControlComponent, IKFootLeftBoneName) == 0x0000C8, "Member 'UIKMeshControlComponent::IKFootLeftBoneName' has a wrong offset!");
//static_assert(offsetof(UIKMeshControlComponent, IKFootRightoneName) == 0x0000D0, "Member 'UIKMeshControlComponent::IKFootRightoneName' has a wrong offset!");
//static_assert(offsetof(UIKMeshControlComponent, MaxCheckSpeed) == 0x0000D8, "Member 'UIKMeshControlComponent::MaxCheckSpeed' has a wrong offset!");
//static_assert(offsetof(UIKMeshControlComponent, TraceDepth) == 0x0000DC, "Member 'UIKMeshControlComponent::TraceDepth' has a wrong offset!");
//static_assert(offsetof(UIKMeshControlComponent, OffsetLerpAlpha) == 0x0000E0, "Member 'UIKMeshControlComponent::OffsetLerpAlpha' has a wrong offset!");

// Class UnrealExtent.LandscapePhysicalMatModifierVolume
// 0x0090 (0x0340 - 0x02B0)
class ALandscapePhysicalMatModifierVolume final : public AVolume
{
public:
	class AGenerateLandscapeVolume*               GenerateVolume;                                    // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALandscape*                             LandscapeActor;                                    // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x80];                                     // 0x02C0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapePhysicalMatModifierVolume">();
	}
	static class ALandscapePhysicalMatModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandscapePhysicalMatModifierVolume>();
	}
};
//static_assert(alignof(ALandscapePhysicalMatModifierVolume) == 0x000008, "Wrong alignment on ALandscapePhysicalMatModifierVolume");
//static_assert(sizeof(ALandscapePhysicalMatModifierVolume) == 0x000340, "Wrong size on ALandscapePhysicalMatModifierVolume");
//static_assert(offsetof(ALandscapePhysicalMatModifierVolume, GenerateVolume) == 0x0002B0, "Member 'ALandscapePhysicalMatModifierVolume::GenerateVolume' has a wrong offset!");
//static_assert(offsetof(ALandscapePhysicalMatModifierVolume, LandscapeActor) == 0x0002B8, "Member 'ALandscapePhysicalMatModifierVolume::LandscapeActor' has a wrong offset!");

// Class UnrealExtent.LandscapeReader
// 0x00E8 (0x0110 - 0x0028)
class ULandscapeReader final : public UObject
{
public:
	class ALandscapeProxy*                        TargetProxy;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             ProxyTransform;                                    // 0x0030(0x0060)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntPoint                              ActorSpaceExtendsMin;                              // 0x0090(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ActorSpaceExtendsMax;                              // 0x0098(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCached;                                          // 0x00A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLandscapeReaderAllWeightData          LayerWeights;                                      // 0x00A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<uint16>                                HeightData;                                        // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x48];                                      // 0x00C8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cache(class ALandscapeProxy* NewLandscapeProxy);
	struct FIntPtr GetHeightData();
	struct FIntPtr GetHeightDataInRect(int32 MinX, int32 MinY, int32 MaxX, int32 MaxY);
	struct FIntPtr GetWeightData(int32 LayerIndex);
	struct FIntPtr GetWeightDataInRect(int32 MinX, int32 MinY, int32 MaxX, int32 MaxY, int32 LayerIndex);
	int32 HeightDataElementNum();
	int32 HeightDataElementSize();
	float SampleHeightData(const struct FVector& WorldPos, ESampleType SampleType);
	float SampleWeightData(const struct FVector& WorldPos, int32 LayerIndex, ESampleType SampleType);
	int32 WeightDataElementNum(int32 LayerIndex);
	int32 WeightDataElementSize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeReader">();
	}
	static class ULandscapeReader* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeReader>();
	}
};
//static_assert(alignof(ULandscapeReader) == 0x000010, "Wrong alignment on ULandscapeReader");
//static_assert(sizeof(ULandscapeReader) == 0x000110, "Wrong size on ULandscapeReader");
//static_assert(offsetof(ULandscapeReader, TargetProxy) == 0x000028, "Member 'ULandscapeReader::TargetProxy' has a wrong offset!");
//static_assert(offsetof(ULandscapeReader, ProxyTransform) == 0x000030, "Member 'ULandscapeReader::ProxyTransform' has a wrong offset!");
//static_assert(offsetof(ULandscapeReader, ActorSpaceExtendsMin) == 0x000090, "Member 'ULandscapeReader::ActorSpaceExtendsMin' has a wrong offset!");
//static_assert(offsetof(ULandscapeReader, ActorSpaceExtendsMax) == 0x000098, "Member 'ULandscapeReader::ActorSpaceExtendsMax' has a wrong offset!");
//static_assert(offsetof(ULandscapeReader, IsCached) == 0x0000A0, "Member 'ULandscapeReader::IsCached' has a wrong offset!");
//static_assert(offsetof(ULandscapeReader, LayerWeights) == 0x0000A8, "Member 'ULandscapeReader::LayerWeights' has a wrong offset!");
//static_assert(offsetof(ULandscapeReader, HeightData) == 0x0000B8, "Member 'ULandscapeReader::HeightData' has a wrong offset!");

// Class UnrealExtent.LayerSceneInfo
// 0x00A8 (0x0320 - 0x0278)
class ALayerSceneInfo : public AActor
{
public:
	class ALandscape*                             LandscapeActor;                                    // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ActorSpaceExtendsMin;                              // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ActorSpaceExtendsMax;                              // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             LandscapeTransform;                                // 0x0290(0x0060)(Edit, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAllLayerData                          AllLandscapeLayerData;                             // 0x02F0(0x0020)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TArray<class UTexture*>                       LayerPreviewInEditor;                              // 0x0310(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void BeginPlayCS();
	void GenerateLayeredInfo();
	bool QueryWeightInfo(const struct FVector& WorldPos, int32 LayerIndex, bool Nearest, float* Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LayerSceneInfo">();
	}
	static class ALayerSceneInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALayerSceneInfo>();
	}
};
//static_assert(alignof(ALayerSceneInfo) == 0x000010, "Wrong alignment on ALayerSceneInfo");
//static_assert(sizeof(ALayerSceneInfo) == 0x000320, "Wrong size on ALayerSceneInfo");
//static_assert(offsetof(ALayerSceneInfo, LandscapeActor) == 0x000278, "Member 'ALayerSceneInfo::LandscapeActor' has a wrong offset!");
//static_assert(offsetof(ALayerSceneInfo, ActorSpaceExtendsMin) == 0x000280, "Member 'ALayerSceneInfo::ActorSpaceExtendsMin' has a wrong offset!");
//static_assert(offsetof(ALayerSceneInfo, ActorSpaceExtendsMax) == 0x000288, "Member 'ALayerSceneInfo::ActorSpaceExtendsMax' has a wrong offset!");
//static_assert(offsetof(ALayerSceneInfo, LandscapeTransform) == 0x000290, "Member 'ALayerSceneInfo::LandscapeTransform' has a wrong offset!");
//static_assert(offsetof(ALayerSceneInfo, AllLandscapeLayerData) == 0x0002F0, "Member 'ALayerSceneInfo::AllLandscapeLayerData' has a wrong offset!");
//static_assert(offsetof(ALayerSceneInfo, LayerPreviewInEditor) == 0x000310, "Member 'ALayerSceneInfo::LayerPreviewInEditor' has a wrong offset!");

// Class UnrealExtent.StatInfoBaseWidget
// 0x0078 (0x0310 - 0x0298)
class UStatInfoBaseWidget : public UUserWidget
{
public:
	class UStatGroupInfoThresholdConfig*          StatGroupThresholdConfig;                          // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FetchStatInfoInterval;                             // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatUISimulatedGraphicsCard                  SimulatedGraphicsCard;                             // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatUISimulatedGraphicsCard                  SelfGraphicsCard;                                  // 0x02A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRecordPerformanceData;                      // 0x02A6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A7[0x1];                                      // 0x02A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RecordFileName;                                    // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x58];                                     // 0x02B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndRecord();
	class FString GetGPUBrand();
	float GetSimulatedGraphicsCardScaleFactor(const class FString& InStatName);
	void SaveRecordsToFiles(int32 NeedCleanup);
	void StartRecord(const class FString& FXConfig, const class FString& UnitName, const class FString& SkillName, const class FString& AssetPath, const float MontageLength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatInfoBaseWidget">();
	}
	static class UStatInfoBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatInfoBaseWidget>();
	}
};
//static_assert(alignof(UStatInfoBaseWidget) == 0x000008, "Wrong alignment on UStatInfoBaseWidget");
//static_assert(sizeof(UStatInfoBaseWidget) == 0x000310, "Wrong size on UStatInfoBaseWidget");
//static_assert(offsetof(UStatInfoBaseWidget, StatGroupThresholdConfig) == 0x000298, "Member 'UStatInfoBaseWidget::StatGroupThresholdConfig' has a wrong offset!");
//static_assert(offsetof(UStatInfoBaseWidget, FetchStatInfoInterval) == 0x0002A0, "Member 'UStatInfoBaseWidget::FetchStatInfoInterval' has a wrong offset!");
//static_assert(offsetof(UStatInfoBaseWidget, SimulatedGraphicsCard) == 0x0002A4, "Member 'UStatInfoBaseWidget::SimulatedGraphicsCard' has a wrong offset!");
//static_assert(offsetof(UStatInfoBaseWidget, SelfGraphicsCard) == 0x0002A5, "Member 'UStatInfoBaseWidget::SelfGraphicsCard' has a wrong offset!");
//static_assert(offsetof(UStatInfoBaseWidget, bEnableRecordPerformanceData) == 0x0002A6, "Member 'UStatInfoBaseWidget::bEnableRecordPerformanceData' has a wrong offset!");
//static_assert(offsetof(UStatInfoBaseWidget, RecordFileName) == 0x0002A8, "Member 'UStatInfoBaseWidget::RecordFileName' has a wrong offset!");

// Class UnrealExtent.NiagaraStatInfoUI
// 0x0008 (0x0318 - 0x0310)
class UNiagaraStatInfoUI final : public UStatInfoBaseWidget
{
public:
	class UVerticalBox*                           VBox_StatList;                                     // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraStatInfoUI">();
	}
	static class UNiagaraStatInfoUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraStatInfoUI>();
	}
};
//static_assert(alignof(UNiagaraStatInfoUI) == 0x000008, "Wrong alignment on UNiagaraStatInfoUI");
//static_assert(sizeof(UNiagaraStatInfoUI) == 0x000318, "Wrong size on UNiagaraStatInfoUI");
//static_assert(offsetof(UNiagaraStatInfoUI, VBox_StatList) == 0x000310, "Member 'UNiagaraStatInfoUI::VBox_StatList' has a wrong offset!");

// Class UnrealExtent.PrefabStaticMeshActor
// 0x0000 (0x0288 - 0x0288)
class APrefabStaticMeshActor final : public AStaticMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrefabStaticMeshActor">();
	}
	static class APrefabStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APrefabStaticMeshActor>();
	}
};
//static_assert(alignof(APrefabStaticMeshActor) == 0x000008, "Wrong alignment on APrefabStaticMeshActor");
//static_assert(sizeof(APrefabStaticMeshActor) == 0x000288, "Wrong size on APrefabStaticMeshActor");

// Class UnrealExtent.RTAvatarUtil
// 0x0000 (0x0028 - 0x0028)
class URTAvatarUtil final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RTAvatarUtil">();
	}
	static class URTAvatarUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<URTAvatarUtil>();
	}
};
//static_assert(alignof(URTAvatarUtil) == 0x000008, "Wrong alignment on URTAvatarUtil");
//static_assert(sizeof(URTAvatarUtil) == 0x000028, "Wrong size on URTAvatarUtil");

// Class UnrealExtent.SlateDebugInfo
// 0x0078 (0x0310 - 0x0298)
class USlateDebugInfo final : public UUserWidget
{
public:
	class UTextBlock*                             Txt_Fps;                                           // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Txt_TickTime;                                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Txt_SlateRender;                                   // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Txt_WidgetRender;                                  // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Txt_Prepass;                                       // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Txt_NumBatches;                                    // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Txt_WidgetAllocSize;                               // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetStatInfoInterval;                               // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x3C];                                     // 0x02D4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlateDebugInfo">();
	}
	static class USlateDebugInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlateDebugInfo>();
	}
};
//static_assert(alignof(USlateDebugInfo) == 0x000008, "Wrong alignment on USlateDebugInfo");
//static_assert(sizeof(USlateDebugInfo) == 0x000310, "Wrong size on USlateDebugInfo");
//static_assert(offsetof(USlateDebugInfo, Txt_Fps) == 0x000298, "Member 'USlateDebugInfo::Txt_Fps' has a wrong offset!");
//static_assert(offsetof(USlateDebugInfo, Txt_TickTime) == 0x0002A0, "Member 'USlateDebugInfo::Txt_TickTime' has a wrong offset!");
//static_assert(offsetof(USlateDebugInfo, Txt_SlateRender) == 0x0002A8, "Member 'USlateDebugInfo::Txt_SlateRender' has a wrong offset!");
//static_assert(offsetof(USlateDebugInfo, Txt_WidgetRender) == 0x0002B0, "Member 'USlateDebugInfo::Txt_WidgetRender' has a wrong offset!");
//static_assert(offsetof(USlateDebugInfo, Txt_Prepass) == 0x0002B8, "Member 'USlateDebugInfo::Txt_Prepass' has a wrong offset!");
//static_assert(offsetof(USlateDebugInfo, Txt_NumBatches) == 0x0002C0, "Member 'USlateDebugInfo::Txt_NumBatches' has a wrong offset!");
//static_assert(offsetof(USlateDebugInfo, Txt_WidgetAllocSize) == 0x0002C8, "Member 'USlateDebugInfo::Txt_WidgetAllocSize' has a wrong offset!");
//static_assert(offsetof(USlateDebugInfo, GetStatInfoInterval) == 0x0002D0, "Member 'USlateDebugInfo::GetStatInfoInterval' has a wrong offset!");

// Class UnrealExtent.StatGroupInfoThresholdConfig
// 0x0050 (0x0080 - 0x0030)
class UStatGroupInfoThresholdConfig final : public UPrimaryDataAsset
{
public:
	TArray<struct FStatUISimulatedGraphicsCardScaleFactor> SimulatedGraphicsCardConfig;                       // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStatInfoThreshold>             ThresholdConfig;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor_Medium;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor_High;                                    // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor_Severe;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatGroupInfoThresholdConfig">();
	}
	static class UStatGroupInfoThresholdConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatGroupInfoThresholdConfig>();
	}
};
//static_assert(alignof(UStatGroupInfoThresholdConfig) == 0x000008, "Wrong alignment on UStatGroupInfoThresholdConfig");
//static_assert(sizeof(UStatGroupInfoThresholdConfig) == 0x000080, "Wrong size on UStatGroupInfoThresholdConfig");
//static_assert(offsetof(UStatGroupInfoThresholdConfig, SimulatedGraphicsCardConfig) == 0x000030, "Member 'UStatGroupInfoThresholdConfig::SimulatedGraphicsCardConfig' has a wrong offset!");
//static_assert(offsetof(UStatGroupInfoThresholdConfig, ThresholdConfig) == 0x000040, "Member 'UStatGroupInfoThresholdConfig::ThresholdConfig' has a wrong offset!");
//static_assert(offsetof(UStatGroupInfoThresholdConfig, TextColor_Medium) == 0x000050, "Member 'UStatGroupInfoThresholdConfig::TextColor_Medium' has a wrong offset!");
//static_assert(offsetof(UStatGroupInfoThresholdConfig, TextColor_High) == 0x000060, "Member 'UStatGroupInfoThresholdConfig::TextColor_High' has a wrong offset!");
//static_assert(offsetof(UStatGroupInfoThresholdConfig, TextColor_Severe) == 0x000070, "Member 'UStatGroupInfoThresholdConfig::TextColor_Severe' has a wrong offset!");

// Class UnrealExtent.TamerAsyncLineTraceManager
// 0x0110 (0x0138 - 0x0028)
class UTamerAsyncLineTraceManager final : public UObject
{
public:
	uint8                                         Pad_28[0xB8];                                      // 0x0028(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            VisibleCount;                                      // 0x00E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	int32                                         WaitTraceFrameCount;                               // 0x0130(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllData();
	bool GetAndCleanAsyncLineTraceResult(TArray<int32>* OutVisibleTamers, TArray<int32>* OutInvisibleTamers);
	void RegisterTamerRef(int32 InRefID, const struct FVector& InLocation, float InCapsuleHalfHeight);
	void StartAsyncLineTrace(const struct FVector& InPlayerLocation, const TArray<int32>& InTraceTamers);
	void UnregisterTamerRef(int32 InRefID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TamerAsyncLineTraceManager">();
	}
	static class UTamerAsyncLineTraceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTamerAsyncLineTraceManager>();
	}
};
//static_assert(alignof(UTamerAsyncLineTraceManager) == 0x000008, "Wrong alignment on UTamerAsyncLineTraceManager");
//static_assert(sizeof(UTamerAsyncLineTraceManager) == 0x000138, "Wrong size on UTamerAsyncLineTraceManager");
//static_assert(offsetof(UTamerAsyncLineTraceManager, VisibleCount) == 0x0000E0, "Member 'UTamerAsyncLineTraceManager::VisibleCount' has a wrong offset!");
//static_assert(offsetof(UTamerAsyncLineTraceManager, WaitTraceFrameCount) == 0x000130, "Member 'UTamerAsyncLineTraceManager::WaitTraceFrameCount' has a wrong offset!");

// Class UnrealExtent.VATAnimClipsInfoConfig
// 0x0018 (0x0048 - 0x0030)
class UVATAnimClipsInfoConfig final : public UPrimaryDataAsset
{
public:
	TArray<struct FVATAnimClipInfo>               ClipConfigs;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TotalFrames;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VATAnimClipsInfoConfig">();
	}
	static class UVATAnimClipsInfoConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVATAnimClipsInfoConfig>();
	}
};
//static_assert(alignof(UVATAnimClipsInfoConfig) == 0x000008, "Wrong alignment on UVATAnimClipsInfoConfig");
//static_assert(sizeof(UVATAnimClipsInfoConfig) == 0x000048, "Wrong size on UVATAnimClipsInfoConfig");
//static_assert(offsetof(UVATAnimClipsInfoConfig, ClipConfigs) == 0x000030, "Member 'UVATAnimClipsInfoConfig::ClipConfigs' has a wrong offset!");
//static_assert(offsetof(UVATAnimClipsInfoConfig, TotalFrames) == 0x000040, "Member 'UVATAnimClipsInfoConfig::TotalFrames' has a wrong offset!");

// Class UnrealExtent.VATAnimMachineInst
// 0x0088 (0x0300 - 0x0278)
class AVATAnimMachineInst final : public AActor
{
public:
	class UVATAnimClipsInfoConfig*                AnimClipsConfig;                                   // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVATAnimMachineConfig                  AnimMachineConfig;                                 // 0x0280(0x0028)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       DynamicMIs;                                        // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         DebugAnimProgress;                                 // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindParamLerpSpeed;                                // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLerpWindDirection;                                // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLerpWindIntensity;                                // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x3E];                                     // 0x02C2(0x003E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitVATAnimMachine();
	void PlayVATAnim();
	void StopVATAnim();
	void UpdateAnimProgress(float InAnimProgress);
	void UpdateAnimSpeed(float InPlaySpeed);
	void UpdateBlendRatio(float InBlendRatio);
	void UpdateWindDirection(const struct FVector2D& InWindDirection);
	void UpdateWindIntensity(float InWindIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VATAnimMachineInst">();
	}
	static class AVATAnimMachineInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVATAnimMachineInst>();
	}
};
//static_assert(alignof(AVATAnimMachineInst) == 0x000008, "Wrong alignment on AVATAnimMachineInst");
//static_assert(sizeof(AVATAnimMachineInst) == 0x000300, "Wrong size on AVATAnimMachineInst");
//static_assert(offsetof(AVATAnimMachineInst, AnimClipsConfig) == 0x000278, "Member 'AVATAnimMachineInst::AnimClipsConfig' has a wrong offset!");
//static_assert(offsetof(AVATAnimMachineInst, AnimMachineConfig) == 0x000280, "Member 'AVATAnimMachineInst::AnimMachineConfig' has a wrong offset!");
//static_assert(offsetof(AVATAnimMachineInst, DynamicMIs) == 0x0002A8, "Member 'AVATAnimMachineInst::DynamicMIs' has a wrong offset!");
//static_assert(offsetof(AVATAnimMachineInst, DebugAnimProgress) == 0x0002B8, "Member 'AVATAnimMachineInst::DebugAnimProgress' has a wrong offset!");
//static_assert(offsetof(AVATAnimMachineInst, WindParamLerpSpeed) == 0x0002BC, "Member 'AVATAnimMachineInst::WindParamLerpSpeed' has a wrong offset!");
//static_assert(offsetof(AVATAnimMachineInst, bLerpWindDirection) == 0x0002C0, "Member 'AVATAnimMachineInst::bLerpWindDirection' has a wrong offset!");
//static_assert(offsetof(AVATAnimMachineInst, bLerpWindIntensity) == 0x0002C1, "Member 'AVATAnimMachineInst::bLerpWindIntensity' has a wrong offset!");

// Class UnrealExtent.VATNiagaraInst
// 0x0008 (0x0280 - 0x0278)
class AVATNiagaraInst final : public AActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitVATNiagaraInst();
	void ResetNiagaraSystem();
	void ResetVATAnim();
	void UpdateNiagaraFloatVariable(const class FString& VariableName, const float TargetValue);
	void UpdateNiagaraVector2Variable(const class FString& VariableName, const struct FVector2D& TargetValue);
	void UpdateNiagaraVectorVariable(const class FString& VariableName, const struct FVector& TargetValue);
	void UpdateVATAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VATNiagaraInst">();
	}
	static class AVATNiagaraInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVATNiagaraInst>();
	}
};
//static_assert(alignof(AVATNiagaraInst) == 0x000008, "Wrong alignment on AVATNiagaraInst");
//static_assert(sizeof(AVATNiagaraInst) == 0x000280, "Wrong size on AVATNiagaraInst");

// Class UnrealExtent.VFXAutoPlayer
// 0x0070 (0x02E8 - 0x0278)
class AVFXAutoPlayer final : public AActor
{
public:
	TArray<class FString>                         PlayList;                                          // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class UNiagaraSystem*>                 InternalPlayList;                                  // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PlayingPtr;                                        // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLifeSpan;                                       // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoMovingRange;                                   // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoMovingSpeed;                                   // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x40];                                     // 0x02A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildPlayList(const class FString& InFolder);
	bool CurNiagaraStatusChanged(bool* bNumDecreased);
	void DestroyAllNiagaras();
	void FlushPlaying();
	TArray<class UNiagaraSystem*> GetInternalPlayList();
	bool ListCompletedPlaying();
	void PlayNiagara(int32 InTargetNiagaraPtr);
	void StartPlaying();
	void StopPlaying();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFXAutoPlayer">();
	}
	static class AVFXAutoPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVFXAutoPlayer>();
	}
};
//static_assert(alignof(AVFXAutoPlayer) == 0x000008, "Wrong alignment on AVFXAutoPlayer");
//static_assert(sizeof(AVFXAutoPlayer) == 0x0002E8, "Wrong size on AVFXAutoPlayer");
//static_assert(offsetof(AVFXAutoPlayer, PlayList) == 0x000278, "Member 'AVFXAutoPlayer::PlayList' has a wrong offset!");
//static_assert(offsetof(AVFXAutoPlayer, InternalPlayList) == 0x000288, "Member 'AVFXAutoPlayer::InternalPlayList' has a wrong offset!");
//static_assert(offsetof(AVFXAutoPlayer, PlayingPtr) == 0x000298, "Member 'AVFXAutoPlayer::PlayingPtr' has a wrong offset!");
//static_assert(offsetof(AVFXAutoPlayer, MaxLifeSpan) == 0x00029C, "Member 'AVFXAutoPlayer::MaxLifeSpan' has a wrong offset!");
//static_assert(offsetof(AVFXAutoPlayer, AutoMovingRange) == 0x0002A0, "Member 'AVFXAutoPlayer::AutoMovingRange' has a wrong offset!");
//static_assert(offsetof(AVFXAutoPlayer, AutoMovingSpeed) == 0x0002A4, "Member 'AVFXAutoPlayer::AutoMovingSpeed' has a wrong offset!");

}

