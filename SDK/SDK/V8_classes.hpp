#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: V8

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "V8_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class V8.JavascriptGeneratedFunction
// 0x0010 (0x00F0 - 0x00E0)
class UJavascriptGeneratedFunction final : public UFunction
{
public:
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptGeneratedFunction">();
	}
	static class UJavascriptGeneratedFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptGeneratedFunction>();
	}
};
//static_assert(alignof(UJavascriptGeneratedFunction) == 0x000008, "Wrong alignment on UJavascriptGeneratedFunction");
//static_assert(sizeof(UJavascriptGeneratedFunction) == 0x0000F0, "Wrong size on UJavascriptGeneratedFunction");

// Class V8.V8Config
// 0x0008 (0x0030 - 0x0028)
class UV8Config final : public UObject
{
public:
	bool                                          bGenAltPropAccessorForAllProp;                     // 0x0028(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenGetStructRefArrayFunction;                     // 0x0029(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"V8Config">();
	}
	static class UV8Config* GetDefaultObj()
	{
		return GetDefaultObjImpl<UV8Config>();
	}
};
//static_assert(alignof(UV8Config) == 0x000008, "Wrong alignment on UV8Config");
//static_assert(sizeof(UV8Config) == 0x000030, "Wrong size on UV8Config");
//static_assert(offsetof(UV8Config, bGenAltPropAccessorForAllProp) == 0x000028, "Member 'UV8Config::bGenAltPropAccessorForAllProp' has a wrong offset!");
//static_assert(offsetof(UV8Config, bGenGetStructRefArrayFunction) == 0x000029, "Member 'UV8Config::bGenGetStructRefArrayFunction' has a wrong offset!");

// Class V8.DirectoryWatcher
// 0x0058 (0x0080 - 0x0028)
class UDirectoryWatcher final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Added;                                             // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Modified;                                          // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Removed;                                           // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool Contains(const class FString& File);
	void Unwatch();
	void Watch(const class FString& Directory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectoryWatcher">();
	}
	static class UDirectoryWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectoryWatcher>();
	}
};
//static_assert(alignof(UDirectoryWatcher) == 0x000008, "Wrong alignment on UDirectoryWatcher");
//static_assert(sizeof(UDirectoryWatcher) == 0x000080, "Wrong size on UDirectoryWatcher");
//static_assert(offsetof(UDirectoryWatcher, Added) == 0x000040, "Member 'UDirectoryWatcher::Added' has a wrong offset!");
//static_assert(offsetof(UDirectoryWatcher, Modified) == 0x000050, "Member 'UDirectoryWatcher::Modified' has a wrong offset!");
//static_assert(offsetof(UDirectoryWatcher, Removed) == 0x000060, "Member 'UDirectoryWatcher::Removed' has a wrong offset!");
//static_assert(offsetof(UDirectoryWatcher, OnChanged) == 0x000070, "Member 'UDirectoryWatcher::OnChanged' has a wrong offset!");

// Class V8.JavascriptComponent
// 0x0088 (0x0138 - 0x00B0)
class UJavascriptComponent final : public UActorComponent
{
public:
	class FString                                 ScriptSourceFile;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveWithinEditor;                               // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJavascriptContext*                     JavascriptContext;                                 // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJavascriptIsolate*                     JavascriptIsolate;                                 // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float DeltaSeconds)>           OnTick;                                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnBeginPlay;                                       // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnEndPlay;                                         // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class FName Name)>             OnInvoke;                                          // 0x0108(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FJavascriptAsset>               Assets;                                            // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJavascriptClassAsset>          ClassAssets;                                       // 0x0128(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Expose(const class FString& ExposedAs, class UObject* Object);
	void ForceGC();
	void Invoke(class FName Name_0);
	void JavascriptNameSignature__DelegateSignature(class FName Name_0);
	void JavascriptNoParamSignature__DelegateSignature();
	void JavascriptTickSignature__DelegateSignature(float DeltaSeconds);
	class UObject* ResolveAsset(class FName Name_0, bool bTryLoad);
	class UClass* ResolveClass(class FName Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptComponent">();
	}
	static class UJavascriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptComponent>();
	}
};
//static_assert(alignof(UJavascriptComponent) == 0x000008, "Wrong alignment on UJavascriptComponent");
//static_assert(sizeof(UJavascriptComponent) == 0x000138, "Wrong size on UJavascriptComponent");
//static_assert(offsetof(UJavascriptComponent, ScriptSourceFile) == 0x0000B0, "Member 'UJavascriptComponent::ScriptSourceFile' has a wrong offset!");
//static_assert(offsetof(UJavascriptComponent, bActiveWithinEditor) == 0x0000C0, "Member 'UJavascriptComponent::bActiveWithinEditor' has a wrong offset!");
//static_assert(offsetof(UJavascriptComponent, JavascriptContext) == 0x0000C8, "Member 'UJavascriptComponent::JavascriptContext' has a wrong offset!");
//static_assert(offsetof(UJavascriptComponent, JavascriptIsolate) == 0x0000D0, "Member 'UJavascriptComponent::JavascriptIsolate' has a wrong offset!");
//static_assert(offsetof(UJavascriptComponent, OnTick) == 0x0000D8, "Member 'UJavascriptComponent::OnTick' has a wrong offset!");
//static_assert(offsetof(UJavascriptComponent, OnBeginPlay) == 0x0000E8, "Member 'UJavascriptComponent::OnBeginPlay' has a wrong offset!");
//static_assert(offsetof(UJavascriptComponent, OnEndPlay) == 0x0000F8, "Member 'UJavascriptComponent::OnEndPlay' has a wrong offset!");
//static_assert(offsetof(UJavascriptComponent, OnInvoke) == 0x000108, "Member 'UJavascriptComponent::OnInvoke' has a wrong offset!");
//static_assert(offsetof(UJavascriptComponent, Assets) == 0x000118, "Member 'UJavascriptComponent::Assets' has a wrong offset!");
//static_assert(offsetof(UJavascriptComponent, ClassAssets) == 0x000128, "Member 'UJavascriptComponent::ClassAssets' has a wrong offset!");

// Class V8.JavascriptContext
// 0x0030 (0x0058 - 0x0028)
class UJavascriptContext final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Paths;                                             // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void CreateInspector(int32 Port);
	void DestroyInspector();
	void Expose(const class FString& Name_0, class UObject* Object);
	void FindPathFile(const class FString& TargetRootPath, const class FString& TargetFileName, TArray<class FString>* OutFiles);
	class FString GetScriptFileFullPath(const class FString& Filename);
	class FString ReadScriptFile(const class FString& Filename);
	void RegisterConsoleCommand(const class FString& Command, const class FString& Help, const struct FJavascriptFunction& Function);
	void RequestV8GarbageCollection();
	void RunFile(const class FString& Filename);
	class FString RunScript(const class FString& Script, bool bOutput);
	void SetContextId(const class FString& Name_0);
	void UnregisterConsoleCommand(const class FString& Command);
	bool WriteAliases(const class FString& Target);
	bool WriteDTS(const class FString& Target, bool bIncludingTooltip);

	bool IsDebugContext() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptContext">();
	}
	static class UJavascriptContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptContext>();
	}
};
//static_assert(alignof(UJavascriptContext) == 0x000008, "Wrong alignment on UJavascriptContext");
//static_assert(sizeof(UJavascriptContext) == 0x000058, "Wrong size on UJavascriptContext");
//static_assert(offsetof(UJavascriptContext, Paths) == 0x000048, "Member 'UJavascriptContext::Paths' has a wrong offset!");

// Class V8.JavascriptDelegate
// 0x0018 (0x0040 - 0x0028)
class UJavascriptDelegate final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Fire();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptDelegate">();
	}
	static class UJavascriptDelegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptDelegate>();
	}
};
//static_assert(alignof(UJavascriptDelegate) == 0x000008, "Wrong alignment on UJavascriptDelegate");
//static_assert(sizeof(UJavascriptDelegate) == 0x000040, "Wrong size on UJavascriptDelegate");

// Class V8.JavascriptGeneratedClass
// 0x0010 (0x0338 - 0x0328)
class UJavascriptGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptGeneratedClass">();
	}
	static class UJavascriptGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptGeneratedClass>();
	}
};
//static_assert(alignof(UJavascriptGeneratedClass) == 0x000008, "Wrong alignment on UJavascriptGeneratedClass");
//static_assert(sizeof(UJavascriptGeneratedClass) == 0x000338, "Wrong size on UJavascriptGeneratedClass");

// Class V8.JavascriptGeneratedClass_Native
// 0x0010 (0x0338 - 0x0328)
class UJavascriptGeneratedClass_Native final : public UBlueprintGeneratedClass
{
public:
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptGeneratedClass_Native">();
	}
	static class UJavascriptGeneratedClass_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptGeneratedClass_Native>();
	}
};
//static_assert(alignof(UJavascriptGeneratedClass_Native) == 0x000008, "Wrong alignment on UJavascriptGeneratedClass_Native");
//static_assert(sizeof(UJavascriptGeneratedClass_Native) == 0x000338, "Wrong size on UJavascriptGeneratedClass_Native");

// Class V8.JavascriptGlobalDelegates
// 0x0050 (0x0078 - 0x0028)
class UJavascriptGlobalDelegates final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Bind(const class FString& Key);
	void LevelAddedToWorld(class ULevel* Level, class UWorld* World);
	void LevelRemovedFromWorld(class ULevel* Level, class UWorld* World);
	void OnActorLabelChanged(class AActor* Actor);
	void OnAssetLoaded(class UObject* Object);
	void OnObjectModified(class UObject* Object);
	void OnObjectPropertyChanged_Friendly(class UObject* InObject, const TFieldPath<struct FProperty>& Property, const TFieldPath<struct FProperty>& MemberProperty, int32 ChangeType);
	void OnObjectSaved(class UObject* Object);
	void OnPostDuplicate_Friendly(class UWorld* World, bool bDuplicateForPIE);
	void OnPostWorldCreation(class UWorld* World);
	void OnPostWorldInitialization_Friendly(class UWorld* World);
	void OnPreObjectPropertyChanged_Friendly(class UObject* InObject, const TFieldPath<struct FProperty>& Property, const TFieldPath<struct FProperty>& MemberProperty);
	void OnPreWorldFinishDestroy(class UWorld* World);
	void OnPreWorldInitialization_Friendly(class UWorld* World);
	void OnWorldCleanup(class UWorld* World, bool bSessionEnded, bool bCleanupResources);
	void PackageCreatedForLoad(class UPackage* InPackage);
	void PostApplyLevelOffset(class ULevel* Level, class UWorld* World, const struct FVector& Offset, bool Flag);
	void PostDemoPlay();
	void PostGarbageCollect();
	void PostLoadMapWithWorld(class UWorld* World);
	void PreGarbageCollectDelegate();
	void PreLoadMap(const class FString& MapName);
	void RedirectorFollowed(const class FString& PackageName, class UObject* Redirector);
	void Unbind(const class FString& Key);
	void UnbindAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptGlobalDelegates">();
	}
	static class UJavascriptGlobalDelegates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptGlobalDelegates>();
	}
};
//static_assert(alignof(UJavascriptGlobalDelegates) == 0x000008, "Wrong alignment on UJavascriptGlobalDelegates");
//static_assert(sizeof(UJavascriptGlobalDelegates) == 0x000078, "Wrong size on UJavascriptGlobalDelegates");

// Class V8.JavascriptStaticCache
// 0x0018 (0x0040 - 0x0028)
class UJavascriptStaticCache final : public UObject
{
public:
	TArray<class UJavascriptIsolate*>             Isolates;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bExecuteTestModePIE;                               // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptStaticCache">();
	}
	static class UJavascriptStaticCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptStaticCache>();
	}
};
//static_assert(alignof(UJavascriptStaticCache) == 0x000008, "Wrong alignment on UJavascriptStaticCache");
//static_assert(sizeof(UJavascriptStaticCache) == 0x000040, "Wrong size on UJavascriptStaticCache");
//static_assert(offsetof(UJavascriptStaticCache, Isolates) == 0x000028, "Member 'UJavascriptStaticCache::Isolates' has a wrong offset!");
//static_assert(offsetof(UJavascriptStaticCache, bExecuteTestModePIE) == 0x000038, "Member 'UJavascriptStaticCache::bExecuteTestModePIE' has a wrong offset!");

// Class V8.JavascriptIsolate
// 0x0010 (0x0038 - 0x0028)
class UJavascriptIsolate final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UJavascriptContext* CreateContext();
	void GetHeapStatistics(struct FJavascriptHeapStatistics* Statistics);
	void Init(bool bIsEditor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptIsolate">();
	}
	static class UJavascriptIsolate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptIsolate>();
	}
};
//static_assert(alignof(UJavascriptIsolate) == 0x000008, "Wrong alignment on UJavascriptIsolate");
//static_assert(sizeof(UJavascriptIsolate) == 0x000038, "Wrong size on UJavascriptIsolate");

// Class V8.JavascriptLibrary
// 0x0000 (0x0028 - 0x0028)
class UJavascriptLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UWorld* Actor_GetWorld(class AActor* Actor);
	static void AddDynamicBinding(class UClass* Outer_0, class UDynamicBlueprintBinding* BindingObject);
	static void AddMessage(const struct FJavascriptStat& Stat, EJavascriptStatOperation InStatOperation);
	static void AddMessage_float(const struct FJavascriptStat& Stat, EJavascriptStatOperation InStatOperation, float Value, bool bIsCycle);
	static void AddMessage_int(const struct FJavascriptStat& Stat, EJavascriptStatOperation InStatOperation, int32 Value, bool bIsCycle);
	static void CallJS(const struct FJavascriptFunction& Function, const struct FJavascriptStubStruct& CustomStruct);
	static void ClipboardCopy(const class FString& String);
	static class FString ClipboardPaste();
	static class FString ConvertRelativePathToFull(class UObject* Object, const class FString& RelativePath);
	static class UEnum* CreateEnum(class UObject* Outer_0, class FName Name_0, const TArray<class FName>& DisplayNames, const TArray<class FString>& Flags_0);
	static struct FJavascriptInternetAddr CreateInternetAddr();
	static struct FJavascriptLogCategory CreateLogCategory(const class FString& CategoryName, ELogVerbosity_JS InDefaultVerbosity);
	static class UPackage* CreatePackage(class UObject* Outer_0, const class FString& PackageName);
	static struct FJavascriptSocket CreateSocket(class FName SocketType, const class FString& Description, bool bForceUDP);
	static struct FJavascriptStreamableManager CreateStreamableManager();
	static bool DeleteDirectory(const class FString& Path, bool RequireExists, bool Tree);
	static bool DeleteFile(const class FString& Filename, bool ReadOnly);
	static bool DirectoryExists(const class FString& InDirectory);
	static class UObject* Duplicate(class UObject* Object, class UObject* Outer_0, class FName Name_0);
	static bool FileExists(const class FString& Filename);
	static class UObject* FindObjectWithOuter(class UObject* Outer_0, class UClass* ClassToLookFor, class FName NameToLookFor);
	static class UPackage* FindPackage(class UObject* InOuter, const class FString& PackageName);
	static void GenerateNavigation(class UWorld* InWorld, class ARecastNavMesh* NavData);
	static void GetAllActorsOfClassAndTags(class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const TArray<class FName>& Tags_Accept, const TArray<class FName>& Tags_Deny, TArray<class AActor*>* OutActors);
	static void GetAllActorsOfClassAndTagsInCurrentLevel(class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const TArray<class FName>& Tags_Accept, const TArray<class FName>& Tags_Deny, TArray<class AActor*>* OutActors);
	static class FString GetArchetypePathName(class UObject* Object);
	static class FString GetBailoutReason(const struct FJavascriptProfileNode& Node);
	static class UClass* GetBlueprintGeneratedClass(class UBlueprint* Blueprint);
	static class UClass* GetBlueprintGeneratedClassFromPath(const class FString& Path);
	static int32 GetCallUid(const struct FJavascriptProfileNode& Node);
	static class FName GetCategoryName(const struct FJavascriptLogCategory& Category);
	static struct FJavascriptProfileNode GetChild(const struct FJavascriptProfileNode& Node, int32 Index_0);
	static int32 GetChildrenCount(const struct FJavascriptProfileNode& Node);
	static class FString GetClassPathName(class UClass* Class_0);
	static int32 GetColumnNumber(const struct FJavascriptProfileNode& Node);
	static TArray<class UActorComponent*> GetComponentsByClass(class AActor* Actor, TSubclassOf<class UActorComponent> ComponentClass);
	static int32 GetCurrentProcessId();
	static class FString GetDeoptInfo_Reason(const struct FJavascriptProfileNode& Node, int32 Index_0);
	static class FString GetDeoptInfo_Stack(const struct FJavascriptProfileNode& Node, int32 Index_0);
	static int32 GetDeoptInfosCount(const struct FJavascriptProfileNode& Node, int32 Index_0);
	static void GetDerivedClasses(class UClass* ClassToLookFor, TArray<class UClass*>* Results, bool bRecursive);
	static class FString GetDir(class UObject* Object, const class FString& WhichDir);
	static class UDynamicBlueprintBinding* GetDynamicBinding(class UClass* Outer_0, TSubclassOf<class UDynamicBlueprintBinding> BindingObjectClass);
	static TArray<class UField*> GetFields(const class UObject* Object, bool bIncludeSuper);
	static int32 GetFileSize(class UObject* Object, const class FString& Filename);
	static class FString GetFunctionName(const struct FJavascriptProfileNode& Node);
	static int32 GetFunctionParmsSize(class UFunction* Function);
	static int32 GetHitCount(const struct FJavascriptProfileNode& Node);
	static int32 GetHitLineCount(const struct FJavascriptProfileNode& Node);
	static float GetLastRenderTime(class AActor* Actor);
	static class ULevel* GetLevel(class AActor* Actor);
	static TArray<class ULevel*> GetLevels(class UWorld* World);
	static int32 GetLineNumber(const struct FJavascriptProfileNode& Node);
	static class FString GetMetaData(class UField* Field, const class FString& Key);
	static class UModel* GetModel(class UWorld* World);
	static class FString GetName(class UObject* Object);
	static int32 GetNodeId(const struct FJavascriptProfileNode& Node);
	static void GetObjectsOfClass(class UClass* ClassToLookFor, TArray<class UObject*>* Results, bool bIncludeDerivedClasses, int32 ExcludeFlags, int32 ExclusionInternalFlags);
	static void GetObjectsWithOuter(const class UObject* Outer_0, TArray<class UObject*>* Results, bool bIncludeNestedObjects, int32 ExclusionFlags, int32 ExclusionInternalFlags);
	static class UObject* GetOuter(class UObject* Object);
	static class UObject* GetOutermost(class UObject* Object);
	static class FString GetPlatformName();
	static int32 GetScriptId(const struct FJavascriptProfileNode& Node);
	static class FString GetScriptResourceName(const struct FJavascriptProfileNode& Node);
	static TArray<struct FJavscriptProperty> GetStructProperties(const class FString& StructName, bool bIncludeSuper);
	static TArray<class UClass*> GetSuperClasses(class UClass* InClass);
	static struct FBox GetWorldBounds(class UWorld* InWorld);
	static void HandleSeamlessTravelPlayer(class AGameModeBase* GameMode, class AController** C);
	static bool HasAnyFlags(class UObject* Object, int32 Flags_0);
	static bool HasAnyPackageFlags(class UPackage* Package, int32 Flags_0);
	static bool HasUndo(class UEngine* Engine);
	static bool IsAsyncLoadComplete(const struct FJavascriptStreamableManager& Manager, const struct FSoftObjectPath& Target);
	static bool IsGameWorld(class UWorld* World);
	static bool IsGeneratedByBlueprint(class UClass* InClass);
	static bool IsPendingKill(class AActor* InActor);
	static bool IsPlayInEditor(class UWorld* World);
	static bool IsPlayInPreview(class UWorld* World);
	static bool IsRegistered(class UActorComponent* ActorComponent);
	static bool IsSuppressed(const struct FJavascriptLogCategory& Category, ELogVerbosity_JS Verbosity);
	static class UPackage* LoadPackage(class UPackage* InOuter, const class FString& PackageName);
	static void Log(const struct FJavascriptLogCategory& Category, ELogVerbosity_JS Verbosity, const class FString& Message, const class FString& Filename, int32 LineNumber);
	static bool MakeDirectory(const class FString& Path, bool Tree);
	static void MarkRenderStateDirty(class UActorComponent* Component);
	static struct FJavascriptStat NewStat(class FName InStatName, const class FString& InStatDesc, class FName InGroupName, class FName InGroupCategory, const class FString& InGroupDesc, bool bDefaultEnable, bool bShouldClearEveryFrame, EJavascriptStatDataType InStatType, bool bCycleStat, bool bSortByName);
	static bool ReadDirectory(class UObject* Object, const class FString& Directory, TArray<struct FDirectoryItem>* OutItems);
	static bool ReadFile(class UObject* Object, const class FString& Filename);
	static class FString ReadStringFromFile(class UObject* Object, const class FString& Filename);
	static struct FReadStringFromFileHandle ReadStringFromFileAsync(class UObject* Object, const class FString& Filename, const struct FJavascriptFunction& Function);
	static void RegisterComponent(class UActorComponent* ActorComponent);
	static void RequestAsyncLoad(const struct FJavascriptStreamableManager& Manager, const TArray<struct FSoftObjectPath>& TargetsToStream, const struct FJavascriptFunction& DelegateToCall, int32 Priority);
	static void ReregisterAllComponents(class AActor* Actor);
	static void ReregisterComponent(class UActorComponent* ActorComponent);
	static bool ResolveIp(const class FString& HostName, class FString* OutIp);
	static bool SegmentIntersection2D(const struct FVector& SegmentStartA, const struct FVector& SegmentEndA, const struct FVector& SegmentStartB, const struct FVector& SegmentEndB, struct FVector* IntersectionPoint);
	static bool SendMemoryTo(struct FJavascriptSocket* Socket, const struct FJavascriptInternetAddr& ToAddr, int32 NumBytes, int32* BytesSent);
	static void SetActorFlags(class AActor* Actor, int32 Flags_0);
	static void SetClientTravel(class UEngine* Engine, class UWorld* InWorld, const class FString& NextURL, ETravelType InTravelType);
	static void SetIp(struct FJavascriptInternetAddr* Addr, const class FString& ResolvedAddress, bool* bValid);
	static void SetMobile(class USceneComponent* SceneComponent);
	static void SetMobility(class USceneComponent* SceneComponent, EComponentMobility Type);
	static void SetObjectFlags(class UObject* Obj, int32 Flags_0);
	static void SetPort(struct FJavascriptInternetAddr* Addr, int32 Port);
	static void SetRootComponent(class AActor* Actor, class USceneComponent* Component);
	static void SimpleAsyncLoad(const struct FJavascriptStreamableManager& Manager, const struct FSoftObjectPath& Target, int32 Priority);
	static class UObject* TryLoadByPath(const class FString& Path);
	static void Unload(const struct FJavascriptStreamableManager& Manager, const struct FSoftObjectPath& Target);
	static void UnregisterComponent(class UActorComponent* ActorComponent);
	static void V8_SetFlagsFromString(const class FString& V8Flags);
	static void V8_SetIdleTaskBudget(float BudgetInSeconds);
	static bool WriteFile(class UObject* Object, const class FString& Filename);
	static bool WriteStringToFile(class UObject* Object, const class FString& Filename, const class FString& Data, EJavascriptEncodingOptions EncodingOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptLibrary">();
	}
	static class UJavascriptLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptLibrary>();
	}
};
//static_assert(alignof(UJavascriptLibrary) == 0x000008, "Wrong alignment on UJavascriptLibrary");
//static_assert(sizeof(UJavascriptLibrary) == 0x000028, "Wrong size on UJavascriptLibrary");

// Class V8.JavascriptMemoryObject
// 0x0000 (0x0028 - 0x0028)
class UJavascriptMemoryObject : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptMemoryObject">();
	}
	static class UJavascriptMemoryObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptMemoryObject>();
	}
};
//static_assert(alignof(UJavascriptMemoryObject) == 0x000008, "Wrong alignment on UJavascriptMemoryObject");
//static_assert(sizeof(UJavascriptMemoryObject) == 0x000028, "Wrong size on UJavascriptMemoryObject");

// Class V8.JavascriptObject
// 0x0020 (0x0048 - 0x0028)
class UJavascriptObject final : public UObject
{
public:
	struct FJavascriptRef                         Ref;                                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJavascriptFunction                    Func_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptObject">();
	}
	static class UJavascriptObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptObject>();
	}
};
//static_assert(alignof(UJavascriptObject) == 0x000008, "Wrong alignment on UJavascriptObject");
//static_assert(sizeof(UJavascriptObject) == 0x000048, "Wrong size on UJavascriptObject");
//static_assert(offsetof(UJavascriptObject, Ref) == 0x000028, "Member 'UJavascriptObject::Ref' has a wrong offset!");
//static_assert(offsetof(UJavascriptObject, Func_0) == 0x000038, "Member 'UJavascriptObject::Func_0' has a wrong offset!");

// Class V8.JavascriptOutputDevice
// 0x0010 (0x0038 - 0x0028)
class UJavascriptOutputDevice final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void Log(class FName Category, ELogVerbosity_JS Verbosity, const class FString& Filename, int32 LineNumber, const class FString& Message);

	void Kill();
	void OnMessage(const class FString& Message, ELogVerbosity_JS Verbosity, class FName Category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptOutputDevice">();
	}
	static class UJavascriptOutputDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptOutputDevice>();
	}
};
//static_assert(alignof(UJavascriptOutputDevice) == 0x000008, "Wrong alignment on UJavascriptOutputDevice");
//static_assert(sizeof(UJavascriptOutputDevice) == 0x000038, "Wrong size on UJavascriptOutputDevice");

// Class V8.JavascriptProcess
// 0x0020 (0x0048 - 0x0028)
class UJavascriptProcess final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CanLaunchURL(const class FString& URL);
	static class UJavascriptProcess* Create(const class FString& URL, const class FString& Parms_0, bool bLaunchDetached, bool bLaunchHidden, bool bLaunchReallyHidden, int32 PriorityModifier, const class FString& OptionalWorkingDirectory, bool bUsePipe);
	static class FString GetApplicationName(int32 ProcessId);
	static int32 GetCurrentProcessId();
	static class FString GetEnvironmentVar(const class FString& VarName);
	static class FString GetString(const class FString& Key, bool bFlag);
	static bool IsApplicationRunning(const class FString& ProcName);
	static bool IsApplicationRunning_PID(int32 ProcessId);
	static void LaunchURL(const class FString& URL, const class FString& Parms_0, class FString* Error);
	static class UJavascriptProcess* Open(const class FString& ProcName);
	static class UJavascriptProcess* Open_PID(int32 ProcessId);
	static void SetEnvironmentVar(const class FString& VarName, const class FString& VarValue);
	static void SimulateKeypress(int32 KeyEvent);
	static void Sleep(float Seconds);

	void Close();
	bool GetReturnCode(int32* ReturnCode);
	bool IsRunning();
	bool ReadArrayFromPipe(TArray<uint8>* Array);
	class FString ReadFromPipe();
	void Terminate(bool KillTree);
	void Wait();
	bool WriteToPipe(const class FString& Message, class FString* OutWritten);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptProcess">();
	}
	static class UJavascriptProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptProcess>();
	}
};
//static_assert(alignof(UJavascriptProcess) == 0x000008, "Wrong alignment on UJavascriptProcess");
//static_assert(sizeof(UJavascriptProcess) == 0x000048, "Wrong size on UJavascriptProcess");

// Class V8.JavascriptProfile
// 0x0008 (0x0030 - 0x0028)
class UJavascriptProfile final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetIdle(const struct FJavascriptCpuProfiler& Profiler, bool Is_idle);
	static void SetSamplingInterval(const struct FJavascriptCpuProfiler& Profiler, int32 Us);
	static struct FJavascriptCpuProfiler Start(const class FString& Title, bool bRecordSamples);
	static class UJavascriptProfile* Stop(const struct FJavascriptCpuProfiler& Profiler, const class FString& Title);

	struct FJavascriptProfileNode GetSample(int32 Index_0);
	int32 GetSamplesCount();
	float GetSampleTimestamp(int32 Index_0);
	struct FJavascriptProfileNode GetTopDownRoot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptProfile">();
	}
	static class UJavascriptProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptProfile>();
	}
};
//static_assert(alignof(UJavascriptProfile) == 0x000008, "Wrong alignment on UJavascriptProfile");
//static_assert(sizeof(UJavascriptProfile) == 0x000030, "Wrong size on UJavascriptProfile");

// Class V8.JavascriptSemaphore
// 0x0008 (0x0030 - 0x0028)
class UJavascriptSemaphore final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJavascriptSemaphore* Create(const class FName& Name_0, bool bCreate, int32 MaxLocks);

	void Dispose();
	void Lock();
	bool TryLock(int32 NanosecondsToWait);
	void Unlock();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptSemaphore">();
	}
	static class UJavascriptSemaphore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptSemaphore>();
	}
};
//static_assert(alignof(UJavascriptSemaphore) == 0x000008, "Wrong alignment on UJavascriptSemaphore");
//static_assert(sizeof(UJavascriptSemaphore) == 0x000030, "Wrong size on UJavascriptSemaphore");

// Class V8.JavascriptSettings
// 0x0010 (0x0038 - 0x0028)
class UJavascriptSettings final : public UObject
{
public:
	class FString                                 V8Flags;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptSettings">();
	}
	static class UJavascriptSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptSettings>();
	}
};
//static_assert(alignof(UJavascriptSettings) == 0x000008, "Wrong alignment on UJavascriptSettings");
//static_assert(sizeof(UJavascriptSettings) == 0x000038, "Wrong size on UJavascriptSettings");
//static_assert(offsetof(UJavascriptSettings, V8Flags) == 0x000028, "Member 'UJavascriptSettings::V8Flags' has a wrong offset!");

// Class V8.JavascriptSharedMemoryRegion
// 0x0008 (0x0030 - 0x0028)
class UJavascriptSharedMemoryRegion final : public UJavascriptMemoryObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJavascriptSharedMemoryRegion* Create(const class FName& Name_0, bool bCreate, bool bRead, bool bWrite, int32 Size);

	void Dispose();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptSharedMemoryRegion">();
	}
	static class UJavascriptSharedMemoryRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptSharedMemoryRegion>();
	}
};
//static_assert(alignof(UJavascriptSharedMemoryRegion) == 0x000008, "Wrong alignment on UJavascriptSharedMemoryRegion");
//static_assert(sizeof(UJavascriptSharedMemoryRegion) == 0x000030, "Wrong size on UJavascriptSharedMemoryRegion");

// Class V8.JavascriptTestLibrary
// 0x0000 (0x0028 - 0x0028)
class UJavascriptTestLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAnalyticsItem(const struct FJavascriptAutomatedTestInstance& Test, const class FString& InAnalyticsItem);
	static void AddError(const struct FJavascriptAutomatedTestInstance& Test, const class FString& InError);
	static void AddLogItem(const struct FJavascriptAutomatedTestInstance& Test, const class FString& InLogItem);
	static void AddWarning(const struct FJavascriptAutomatedTestInstance& Test, const class FString& InWarning);
	static void BeginPlay(class UWorld* World);
	static void ClearExecutionInfo(const struct FJavascriptAutomatedTestInstance& Test);
	static struct FJavascriptAutomatedTestInstance Create(const struct FJavascriptAutomatedTest& Test);
	static void Destroy(struct FJavascriptAutomatedTestInstance* Test);
	static void DestroyUObject(class UObject* Object);
	static void DestroyWorld(class UWorld* World);
	static void InitializeActorsForPlay(class UWorld* World, const struct FURL& URL);
	static class UWorld* NewWorld();
	static void PopFrameCounter();
	static void PushFrameCounter();
	static void SetContinue(const struct FJavascriptAutomatedTestInstance& Test, bool bInContinue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JavascriptTestLibrary">();
	}
	static class UJavascriptTestLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJavascriptTestLibrary>();
	}
};
//static_assert(alignof(UJavascriptTestLibrary) == 0x000008, "Wrong alignment on UJavascriptTestLibrary");
//static_assert(sizeof(UJavascriptTestLibrary) == 0x000028, "Wrong size on UJavascriptTestLibrary");

}

